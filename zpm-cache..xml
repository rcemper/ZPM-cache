<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="%ZPM.AbstractInstaller">
<Description>
Abstract base class that defines the interface for product-level
Installer.Install classes.</Description>
<Abstract>1</Abstract>
<TimeCreated>65797,80971.32924</TimeCreated>

<Parameter name="Version">
<Abstract>1</Abstract>
</Parameter>

<Parameter name="MaintenanceVersion">
</Parameter>

<Method name="OnInstallComponent">
<Description><![CDATA[
Callback that is invoked during product installation to allow for
system-level changes to be performed. Common examples of such changes include:
<ul>
<li>Definition of resources and roles</li>
<li>Definition/configuration of the product library database</li>
<li>Import of localized messages for the product</li>
</ul>
Subclasses SHOULD override this method.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDatabase:%String,pVerbose:%Boolean=0,pDevMode:%Boolean=0,pIsUpgrade:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnUnInstallComponent">
<Description>
Callback that is invoked when removing a product.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDatabase:%String,pVerbose:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnComponentVersion">
<Description><![CDATA[
Callback to return the major version of the component. This implementation uses the <parameter>Version</parameter>, 
which must by implemented by the installer subclass (or else the subclass must override this method using some other approach). 
If not overridden, and the Version parameter is not populated, this method will throw an exception (not merely return an error status). 
<var>pMajorVersion</var> is generally set to the value of a product-level macro which defines
the major version, e.g. <code>$$$HSLIBmajorVersion</code> for PackageManager Core.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pMajorVersion:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	kill pMajorVersion
	Set pMajorVersion = ..#Version
	if pMajorVersion = "" {
		$$$ThrowStatus($$$ERROR($$$NotImplemented))
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnComponentMaintenanceVersion">
<Description><![CDATA[
Callback to return the minor version of the component. This implementation uses the <parameter>MaintenanceVersion</parameter>, 
which must by implemented by the installer subclass (or else the subclass must override this method using some other approach). 
If not overridden, and the Version parameter is not populated, this method will throw an exception (not merely return an error status). 
<var>pMinorVersion</var> is generally set to the value of a product-level macro which defines
the minor version, e.g. <code>$$$HSLIBminorVersion</code> for PackageManager Core.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pMinorVersion:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	kill pMinorVersion
	Set pMinorVersion = ..#MaintenanceVersion
	if pMinorVersion = "" {
		$$$ThrowStatus($$$ERROR($$$NotImplemented))
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnConfigureComponent">
<Description><![CDATA[
<p>Callback that is invoked during namespace (re)activation.
Subclasses SHOULD override this method. </p><p>
pVars is an array of miscellaneous information, populated by the calling code in the installation/configuration 
framework (mainly <class>HS.Util.Installer</class>). 
Subscripts appearing in pVars include: </p>
<ul><li>
Production - set to (namespace)_"PKG.FoundationProduction"
</li><li>
LogFile - current log file for install operation 
</li><li>
Upgrade - boolean, indicating whether the current operation is an upgrade
</li><li>
Type - hardcoded to "Foundation"
</li><li>
Component - current component name
</li></ul>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pNamespace:%String,pVerbose:%Boolean=0,&pVars]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnUnconfigureComponent">
<Description>
Callback that is invoked when removing a product from a namespace.
Subclasses SHOULD override this method.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pNamespace:%String,pVerbose:%Boolean=0,pPurgeFiles:%Boolean=0,&pVars]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnUpgradeSteps">
<Description>
What to do system wide (not specific namespaces) during an upgrade. Not currently called by the framework, but present for future use. </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPreviousVersion:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// note: if we adopt this then we may need to revisit the argument list - pPreviousVersion is ambiguous about major/minor
	set tSC = $$$OK
	
	try {
	} catch ex {
		Set tSC=ex.AsStatus()
	}
	
	quit tSC
]]></Implementation>
</Method>

<XData name="InstallationInfo">
<Description><![CDATA[
XML block that should contain XML for a <class>%ZPM.Component</class>
instance that describes the current component.
Note that this XML may make use of the following expressions that will be substituted during parsing:
<ul>
<li><code>{$expression{COSExpression}}</code></li>
<li><code>{$method{COSExpression}}</code></li>
</ul>
Where <code>COSExpression</code> is a valid expression.
An example of such an expression would be as follows:
<example language="none">
&lt;Version>{$expression{$parameter("Installer.Install","Version")}}&lt;/Version>
</example>]]></Description>
</XData>
</Class>


<Class name="%ZPM.Installer">
<Super>%Projection.AbstractProjection</Super>
<TimeCreated>65797,77643.762604</TimeCreated>

<Projection name="Reference">
<Type>Installer</Type>
</Projection>

<Parameter name="VERSION">
<Description>
Version used for autoinstall release</Description>
<Default>0.2.14-cache</Default>
</Parameter>

<Parameter name="FILESCOUNT">
<Description>
Number of files for autoinstall release</Description>
</Parameter>

<XData name="PM">
<Description>
Application Definition</Description>
<XMLNamespace>INSTALLER</XMLNamespace>
<Data><![CDATA[
<Manifest>
<Default Name="MODDIR" Dir="${MGRDIR}zpm" />
<Default Name="SRCDIR" Dir="${MODDIR}src" />
<Default Name="REGISTRY" Value="https://pm.community.intersystems.com" />
<Default Name="TRACKINGID" Value="UA-126752118-1" />

<Namespace Name="%SYS">
  <Import File="${SRCDIR}inc/_ZPM/PackageManager/Common.inc" />
  <Import File="${SRCDIR}inc/_ZPM/cache.inc" />
  <Import File="${SRCDIR}inc/_ZPM/filetempdir.inc" />
  <Import File="${SRCDIR}cls" Recurse="1" />
  
  <Invoke Class="%ZPM.PackageManager" Method="UpdateLanguageExtensions" CheckStatus="true" />
  <Invoke Class="%ZPM.Installer" Method="ZPMInit" CheckStatus="true">
    <Arg Value="${REGISTRY}"/> 
    <Arg Value="${TRACKINGID}"/>
  </Invoke>
  <Invoke Class="%ZPM.Installer" Method="ZPMLoad" CheckStatus="true">
    <Arg Value="${MODDIR}"/>
  </Invoke>
  <Invoke Class="%ZPM.Installer" Method="ZPMCompile" CheckStatus="true" />
</Namespace>

</Manifest>
]]></Data>
</XData>

<Method name="setup">
<Description>
This is a method generator whose code is generated by XGL.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[&pVars,pLogLevel:%Integer,pInstaller:%Installer.Installer,pLogger:%Installer.AbstractLogger]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #; Let our XGL document generate code for this method. 
  Do %code.WriteLine(" If $Data(pVars, path)#10,path'="""" Set pVars(""MODDIR"")=path")
  Quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "PM")
]]></Implementation>
</Method>

<Method name="AsyncSetup">
<ClassMethod>1</ClassMethod>
<FormalSpec>Args...</FormalSpec>
<Implementation><![CDATA[
  Try {
    Set tSC = ..setup(Args...)
  } Catch ex {
    Set tSC = ex.AsStatus()
  }  
  Do $System.Event.Signal($ZParent, tSC)
]]></Implementation>
</Method>

<Method name="ZPMInit">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRegistry:%String="",pAnalyticsTrackingID:%String=""</FormalSpec>
<Implementation><![CDATA[
    If (pRegistry'="") {
      $$$QuitOnError(##class(%ZPM.PackageManager).Shell("repo -t registry -name registry -url "_ pRegistry))
    }
    $$$QuitOnError(##class(%ZPM.PackageManager.Client.Settings).SetDefaultRegistry(pRegistry))
    $$$QuitOnError(##class(%ZPM.PackageManager.Client.Settings).SetAnalyticsAvailable(1))
    $$$QuitOnError(##class(%ZPM.PackageManager.Client.Settings).SetAnalyticsTrackingId(pAnalyticsTrackingID))
    $$$QuitOnError(##class(%ZPM.PackageManager.Client.Settings).SetValue("ColorScheme",""))
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="ZPMLoad">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDirectoryName</FormalSpec>
<Implementation><![CDATA[  Quit ##class(%ZPM.PackageManager).Shell("load -dev "_pDirectoryName)
]]></Implementation>
</Method>

<Method name="ZPMCompile">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[  Quit ##class(%ZPM.PackageManager).Shell("ZPM compile")
]]></Implementation>
</Method>

<Method name="CreateProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #; Behave as simple installer
  If (..#FILESCOUNT'>0)||(..#VERSION="") QUIT $$$OK

  #; This flag used in development
  if $DATA(^%ZPM("skipinstall")) QUIT $$$OK
  
  #; Installed version newer
  if '..NeedInstall() QUIT $$$OK

  Write !,"Extract package"
  $$$QuitOnError(..ExtractPackage(.tModDir))
  
  Write !,"Install ZPM"

  set ts = $ZHOROLOG
  set logFile=##class(%File).TempFilename()
  JOB ..AsyncSetup(tModDir, 3):(:::logFile):0
  if '$test {
    quit $$$ERROR($$$GeneralError, "Job did not start")
  }

  #; Wait setup
  set child=$zchild
  Set tSC = $$$OK
  do { 
    hang 1
    Set $Listbuild(res, tSC) = $System.Event.WaitMsg("", 10)
    Quit:res=1
  } while $data(^$JOB(child))

  set fs=##class(%Stream.FileCharacter).%New()
  set fs.Filename=logFile
  while 'fs.AtEnd {
    write !,fs.ReadLine()
  }
  if ##class(%File).Delete(logFile)

  Write !,"Time spent ",$ZHOROLOG - ts

  QUIT tSC
]]></Implementation>
</Method>

<Method name="NeedInstall">
<Description>
Check currently installed version, if any</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*version:%String</FormalSpec>
<Implementation><![CDATA[
  try {
    set module = ##class(%ZPM.PackageManager.Developer.Module).NameOpen("zpm")
    if '$ISOBJECT(module) {
      RETURN 1
    }

    set version = ##class(%ZPM.PackageManager.Core.SemanticVersion).FromString(..#VERSION)
    if $isobject(version) {
      RETURN version.Follows(module.Version)
    }

  } CATCH ex {
    
  }
  QUIT 1
]]></Implementation>
</Method>

<Method name="Make">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pPackage:%Stream.Object,&pStream:%Stream.TmpCharacter]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#define FileTempDir ##class(%SYS.System).TempDirectory()_"/"_##class(%PopulateUtils).StringMin(8,8)

  Set tSC = $$$OK
  try {
    Set tModule = ##class(%ZPM.PackageManager.Developer.Module).NameOpen("zpm")

    Set tmpDir = ##class(%File).NormalizeDirectory($$$FileTempDir)
    $$$ThrowOnError(##class(%ZPM.PackageManager.Developer.Archive).Extract(pPackage, tmpDir))

    Do ..CollectPackage(tmpDir, .tList, tmpDir)

    Do ..CompactPackage(.tList)

    Set param = ##class(%Dictionary.ParameterDefinition).%OpenId($CLASSNAME()_"||VERSION")
    Set param.Default = tModule.VersionString
    Do param.%Save()

    Set param = ##class(%Dictionary.ParameterDefinition).%OpenId($CLASSNAME()_"||FILESCOUNT")
    Set param.Default = $Get(tList)
    Do param.%Save()

    Set tSC = $SYSTEM.OBJ.ExportToStream($CLASSNAME()_".CLS", .pStream, "/diffexport/exportversion=2017.1")
    #; Set tSC = $SYSTEM.OBJ.ExportToStream($CLASSNAME()_".CLS", , "/diffexport/exportversion=2017.1")
  } Catch e {
    Set tSC = e.AsStatus()
  }
  QUIT tSC
]]></Implementation>
</Method>

<Method name="CollectPackage">
<ClassMethod>1</ClassMethod>
<FormalSpec>pPath:%String,*pList,pRoot:%String</FormalSpec>
<Implementation><![CDATA[
  set rs = ##class(%File).FileSetFunc(pPath)
  WHILE rs.%Next() {
    If rs.Type="D" {
      do ..CollectPackage(rs.Name, .pList, pRoot)
    } ELSE {
      #; Set $LISTBUILD(url) = $SYSTEM.CSP.FilenameToUrls(rs.Name) 
      Set pList($INCREMENT(pList)) = $LISTBUILD(rs.Name, $EXTRACT(rs.Name, $LENGTH(pRoot) + 1, *))
    }
  }
]]></Implementation>
</Method>

<Method name="CompactPackage">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pList]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set file = ""
  for i=1:1:$Get(pList) {
    Set $LISTBUILD(file, name) = pList(i)
    
    set tmpFile = ##class(%File).TempFilename("gz")

    set stream = ##class(%Stream.FileBinary).%New()
    set stream.Filename = file

    Set gzip = ##class(%Stream.FileBinaryGzip).%New()
    Set gzip.Filename = tmpFile
    do gzip.CopyFromAndSave(stream)
    
    Set gzip = ##class(%Stream.FileBinary).%New()
    Set gzip.Filename = tmpFile

    Set xdata = ##class(%Dictionary.XDataDefinition).%New()
    Set xdata.Name = "Data"_i
    Set xdata.Description = name
    Do xdata.parentSetObjectId($CLASSNAME())
    set chunkSize = 22800
    while 'gzip.AtEnd {
      set data = gzip.Read(chunkSize)
      set base64 = $SYSTEM.Encryption.Base64Encode(data)
      do xdata.Data.WriteLine(base64)
      set data1 = $SYSTEM.Encryption.Base64Decode(base64)
    }
    do xdata.%Save()
    set hash = $SYSTEM.Encryption.SHA1HashStream(gzip)
  
    do ##class(%File).Delete(tmpFile)
  }
  QUIT $$$OK
  
  
  Quit $$$OK
]]></Implementation>
</Method>

<Method name="ExtractPackage">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pFolder:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
#define FileTempDir ##class(%SYS.System).TempDirectory()_"/"_##class(%PopulateUtils).StringMin(8,8)

  Set pFolder = ##class(%File).NormalizeDirectory($$$FileTempDir)

  For i=1:1:..#FILESCOUNT {
    Set xdata = ##class(%Dictionary.XDataDefinition).%OpenId($CLASSNAME()_"||Data"_i)
    Set name = xdata.Description
    Set fileName = pFolder_name

    Set tParentFolder = ##class(%File).ParentDirectoryName(fileName)    
    if '##class(%File).DirectoryExists(tParentFolder) {
      Do ##class(%File).CreateDirectoryChain(tParentFolder)
    }

    set tmpFile = ##class(%File).TempFilename("gz")

    set stream = ##class(%Stream.FileBinary).%New()
    set stream.Filename = tmpFile
    set prev = ""
    set chunkSize = 30400
    do {
      set data = prev
      if 'xdata.Data.AtEnd {
        set data = data _ xdata.Data.Read()
      }
      set data = $ZSTRIP(data, "*C")
      set prev = $EXTRACT(data, chunkSize + 1, *)
      set data = $EXTRACT(data, 1, chunkSize)
      set chunk = $SYSTEM.Encryption.Base64Decode(data)
      do stream.Write(chunk)
    } while (prev'="")||('xdata.Data.AtEnd)
    do stream.%Save()

    set gzip = ##class(%Stream.FileBinaryGzip).%New()
    set gzip.Filename = tmpFile

    set fs = ##class(%Stream.FileCharacter).%New()
    set fs.Filename = fileName
    do fs.CopyFromAndSave(gzip)

    do ##class(%File).Delete(tmpFile)
  }
  Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.JSON.Adaptor">
<Super>%ZPM.cache.Adaptor</Super>
<System>3</System>
<TimeCreated>65797,80090.849908</TimeCreated>

<Method name="%JSONGenerate">
<Description><![CDATA[
%JSONGenerate is an internal method that controls the generation of the other methods in %ZPM.cache.Adaptor.
If %JSONGenerate is overridden, then JSON meta data and the other generator methods
of %ZPM.cache.Adaptor will not be created.<p>]]></Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<GenerateAfter>%JSONX</GenerateAfter>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[  Quit ##class(Generator).%JSONGenerate(.%mode,.%class,.%property,.%method,.%parameter,.%codemode,.%code,.%classmodify,.%context)
]]></Implementation>
</Method>

<Method name="%JSONImportInternal">
<Description>
%JSONImportInternal is internal method used by %JSONImport</Description>
<Internal>1</Internal>
<CodeMode>generator</CodeMode>
<GenerateAfter>%JSONGenerate</GenerateAfter>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[  Quit ##class(Generator).JSONImportInternal(.%mode,.%class,.%property,.%method,.%parameter,.%codemode,.%code,.%classmodify,.%context)
]]></Implementation>
</Method>

<Method name="%JSONExportInternal">
<Description>
%JSONExportInternal is internal method used by %JSONExport</Description>
<Internal>1</Internal>
<CodeMode>generator</CodeMode>
<GenerateAfter>%JSONGenerate</GenerateAfter>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[  Quit ##class(Generator).JSONExportInternal(.%mode,.%class,.%property,.%method,.%parameter,.%codemode,.%code,.%classmodify,.%context)
]]></Implementation>
</Method>

<Method name="%JSONExportToStringInternal">
<Description>
%JSONExportToStringInternal is internal method used by %JSONExport</Description>
<Internal>1</Internal>
<CodeMode>generator</CodeMode>
<GenerateAfter>%JSONGenerate</GenerateAfter>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[  Quit ##class(Generator).JSONExportToStringInternal(.%mode,.%class,.%property,.%method,.%parameter,.%codemode,.%code,.%classmodify,.%context)
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.JSON.Generator">
<Super>%ZPM.cache.Generator</Super>
<System>2</System>
<TimeCreated>65797,80090.934118</TimeCreated>

<Method name="GenImportBinaryStream">
<Description>
Generate code for getting the field value from a binary stream and storing in variable named data.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
  Set property=$$$jsonproperty(propertyMap)
  
  // If present, then must be the expected JSON type
  $$$GENERATE(indent_"  If jsontype'=""string"" Goto %JSONImportError")
  // Get the field value
  // Code to use property stream
  $$$GENERATE(indent_"  Set stream=.."_$$$jsonpropertyQN(propertyMap)_" Do stream.Rewind()")
  $$$GENERATE(indent_"  Set tBase64=%JSONObject."_$$$QN($$$jsonfieldname(propertyMap)))
  $$$GENERATE(indent_"  Set tBase64=$Translate(tBase64, ""=""_$Char(10,13))")
  $$$GENERATE(indent_"  Set tLen=$Length(tBase64)")
  $$$GENERATE(indent_"  For i=1:1:tLen\30020+1 {")
  $$$GENERATE(indent_"    Set sc=stream.Write($system.Encryption.Base64Decode($Extract(tBase64, i-1*30020+1, i*30020))) If $$$ISERR(sc) Goto %JSONImportExit")
  $$$GENERATE(indent_"  }")
]]></Implementation>
</Method>

<Method name="GenExportBinaryStream">
<Description>
Generate code for exporting a binary stream as JSON.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,fieldName:%String,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
  Do ..GenWriteField(fieldName,indent,"")
  $$$GENERATE(indent_"  "_%outputCode_"""""""""")
  $$$GENERATE(indent_" Do value.Rewind()")
  $$$GENERATE(indent_" If value.Size>0 { While 'value.AtEnd {")
  $$$GENERATE(indent_" "_%outputCode_"$system.Encryption.Base64Encode(value.Read(22515,.sc),1)")
  $$$GENERATE(indent_" If $$$ISERR(sc) Goto "_%exitCode_" }} "_%outputCode_"""""""""")
]]></Implementation>
</Method>
</Class>




<Class name="%ZPM.PackageManager.Client.Filesystem.Cache">
<Super>%Persistent,%ZPM.PackageManager.Core.ModuleInfo</Super>
<TimeCreated>65797,80971.5512</TimeCreated>

<Index name="CacheItemIndex">
<Data>LastModified</Data>
<Properties>Root,SubDirectory</Properties>
<Unique>1</Unique>
</Index>

<Property name="Root">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="260"/>
</Property>

<ForeignKey name="RootFK">
<OnDelete>cascade</OnDelete>
<Properties>Root</Properties>
<ReferencedClass>%ZPM.PackageManager.Client.FilesystemServerDefinition</ReferencedClass>
<ReferencedKey>RootIndex</ReferencedKey>
</ForeignKey>

<Property name="SubDirectory">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="260"/>
</Property>

<Property name="LastModified">
<Type>%TimeStamp</Type>
<Required>1</Required>
</Property>

<Property name="Manifest">
<Description>
Full module manifest</Description>
<Type>%Stream.GlobalCharacter</Type>
</Property>

<Index name="SemVer">
<Properties>Name,Version</Properties>
<TypeClass>%ZPM.PackageManager.Server.SemVerIndex</TypeClass>
</Index>

<Property name="SemVer">
<Description>
Property associated with the index to allow quick $Query'ing over SemVer order based on ID</Description>
<Type>%String</Type>
<SqlComputeCode>set {*} = ##class(%ZPM.PackageManager.Client.Filesystem.Cache).SemVerNode({Name},{Version})</SqlComputeCode>
<SqlComputed>1</SqlComputed>
<SqlComputeOnChange>%%INSERT,%%UPDATE</SqlComputeOnChange>
<Parameter name="MAXLEN" value="512"/>
</Property>

<Index name="RootNameVersion">
<Properties>Root,Name,VersionString</Properties>
<Unique>1</Unique>
</Index>

<Method name="%OnBeforeBuildIndices">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&indexlist:%String(MAXLEN="")=""]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If (indexlist [ "SemVer") || (indexlist = "") {
		// Force recomputation of SemVer property if index needs to be rebuilt (i.e., because structure has changed)
		Set tRes = ##class(%SQL.Statement).%ExecDirect(,"update %ZPM_PackageManager_Client_Filesystem.Cache set SemVer = ''")
		If tRes.%SQLCODE < 0 {
			Quit $$$ERROR($$$SQLCode,tRes.%SQLCODE,tRes.%Message)
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="OrderedMatches">
<Type>%Query</Type>
<FormalSpec>pRoot:%String="",pName:%String="",pVersionExpression:%String="*",pParameters:%String=""</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Name:%String,VersionString:%String"/>
</Query>

<Method name="OrderedMatchesExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,pRoot:%String="",pName:%String="",pVersionExpression:%String="*",pParameters:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ##class(%ZPM.PackageManager.Server.SemVerFind).MatchesExecute(.qHandle,$classname(),"SemVer",..SemVerIndexLocation(),pName,pVersionExpression,pParameters)
	Set qHandle("root") = pRoot
	Quit tSC
]]></Implementation>
</Method>

<Method name="OrderedMatchesClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>OrderedMatchesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ##class(%ZPM.PackageManager.Server.SemVerFind).MatchesClose(.qHandle)
]]></Implementation>
</Method>

<Method name="OrderedMatchesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>OrderedMatchesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	For {
		Set tSC = ##class(%ZPM.PackageManager.Server.SemVerFind).MatchesFetch(.qHandle,.tRow,.AtEnd)
		If AtEnd {
			Quit
		}
		Set tRoot = ..RootGetStored($ListGet(tRow))
		If (tRoot = qHandle("root")) {
			Set Row = $ListBuild(..NameGetStored($ListGet(tRow)),..VersionStringGetStored($ListGet(tRow)))
			Quit
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^ZPM.Client.FSCacheD</DataLocation>
<DefaultData>CacheDefaultData</DefaultData>
<IdLocation>^ZPM.Client.FSCacheD</IdLocation>
<IndexLocation>^ZPM.Client.FSCacheI</IndexLocation>
<StreamLocation>^ZPM.Client.FSCacheS</StreamLocation>
<Data name="CacheDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Root</Value>
</Value>
<Value name="3">
<Value>SubDirectory</Value>
</Value>
<Value name="4">
<Value>Name</Value>
</Value>
<Value name="5">
<Value>Version</Value>
</Value>
<Value name="6">
<Value>VersionString</Value>
</Value>
<Value name="7">
<Value>LastModified</Value>
</Value>
<Value name="8">
<Value>Manifest</Value>
</Value>
<Value name="9">
<Value>SemVer</Value>
</Value>
<Value name="10">
<Value>Description</Value>
</Value>
<Value name="11">
<Value>Repo</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Client.Filesystem.PackageService">
<Super>%RegisteredObject,%ZPM.PackageManager.Core.IPackageService,%ZPM.PackageManager.Core.ModuleInfo.QueryUtils</Super>
<TimeCreated>65797,80971.512832</TimeCreated>

<Property name="Root">
<Type>%String</Type>
<Private>1</Private>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="%OnNew">
<FormalSpec>pRoot:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set i%Root = pRoot
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ListModules">
<FormalSpec>pSearchCriteria:%ZPM.PackageManager.Core.SearchCriteria</FormalSpec>
<ReturnType>%ListOfObjects</ReturnType>
<ReturnTypeParams>ELEMENTTYPE="%ZPM.PackageManager.Core.ResolvedModuleReference"</ReturnTypeParams>
<Implementation><![CDATA[
	Set tList = ##class(%Library.ListOfObjects).%New()
	Set tQuery = "select Name,VersionString from %ZPM_PackageManager_Client_Filesystem.Cache_OrderedMatches(?,?,?,?) m"
	Set tArgs($i(tArgs)) = ..Root
	Quit ..moduleSqlToList(tQuery,.pSearchCriteria,.tArgs)
]]></Implementation>
</Method>

<Method name="HasModule">
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit ##class(%ZPM.PackageManager.Client.Filesystem.Cache).RootNameVersionExists(..Root,pModuleReference.Name,pModuleReference.VersionString)
]]></Implementation>
</Method>

<Method name="GetModuleManifest">
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
	Set tModule = ##class(%ZPM.PackageManager.Client.Filesystem.Cache).RootNameVersionOpen(..Root,pModuleReference.Name,pModuleReference.VersionString,,.tStatus)
	$$$ThrowOnError(tStatus)
	Quit tModule.Manifest
]]></Implementation>
</Method>

<Method name="GetModule">
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
	// ... and tgz it!
	Set tTempFileName = ##class(%File).TempFilename("tgz")
	Set tSrcPath = ..GetModuleDirectory(pModuleReference)
	$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.Archive).Create(tSrcPath,tTempFileName))
	
	Set tFileBinStream = ##class(%Stream.FileBinary).%New()
	$$$ThrowOnError(tFileBinStream.LinkToFile(tTempFileName))
	
	Quit tFileBinStream
]]></Implementation>
</Method>

<Method name="GetModuleDirectory">
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// Get the module ...
	Set tModule = ##class(%ZPM.PackageManager.Client.Filesystem.Cache).RootNameVersionOpen(..Root,pModuleReference.Name,pModuleReference.VersionString,,.tStatus)
	$$$ThrowOnError(tStatus)
	
	Quit ##class(%File).NormalizeDirectory(tModule.Root_tModule.SubDirectory)
]]></Implementation>
</Method>

<Method name="GetApplication">
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[	Quit $$$NULLOREF
]]></Implementation>
</Method>

<Method name="GetApplicationManifest">
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[	Quit $$$NULLOREF
]]></Implementation>
</Method>

<Method name="HasApplication">
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit 0
]]></Implementation>
</Method>

<Method name="ListApplications">
<FormalSpec>pSearchCriteria:%ZPM.PackageManager.Core.SearchCriteria</FormalSpec>
<ReturnType>%ListOfObjects</ReturnType>
<ReturnTypeParams>ELEMENTTYPE="%ZPM.PackageManager.Core.ResolvedModuleReference"</ReturnTypeParams>
<Implementation><![CDATA[	Quit ##class(%Library.ListOfObjects).%New()
]]></Implementation>
</Method>

<Method name="Supports">
<Description>
Returns 1 if the service supports a particular method.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMethod:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Filesystem package service only supports module packaging for now.
	Quit '(pMethod [ "Application")
]]></Implementation>
</Method>

<Method name="IsAvailable">
<Description>
For run-time checks to ensure the service is available before attempting to invoke it.</Description>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit ##class(%File).DirectoryExists(..Root)
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Client.FilesystemServerDefinition">
<Super>%ZPM.PackageManager.Client.ServerDefinition</Super>
<TimeCreated>65797,80971.424732</TimeCreated>

<Parameter name="DISPLAYNAME">
<Type>STRING</Type>
<Default>Filesystem</Default>
</Parameter>

<Parameter name="MONIKER">
<Type>STRING</Type>
<Default>file</Default>
</Parameter>

<Index name="RootIndex">
<Properties>Root</Properties>
<Unique>1</Unique>
</Index>

<Property name="Details">
<Type>%String</Type>
<SqlComputeCode>Set {*} = {Root}_$Case({Depth},0:"*",:$Replace($Justify(" ",{Depth}*2),"  ",$Select($$$isWINDOWS:"*\",1:"*/"))_"module.xml")</SqlComputeCode>
<SqlComputed>1</SqlComputed>
<SqlComputeOnChange>%%INSERT,%%UPDATE</SqlComputeOnChange>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Root">
<Description>
Root folder on the server filesystem</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="260"/>
</Property>

<Property name="Depth">
<Description>
How many levels of depth to search for module.xml files; 0 indicates unlimited.</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Parameter name="RootPromptString">
<Description>
Prompt to use for Root in interactive configuration of this repository type</Description>
<Expression>$$$Text("Root File Path:","ZPM")</Expression>
</Parameter>

<Method name="RootSet">
<FormalSpec>%val</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If (%val '= "") {
		Set %val = ##class(%File).NormalizeDirectory(%val)
	}
	Set i%Root = %val
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetPackageService">
<Description>
Returns a client to interact with this server.</Description>
<ReturnType>%ZPM.PackageManager.Core.IPackageService</ReturnType>
<Implementation><![CDATA[
	Set tService = ##class(%ZPM.PackageManager.Client.Filesystem.PackageService).%New(..Root)
	If tService.IsAvailable() {
		$$$ThrowOnError(..BuildCache(1))
	}
	Quit tService
]]></Implementation>
</Method>

<Method name="OnConfigure">
<Description>
Handles modifiers/data attributes provided from the package manager shell.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pInstance:%ZPM.PackageManager.Client.ServerDefinition,pInteractive:%Boolean=1,&pModifiers,&pData]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tPath = $Get(pModifiers("path"),pInstance.Root)
		If (pInteractive && (tPath = "")) {
			Set tPrompt = ..#RootPromptString
			Set tResponse = ##class(%Library.Prompt).GetString(tPrompt,.tPath)
			If (tResponse '= $$$SuccessResponse) {
				$$$ThrowStatus($$$ERROR($$$GeneralError,"Operation cancelled."))
			}
			
			If ##class(%ZPM.PackageManager.Client.FilesystemServerDefinition).RootIndexExists(tPath) {
				$$$ThrowStatus($$$ERROR($$$GeneralError,$$$FormatText("Root '%1' is already configured for another repository."),tPath))
			}
		}
		Set pInstance.Root = tPath
		
		If $Data(pModifiers("depth"),tDepth) {
			Set pInstance.Depth = tDepth
		}
		
		// This also saves it.
		$$$ThrowOnError(pInstance.BuildCache(1,1,1))
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetPublishService">
<Description>
Returns a client to publish modules/applications to this server.</Description>
<ReturnType>%ZPM.PackageManager.Core.IPublishService</ReturnType>
<Implementation><![CDATA[
	// TODO: Implement? (Does it make sense to allow publishing to the local filesystem? What does that even mean?)
	Quit $$$NULLOREF
]]></Implementation>
</Method>

<Method name="GetSortOrder">
<Private>1</Private>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	Quit 2
]]></Implementation>
</Method>

<Trigger name="RootChanged">
<Description>
Clears the cache if the root is changed.</Description>
<Code><![CDATA[	New tOldRoot
	If ({Root*C}) {
		Set tOldRoot = {Root*O}
		&sql(delete from %ZPM_PackageManager_Client_Filesystem.Cache where Root = :tOldRoot)
		If (SQLCODE < 0) {
			Set %ok = 0
		}
	}]]></Code>
<Event>UPDATE</Event>
<Foreach>row/object</Foreach>
</Trigger>

<Method name="BuildCache">
<FormalSpec>pPurge:%Boolean=1,pVerbose:%Integer=0,pAutoDetectDepth:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tInitTLevel = $TLevel
	Try {
		TSTART
		If (pPurge) {
			#dim tResult As %SQL.StatementResult
			Set tResult = ##class(%SQL.Statement).%ExecDirect(,"delete from %ZPM_PackageManager_Client_Filesystem.Cache where Root = ?",..Root)
			If (tResult.%SQLCODE < 0) {
				Set tSC = $$$ERROR($$$SQLCode,tResult.%SQLCODE,tResult.%Message)
				Quit
			}
		}
		
		// Force save so that root foreign key for items will exist.
		Set tSC = ..%Save()
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Scan root directory recursively, up to ..Depth levels down, for module.xml files.
		Set tSC = ..ScanDirectory(..Root,.tFilenameList,,..Depth,$Select(pVerbose>1:1,1:0),.tMaxDepth)
		If $$$ISERR(tSC) {
			Quit
		}
		
		If (pAutoDetectDepth) && (tMaxDepth > 0) {
			Set ..Depth = tMaxDepth
			Set tSC = ..%Save()
			If $$$ISERR(tSC) {
				Quit
			}
		}
		
		// Ensure that we're looking at valid MODULE documents (as opposed to classes named Module, which the package manager has!)
		Set tKey = ""
		For {
			Set tKey = $Order(tFilenameList(tKey),1,tFile)
			Quit:(tKey="")
			
			// Get list of what's in module.xml
			Set tSC = $System.OBJ.Load(tFile,"-d",,.tLoadedList,1)
			If $$$ISERR(tSC) {
				// Wasn't a valid file. We'll just continue.
				Set tSC = $$$OK
				Continue
			}
			
			If ($Length(tLoadedList,",") > 1) {
				// Contained multiple documents - tricky! We'll just continue.
				Continue
			}
			
			Set tExt = $ZConvert($Piece($Get(tLoadedList),".",*),"U")
			If (tExt '= "ZPM") {
				Continue
			}
			
			Kill tStream,tName,tVersionString
			Set tSC = ..GetModuleStreamFromFile(tFile,.tStream,.tName,.tVersionString)
			If $$$ISERR(tSC) {
				Quit
			}
		
			// Create cache item.
			Set tSubDirectory = tFilenameList(tKey,"sub")
			If ##class(%ZPM.PackageManager.Client.Filesystem.Cache).CacheItemIndexExists(..Root,tSubDirectory) {
				Set tCacheItem = ##class(%ZPM.PackageManager.Client.Filesystem.Cache).CacheItemIndexOpen(..Root,tSubDirectory)
			} Else {
				Set tCacheItem = ##class(%ZPM.PackageManager.Client.Filesystem.Cache).%New()
				Set tCacheItem.Root = ..Root
				Set tCacheItem.SubDirectory = tSubDirectory
			}
			Set tCacheItem.Name = tName
			Set tCacheItem.VersionString = tVersionString
			Do tCacheItem.Manifest.CopyFrom(tStream)
			Set tCacheItem.LastModified = $zdt($zts,3)
			Set tSC = tCacheItem.%Save()
			If $$$ISERR(tSC) {
				Quit
			}
			
			Write:pVerbose !,tName," ",tVersionString," @ ",##class(%File).NormalizeDirectory(..Root_tSubDirectory)
		}
		TCOMMIT
	} Catch e {
		Set tSC = e.AsStatus()
	}
	While ($TLevel > tInitTLevel) { TROLLBACK 1 }
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetModuleStreamFromFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFilename:%String,*pStream:%Stream.GlobalCharacter,*pName:%String,*pVersion:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pName = ""
	Set pVersion = ""
	Try {
		// These documents will always look like:
		/*
			<?xml version="1.0" encoding="UTF-8"?>
			<Export generator="Cache" version="25">
			<Document name="%ZPM.ZPM"><Module>
			...
			</Module>
			</Document></Export>
		*/
		// We want the first line, and everything from <Module> to </Module>.
		// Rather than doing full XML parsing, it's fastest to just selectively copy lines from the file to the target stream.
		// Some information is also extracted from the XML using $Piece.
		
		Set tSourceStream = ##class(%Stream.FileCharacter).%New()
		Set tSC = tSourceStream.LinkToFile(pFilename)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set pStream = ##class(%Stream.GlobalCharacter).%New()
		Do pStream.WriteLine(tSourceStream.ReadLine($$$MaxStringLength)) //<?xml version="1.0" encoding="UTF-8"?>
		Do tSourceStream.ReadLine($$$MaxStringLength) //<Export generator="Cache" version="25">
		Set tFirstLine = tSourceStream.ReadLine($$$MaxStringLength) //<Document name="%ZPM.ZPM"><Module>
		Do pStream.WriteLine("<Module>")
		While 'tSourceStream.AtEnd {
			Set tLine = tSourceStream.ReadLine($$$MaxStringLength)
			If tLine = "</Document></Export>" {
				Quit
			}
			
			// This depends on the Name and Version tags coming early in the export. Our format enforces this.
			If (tLine [ "<Version>") && (pVersion = "") {
				Set pVersion = $Piece($Piece(tLine,"<Version>",2),"</Version>")
			}
			If (tLine [ "<Name>") && (pName = "") {
				Set pName = $Piece($Piece(tLine,"<Name>",2),"</Name>")
			}
			Do pStream.WriteLine(tLine)
		}
		
		Do pStream.Rewind()
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ScanDirectory">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pRoot:%String,&pFilenameList,pSub:%String="",pDepth:%Integer="",pVerbose:%Boolean=0,*pMaxDepth:%Integer=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pRoot = ##class(%File).NormalizeDirectory(pRoot)
		Set tDirArray($i(tDirArray)) = ""
		
		Set i = 0
		Do {
			Set i = i + 1
			If (pDepth > 0) && ($Length(tDirArray(i),"/") > pDepth) {
				Continue
			}
			
			Set tStmt = ##class(%SQL.Statement).%New()
			Set tSC = tStmt.%PrepareClassQuery("%Library.File","FileSet")
			If $$$ISERR(tSC) {
				Quit
			}
			
			Set tFullDir = ##class(%File).NormalizeDirectory(pRoot_tDirArray(i))
			Set tRes = tStmt.%Execute(tFullDir,"module.xml",,1)
			While tRes.%Next() {
				If (tRes.%Get("Type") = "D") {
					Write:pVerbose !,"Scanning directory: ",tRes.%Get("ItemName")
					Set tDirArray($i(tDirArray)) = tDirArray(i)_$Case(tDirArray(i),"":"",:"/")_tRes.%Get("ItemName")
				} Else {
					Write:pVerbose !,"Found file: ",tRes.%Get("Name")
					Set pFilenameList($i(pFilenameList)) = tRes.%Get("Name")
					Set pFilenameList(pFilenameList,"sub") = tDirArray(i)
					If (pDepth > pMaxDepth) {
						Set pMaxDepth = $Length(tDirArray(i),"/")
					}
				}
			}
		} While (i < tDirArray)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>FilesystemServerDefinitionDefaultData</DefaultData>
<Data name="FilesystemServerDefinitionDefaultData">
<Subscript>"FilesystemServerDefinition"</Subscript>
<Value name="1">
<Value>Root</Value>
</Value>
<Value name="2">
<Value>Depth</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Client.LocalServerDefinition">
<Super>%ZPM.PackageManager.Client.ServerDefinition</Super>
<TimeCreated>65797,80971.459704</TimeCreated>

<Parameter name="DISPLAYNAME">
<Type>STRING</Type>
<Default>Local Cache</Default>
</Parameter>

<Parameter name="MONIKER">
<Type>STRING</Type>
<Default>local</Default>
</Parameter>

<Property name="Details">
<Type>%String</Type>
<SqlComputeCode>Set {*} = "Namespace-local module registry."</SqlComputeCode>
<SqlComputed>1</SqlComputed>
<SqlComputeOnChange>%%INSERT,%%UPDATE</SqlComputeOnChange>
<Parameter name="MAXLEN"/>
</Property>

<Index name="Singleton">
<Properties>IsLocalCache</Properties>
<Unique>1</Unique>
</Index>

<Property name="IsLocalCache">
<Type>%Integer</Type>
<InitialExpression>1</InitialExpression>
<ReadOnly>1</ReadOnly>
</Property>

<Method name="GetPackageService">
<Description>
Returns a client to interact with this server.</Description>
<ReturnType>%ZPM.PackageManager.Core.IPackageService</ReturnType>
<Implementation><![CDATA[	Quit ##class(%ZPM.PackageManager.Server.PackageService).%New()
]]></Implementation>
</Method>

<Method name="GetPublishService">
<Description>
Returns a client to publish modules/applications to this server.</Description>
<ReturnType>%ZPM.PackageManager.Core.IPublishService</ReturnType>
<Implementation><![CDATA[	Quit ##class(%ZPM.PackageManager.Server.PublishService).%New()
]]></Implementation>
</Method>

<Method name="OnConfigure">
<Description>
Handles modifiers/data attributes provided from the package manager shell.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pInstance:%ZPM.PackageManager.Client.ServerDefinition,pInteractive:%Boolean=1,&pModifiers,&pData]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Intentional no-op.
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetSortOrder">
<Private>1</Private>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	Quit 1
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Client.REST.PackageManagerClient">
<Super>%RegisteredObject,%ZPM.PackageManager.Core.IPackageService</Super>
<TimeCreated>65797,80971.561565</TimeCreated>

<Property name="Location">
<Type>%String</Type>
</Property>

<Property name="Username">
<Type>%String</Type>
</Property>

<Property name="Password">
<Type>%String</Type>
</Property>

<Method name="GetInfo">
<FormalSpec>url:%String</FormalSpec>
<ReturnType>%DynamicObject</ReturnType>
<Implementation><![CDATA[
 	Set tRequest = ..GetHttpRequest()
 	Set tSC = tRequest.Get()

  If $$$ISOK(tSC), tRequest.HttpResponse.StatusCode=200 {
    Set tRes = {}.%FromJSON(tRequest.HttpResponse.Data)
    Return tRes
  }

	$$$ThrowStatus($$$ERROR($$$GeneralError,"Registry server not available."))
]]></Implementation>
</Method>

<Method name="ListModules">
<FormalSpec>pSearchCriteria:%ZPM.PackageManager.Core.SearchCriteria</FormalSpec>
<ReturnType>%ListOfObjects</ReturnType>
<ReturnTypeParams>ELEMENTTYPE="%ZPM.PackageManager.Core.ResolvedModuleReference"</ReturnTypeParams>
<Implementation><![CDATA[
  Set tList = ##class(%Library.ListOfObjects).%New()
  Set tRequest = ..GetHttpRequest()

  Set name = $$$lcase(pSearchCriteria.Name)
  Set tVersionExpression = pSearchCriteria.VersionExpression
  Set tSC = ##class(%ZPM.PackageManager.Core.SemanticVersionExpression).FromString(pSearchCriteria.VersionExpression, .tVersionExpression)
  $$$ThrowOnError(tSC)

  If name = "" {
    Set tSC = tRequest.Get($$$URLENCODE(tRequest.Location_"packages/-/all"))
  }
  Else {
    Set tSC = tRequest.Get($$$URLENCODE(tRequest.Location_"packages/" _ name))
  }
  If $$$ISOK(tSC), tRequest.HttpResponse.StatusCode=200 {
    Set tRes = {}.%FromJSON(tRequest.HttpResponse.Data)
    If ('tRes.%IsA("%Library.DynamicArray")) {
      Set tRes = [].%Push(tRes)
    }
    
    Set tIter = tRes.%GetIterator()

    While tIter.%GetNext(.key, .item) {
      Set tIterVer = item.versions.%GetIterator()
      WHILE tIterVer.%GetNext(.verkey, .version) {
        Set tVersion = ##class(%ZPM.PackageManager.Core.SemanticVersion).FromString(version)
        CONTINUE:'tVersion.Satisfies(tVersionExpression)
        Set tModRef = ##class(%ZPM.PackageManager.Core.ResolvedModuleReference).%New()
        Set tModRef.Name = item.name
        Set tModRef.Repo = item.repository
        Set tModRef.VersionString = version
        Set tModRef.Description = item.description
        Do tList.Insert(tModRef)
      }      
    }
  }
  
  Return tList
]]></Implementation>
</Method>

<Method name="GetModule">
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference,*AsArchive:%Boolean=1</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
  Set tRequest = ..GetHttpRequest()
  Set tFileBinStream = ""
  Set AsArchive = 1

  Set name = pModuleReference.Name
  Set version = pModuleReference.VersionString

  Set tSC = tRequest.Get($$$URLENCODE(tRequest.Location_"packages/" _ name _ "/" _ version))
  Set tPackageUrl = ""
  If $$$ISOK(tSC), tRequest.HttpResponse.StatusCode=200 {
    Set tRes = {}.%FromJSON(tRequest.HttpResponse.Data)
    
    Set tPackageUrl = tRes.url
    Set tHash = tRes.hash

    Do ##class(%Net.URLParser).Parse(tPackageUrl,.tComponents)
    If ($Data(tComponents("path"))#2) {
      If ($Extract(tComponents("path"),1,1)="/") {
          Set path = $Extract(tComponents("path"),2,*)	
      }
    }
    Set tRequest = ..GetHttpRequest()
    Set tRequest.Timeout = 300
    Set tSC = tRequest.Get(tRequest.Location_path)
    If $$$ISOK(tSC), tRequest.HttpResponse.StatusCode=200 {
      Set tFileBinStream = ##class(%Stream.FileBinary).%New()
      Set tFileBinStream.Filename = ##class(%File).TempFilename("tgz")
      do tFileBinStream.CopyFromAndSave(tRequest.HttpResponse.Data)      
      If (tHash'="") {
        set tTestHash = $$$lcase(##class(%File).SHA1Hash(tFileBinStream.Filename, 1)) 
        if tTestHash'=tHash {
          $$$ThrowStatus($$$ERROR($$$GeneralError, "Download module, hash mismatch."))
        }
      }
      Set token = tRequest.HttpResponse.GetHeader("INSTALLTOKEN")
      If (token'="") {
        Set ^IRIS.TempZPMRInst(name,version) = token
      }
    }
  }
  If tFileBinStream="" {
    $$$ThrowStatus($$$ERROR($$$GeneralError,"Download module, something went wrong."))
  }
  Quit tFileBinStream
]]></Implementation>
</Method>

<Method name="GetModuleManifest">
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
<Implementation><![CDATA[
  Set tRequest = ..GetHttpRequest()
  Set tFileBinStream = ""

  Set name = pModuleReference.Name
  Set version = pModuleReference.VersionString

  Set tSC = tRequest.Get($$$URLENCODE(tRequest.Location_"packages/" _ name _ "/"_version_"/manifest"))
  If $$$ISOK(tSC), tRequest.HttpResponse.StatusCode=200 {
    Return tRequest.HttpResponse.Data
  }

  $$$ThrowStatus($$$ERROR($$$GeneralError,"Download package manifest, something went wrong."))
]]></Implementation>
</Method>

<Method name="SendAnalyticsToRegistry">
<FormalSpec>action:%String,data:%DynamicObject</FormalSpec>
<Implementation><![CDATA[
    Set tRequest = ..GetHttpRequest()
    Set tRequest.ContentType = "application/json"
    Do tRequest.SetHeader("INSTALLTOKEN", $Get(^IRIS.TempZPMRInst(data.name,data.version))) 
    Kill ^IRIS.TempZPMRInst(data.name,data.version)
    Do data.%ToJSON(tRequest.EntityBody) 
    Set tSC = tRequest.Post($$$URLENCODE(tRequest.Location_"collect/" _ action))
    If ($$$ISERR(tSC) || (tRequest.HttpResponse.StatusCode'=200)) {
        $$$ThrowStatus($$$ERROR($$$GeneralError,"Error Sending Analytics Data"))
    }
]]></Implementation>
</Method>

<Method name="SendAnalyticsToGoogle">
<FormalSpec>action:%String,data:%DynamicObject</FormalSpec>
<Implementation><![CDATA[
    Set TrackingID = ##class(%ZPM.PackageManager.Client.Settings).GetAnalyticsTrackingId()
    Quit:(TrackingID = "") 0
    Set tRequest = ##class(%Net.HttpRequest).%New()
    Set tRequest.FollowRedirect = 1
    Set tRequest.Server = "www.google-analytics.com"
    Set tRequest.SSLConfiguration = ..GetSSLConfiguration(tRequest.Server)

    Set status = $case($$$ISOK(data.success), 1: "Success", : "Failure")
    Set version = data.version
    Set irisPlatform = $system.Version.GetPlatform()
    Set irisVersion = $system.Version.GetNumber()
    Set irisProduct = $system.Version.GetProduct()

    Do tRequest.SetParam("v","1")
    Do tRequest.SetParam("tid",TrackingID)
    Do tRequest.SetParam("cid",##class(%SYS.System).InstanceGUID())
    Do tRequest.SetParam("ds","web")
    Do tRequest.SetParam("t","event")
    Do tRequest.SetParam("ec",data.name)
    Do tRequest.SetParam("ea",status)
    Do tRequest.SetParam("el",version_", "_irisProduct_", "_irisPlatform_", "_irisVersion)
    Return tRequest.Post("/collect")
]]></Implementation>
</Method>

<Method name="CollectAnalytics">
<FormalSpec>action:%String,name:%String,version:%String,success:%Boolean=1,msg:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    If ('##class(%ZPM.PackageManager.Client.Settings).GetAnalyticsAvailable()) {
        Return $$$OK
    }
    Set jo = {}
    Set jo.name = name
    Set jo.version = version
    Set jo.guid = ##class(%SYS.System).InstanceGUID()
    Set jo."system_version" = $ZVersion
    Set zpmVersion = ##class(%ZPM.PackageManager.Client.Utils).GetZPMVersion()
    If (zpmVersion'="") {
        Set jo."zpmclient_version" = zpmVersion
    } 
    Do jo.%Set("success",success,"boolean")
    Set jo."error_msg" = msg
    Try {
        Do ..SendAnalyticsToRegistry(action, jo)
        Do ..SendAnalyticsToGoogle(action, jo)
    } Catch ex {
        Return ex.AsStatus()
    }
    Return $$$OK
]]></Implementation>
</Method>

<Method name="IsAvailable">
<Description>
For run-time checks to ensure the service is available before attempting to invoke it.</Description>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  Set tAvailable = 0
  Set tRequest = ..GetHttpRequest()
  
  Set tRequest.Timeout = 30
  Set tSC = tRequest.Get($$$URLENCODE(tRequest.Location_"_ping"))
  set status =tRequest.HttpResponse.StatusCode
  If $$$ISOK(tSC) && (tRequest.HttpResponse.StatusCode = 200) {
    Set tAvailable = 1
  }
  Return tAvailable
]]></Implementation>
</Method>

<Method name="GetHttpRequest">
<FormalSpec>tLocation=..Location</FormalSpec>
<ReturnType>%Net.HttpRequest</ReturnType>
<Implementation><![CDATA[
  Set tRequest = ##class(%Net.HttpRequest).%New()

  Set tRequest.FollowRedirect = 1

  Set tLocation = $$$URLDECODE(tLocation)
  If ($piece(tLocation, "://")'["http") {
    Set tLocation = "http://" _ tLocation
  }
  
  Do ##class(%Net.URLParser).Parse(tLocation,.tComponents)
  
	If ($$$lcase(tComponents("scheme")) [ "http") {
		If ($Data(tComponents("host"))#2) {
			Set tRequest.Server = tComponents("host")
		}
		If ($Data(tComponents("port"))#2) {
			Set tRequest.Port = tComponents("port")
		}
		If ($$$lcase(tComponents("scheme")) = "https") {
			Set tRequest.Https = 1
    }
    If ($Get(tComponents("path"))'="") {
			Set path = tComponents("path")
			If ($Extract(path,1,1)="/") {
				Set path = $Extract(path,2,*)	
			}
			Set tRequest.Location = path
		}
    #; in case of redirection
    Set tRequest.SSLConfiguration = ..GetSSLConfiguration(tRequest.Server)
    
		If (..Username '= "") && (..Password '= "") {
      Set tRequest.Username = ..Username
      Set tRequest.Password = ..Password
		}
  }
  Return tRequest
]]></Implementation>
</Method>

<Method name="GetSSLConfiguration">
<ClassMethod>1</ClassMethod>
<FormalSpec>host</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  NEW $NAMESPACE
  SET $NAMESPACE = "%SYS"
  
  IF '##class(Security.SSLConfigs).Exists(host) {
    DO ##class(Security.SSLConfigs).Create(host)
  }
  QUIT host
]]></Implementation>
</Method>

<Method name="ResetRegistry">
<Description>
Used for unittests, reset's external temporary registry from any packages.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  Set debugKey = $system.Util.GetEnviron("TEST_REGISTRY_DEBUG")
  if (debugKey="") {
    Quit $$$OK
  }

  Set tRequest = ..GetHttpRequest()
  Do tRequest.SetHeader("REGISTRY_DEBUG", debugKey)
  
  Quit tRequest.Get(tRequest.Location_"_reset")
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Client.REST.PublishClient">
<Super>%ZPM.PackageManager.Client.REST.PackageManagerClient,%ZPM.PackageManager.Core.IPublishService</Super>
<TimeCreated>65797,80971.528647</TimeCreated>

<Method name="PublishModule">
<FormalSpec>pModule:%ZPM.PackageManager.Core.Module</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  Quit ..Publish(pModule)
]]></Implementation>
</Method>

<Method name="PublishApplication">
<FormalSpec>pApplication:%ZPM.PackageManager.Core.Application</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  Quit ..Publish(pApplication)
]]></Implementation>
</Method>

<Method name="Publish">
<FormalSpec>pModule:%ZPM.PackageManager.Core.VersionedBase</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  if (..Username="") || (..Password="") {
    $$$ThrowStatus($$$ERROR($$$GeneralError, "Publishing module, authorization required."))
  }
  
  Set tRequest = ..GetHttpRequest()
  Set tRequest.ContentType = "application/json"

  $$$ThrowOnError(pModule.%JSONExportToStream(tRequest.EntityBody))
  $$$ThrowOnError(tRequest.Post(tRequest.Location_"packages"))
  
  If (tRequest.HttpResponse.StatusCode '= 200) {
    If tRequest.HttpResponse.StatusCode = 401 {
      $$$ThrowStatus($$$ERROR($$$GeneralError, "Publishing module, authorization required."))
    } Else {
      $$$ThrowStatus($$$ERROR($$$GeneralError, "Publishing module, something went wrong."))
    }
  }
  Quit 1
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Client.RemoteServerDefinition">
<Super>%ZPM.PackageManager.Client.ServerDefinition</Super>
<TimeCreated>65797,80971.490091</TimeCreated>

<Parameter name="DISPLAYNAME">
<Type>STRING</Type>
<Default>Remote Repository</Default>
</Parameter>

<Parameter name="MONIKER">
<Type>STRING</Type>
<Default>registry</Default>
</Parameter>

<Property name="Details">
<Type>%String</Type>
<SqlComputeCode>Set {*} = {URL}</SqlComputeCode>
<SqlComputed>1</SqlComputed>
<SqlComputeOnChange>%%INSERT,%%UPDATE</SqlComputeOnChange>
<Parameter name="MAXLEN"/>
</Property>

<Index name="URL">
<Properties>URL</Properties>
<Unique>1</Unique>
</Index>

<Property name="URL">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="2048"/>
</Property>

<Parameter name="URLPromptString">
<Expression>$$$Text("Registry URL:","ZPM")</Expression>
</Parameter>

<Property name="Username">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Password">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="DeploymentEnabled">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Index name="DeploymentServer">
<Properties>DeploymentEnabled</Properties>
<Unique>1</Unique>
</Index>

<Method name="%OnBeforeSave">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%Save</METHOD> method to 
provide notification that the object is being saved. It is called before 
any data is written to disk.

<P><VAR>insert</VAR> will be set to 1 if this object is being saved for the first time.

<P>If this method returns an error then the call to <METHOD>%Save</METHOD> will fail.]]></Description>
<FormalSpec>insert:%Boolean</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	// Leave DeploymentEnabled null to make unique index work right
	// (i.e., deployment can only be enabled for one remote server.)
	Set:..DeploymentEnabled=0 ..DeploymentEnabled=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%ValidateObject</METHOD> method to 
provide notification that the current object is being validated.

<P>If this method returns an error then <METHOD>%ValidateObject</METHOD> will fail.]]></Description>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetPackageService">
<Description>
Returns a REST client to interact with this server.</Description>
<ReturnType>%ZPM.PackageManager.Core.IPackageService</ReturnType>
<Implementation><![CDATA[
	Set tClient = ##class(%ZPM.PackageManager.Client.REST.PackageManagerClient).%New()
	Set tClient.Location = ..URL
	Set tClient.Username = ..Username
	Set tClient.Password = ..Password
	Quit tClient
]]></Implementation>
</Method>

<Method name="GetPublishService">
<Description>
Returns a REST client to publish modules/applications to this server.</Description>
<ReturnType>%ZPM.PackageManager.Core.IPublishService</ReturnType>
<Implementation><![CDATA[
	Set tClient = ##class(%ZPM.PackageManager.Client.REST.PublishClient).%New()
	Set tClient.Location = ..URL
	Set tClient.Username = ..Username
	Set tClient.Password = ..Password
	Quit tClient
]]></Implementation>
</Method>

<Method name="Display">
<Description>
Outputs information about this server to the current device.
Subclasses may override to show additional information.</Description>
<Implementation><![CDATA[
	Do ##super()
	If (..Username '= "") {
		Write !,$c(9),"Username: ",$c(9),..Username
	}
	If (..Password '= "") {
		Write !,$c(9),"Password: ",$c(9),$Case(..Password,"":"<unset>",:"<set>")
	}
]]></Implementation>
</Method>

<Method name="OnConfigure">
<Description>
Handles modifiers/data attributes provided from the package manager shell.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pInstance:%ZPM.PackageManager.Client.ServerDefinition,pInteractive:%Boolean=1,&pModifiers,&pData]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tUrl = $Get(pModifiers("url"), pInstance.URL)
		If (pInteractive && (tUrl = "")) {
			Set tPrompt = ..#URLPromptString
			Set tResponse = ##class(%Library.Prompt).GetString(tPrompt, .tUrl)
			If (tResponse '= $$$SuccessResponse) {
				$$$ThrowStatus($$$ERROR($$$GeneralError, "Operation cancelled."))
			}
		}
		
		Set pInstance.Username = $Get(pModifiers("username"),"")
		Set pInstance.Password = $Get(pModifiers("password"),"")	
	
		If $Data(pModifiers("url"),tURL) {
			Set pInstance.URL = tURL
		}
		If ((pInstance.%Id()="")&&..DeploymentServerExists(1)) {
			$$$ThrowStatus($$$ERROR($$$GeneralError, "Unable to add new remote server."_$$$NL_" Use ""repo -r -n registry -url <new url>"" to switch to another server"_$$$NL))
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetSortOrder">
<Private>1</Private>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	// TODO: Allow this to be changed dynamically.
	Quit 2 + $Case(..%Id(),"":1,:..%Id())
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>RemoteServerDefinitionDefaultData</DefaultData>
<Data name="RemoteServerDefinitionDefaultData">
<Subscript>"RemoteServerDefinition"</Subscript>
<Value name="2">
<Value>Username</Value>
</Value>
<Value name="3">
<Value>Password</Value>
</Value>
<Value name="4">
<Value>URL</Value>
</Value>
<Value name="5">
<Value>DeploymentEnabled</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Client.ServerDefinition">
<Abstract>1</Abstract>
<IncludeCode>%syPrompt,%ZPM.PackageManager.Common</IncludeCode>
<Super>%Persistent,%ZEN.DataModel.Adaptor</Super>
<TimeCreated>65797,80971.547979</TimeCreated>

<Parameter name="DOMAIN">
<Default>ZPM</Default>
</Parameter>

<Parameter name="DISPLAYNAME">
<Description>
Display name for this type of repository, shown in the UI and package manager shell.</Description>
<Type>STRING</Type>
<Abstract>1</Abstract>
</Parameter>

<Parameter name="MONIKER">
<Description>
Short/logical name for this type of repository, used in the package manager shell as an alternative to the full class name.</Description>
<Type>STRING</Type>
<Abstract>1</Abstract>
</Parameter>

<Index name="ServerDefinitionKey">
<Properties>Name</Properties>
<Unique>1</Unique>
</Index>

<Property name="Name">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="100"/>
</Property>

<Property name="Enabled">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="Details">
<Type>%String</Type>
<SqlComputeCode>Set {*} = ""</SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Snapshots">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Prereleases">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="GetPackageService">
<Description>
Returns a client to interact with this server.</Description>
<Abstract>1</Abstract>
<ReturnType>%ZPM.PackageManager.Core.IPackageService</ReturnType>
</Method>

<Method name="GetPublishService">
<Description>
Returns a client to publish modules/applications to this server.</Description>
<Abstract>1</Abstract>
<ReturnType>%ZPM.PackageManager.Core.IPublishService</ReturnType>
</Method>

<Method name="SortOrder">
<ClassMethod>1</ClassMethod>
<FormalSpec>pID:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	Set tServer = ..%OpenId(pID)
	Quit tServer.GetSortOrder()
]]></Implementation>
</Method>

<Method name="Display">
<Description>
Outputs information about this server to the current device.
Subclasses may override to show additional information, but should typically call ##super() at the beginning.</Description>
<Implementation><![CDATA[
	Write !,..Name
	Write !,$c(9),"Source: ",$c(9),..Details
	Write !,$c(9),"Enabled?",$c(9),$$$YesNo(..Enabled)
	Write !,$c(9),"Available?",$c(9),$$$YesNo(..GetPackageService().IsAvailable())
	Write !,$c(9),"Use for Snapshots?",$c(9),$$$YesNo(..Snapshots)
	Write !,$c(9),"Use for Prereleases?",$c(9),$$$YesNo(..Prereleases)
]]></Implementation>
</Method>

<Method name="Configure">
<Description><![CDATA[
Called from package manager shell to create or update an instance of this class.
Acceptable values in <var>pModifiers</var> and <var>pData</var> may vary between classes, but
some (such as "name", "enabled", "snapshots", and "prereleases") are common to all.
For a full list of modifiers, see the Commands XDATA block in <class>%ZPM.PackageManager</class>.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pInteractive:%Boolean=1,&pModifiers,&pData]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tName = $Get(pModifiers("name"))
		
		If (pInteractive && (tName = "")) {
			Set tResponse = ##class(%Library.Prompt).GetString("Name: ",.tName)
			If (tResponse '= $$$SuccessResponse) {
				$$$ThrowStatus($$$ERROR($$$GeneralError,"Operation cancelled."))
			}
		}
		
		Set tIsNew = 0
		Set tInstance = $$$NULLOREF
		If ..ServerDefinitionKeyExists(tName) {
			Set tInstance = ..ServerDefinitionKeyOpen(tName,,.tSC)
			$$$ThrowOnError(tSC)
		}
		
		If '$IsObject(tInstance) {
			Set tInstance = ..%New()
			Set tIsNew = 1
			Set tInstance.Name = tName
		}
		
		If $Data(pModifiers("disable")) {
			Set tInstance.Enabled = 0
		} ElseIf (tIsNew || $Data(pModifiers("enable"))) {
			Set tInstance.Enabled = 1
		}
		
		If $Data(pModifiers("snapshots"),tSnapshots) {
			Set tInstance.Snapshots = tSnapshots
		} ElseIf (tIsNew) {
			Set tInstance.Snapshots = 1
		}
		If $Data(pModifiers("prereleases"),tPrereleases) {
			Set tInstance.Prereleases = tPrereleases
		} ElseIf (tIsNew) {
			Set tInstance.Prereleases = 1
		}
		
		$$$ThrowOnError(..OnConfigure(tInstance,pInteractive,.pModifiers,.pData))
		
		$$$ThrowOnError(tInstance.%Save())
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnConfigure">
<Description>
Subclasses must override. Allows handling of any custom modifiers/data attributes provided from the package manager shell.</Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pInstance:%ZPM.PackageManager.Client.ServerDefinition,pInteractive:%Boolean=1,&pModifiers,&pData]]></FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="GetSortOrder">
<Description>
Subclasses must override. Orders repositories by type and possibly other factors.</Description>
<Abstract>1</Abstract>
<Private>1</Private>
<ReturnType>%Integer</ReturnType>
</Method>

<Query name="Catalog">
<Type>%Query</Type>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Classname:%String,Moniker:%String,Description:%String"/>
</Query>

<Method name="CatalogExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tRes = ##class(%SQL.Statement).%New()
		Set tSC = tRes.%PrepareClassQuery("%Dictionary.ClassDefinition","SubclassOf")
		$$$ThrowOnError(tSC)
		Set qHandle = tRes.%Execute($classname())
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="CatalogFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>CatalogExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set AtEnd = 'qHandle.%Next(.tSC)
	If 'AtEnd {
		Set tClass = qHandle.%Get("Name")
		Set Row = $ListBuild(tClass,$parameter(tClass,"MONIKER"),$parameter(tClass,"DISPLAYNAME"))
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="CatalogClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>CatalogExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^%ZPM.Client.ServerDefD</DataLocation>
<DefaultData>ServerDefinitionDefaultData</DefaultData>
<IdLocation>^%ZPM.Client.ServerDefD</IdLocation>
<IndexLocation>^%ZPM.Client.ServerDefI</IndexLocation>
<StreamLocation>^%ZPM.Client.ServerDefS</StreamLocation>
<Data name="ServerDefinitionDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="5">
<Value>Credentials</Value>
</Value>
<Value name="7">
<Value>Enabled</Value>
</Value>
<Value name="8">
<Value>IsLocalCache</Value>
</Value>
<Value name="9">
<Value>Details</Value>
</Value>
<Value name="10">
<Value>Snapshots</Value>
</Value>
<Value name="11">
<Value>Prereleases</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Client.Settings">
<Description>
ZPM settings are placed in ^zpm.settings global in %SYS namespace
Use this class to set or get settings

Available settings
default_registry (string) - default registry url 
analytics_tracking_id
analytics_available (boolean) - if 1 - send usage statistics</Description>
<Super>%RegisteredObject</Super>
<TimeCreated>65797,80971.475126</TimeCreated>

<Parameter name="registry">
<Default>default_registry</Default>
</Parameter>

<Parameter name="trackingId">
<Default>analytics_tracking_id</Default>
</Parameter>

<Parameter name="analytics">
<Default>analytics_available</Default>
</Parameter>

<Parameter name="ColorScheme">
<Default>ColorScheme</Default>
</Parameter>

<Parameter name="CONFIGURABLE">
<Default>trackingId,analytics,ColorScheme</Default>
</Parameter>

<Method name="GetAll">
<Description>
Returns configArray, that includes all configurable settings</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*configArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set configArray = ""
    For i=1:1:$Length(..#CONFIGURABLE, ",") {
        Set configArray($Piece(..#CONFIGURABLE, ",",i)) = ..GetValue($Parameter(..%ClassName(1),$Piece(..#CONFIGURABLE, ",",i)))
    }
    Return $$$OK
]]></Implementation>
</Method>

<Method name="PrintList">
<Description>
Writes in terminal key : value pairs for all configurable settings</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    Do ..GetAll(.confArr)
    Set k = ""
    For {
        Set k = $Order(confArr(k))
        Quit:(k="")
        Write k_": "_confArr(k),! 
    }
]]></Implementation>
</Method>

<Method name="PrintOne">
<ClassMethod>1</ClassMethod>
<FormalSpec>key:%String</FormalSpec>
<Implementation><![CDATA[
    Set SettingsList = $Listfromstring(..#CONFIGURABLE)
    If ('$Listfind(SettingsList,key)) {
        Write "Config key = """_key_""" not found",!
        Quit
    }
    Write key_":"_..GetValue($Parameter(..%ClassName(1),key)),!
]]></Implementation>
</Method>

<Method name="ResetToDefault">
<ClassMethod>1</ClassMethod>
<FormalSpec>key:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set SettingsList = $Listfromstring(..#CONFIGURABLE)
    If ('$Listfind(SettingsList,key)) {
        Write "Config key = """_key_""" not found",!
        Quit
    }
    Set sc = ..SetValue($Parameter(..%ClassName(1),key), ..GetDefaultValue($Parameter(..%ClassName(1),key)))
    If $$$ISOK(sc) {
        Write "Value for """_key_""" succesfully reset to default",!
    } Else {
        Write "Error reseting value for """_key_"""",!
    }
    Return sc
]]></Implementation>
</Method>

<Method name="UpdateOne">
<ClassMethod>1</ClassMethod>
<FormalSpec>key:%String,value:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set SettingsList = $Listfromstring(..#CONFIGURABLE)
    If ('$Listfind(SettingsList,key)) {
        Write "Config key = """_key_""" not found",!
        Quit
    }
    Set sc = ..SetValue($Parameter(..%ClassName(1),key), value)
    If $$$ISOK(sc) {
        Write "Key """_key_""" succesfully updated",!
    } Else {
        Write "Error updating """_key_"""",!
    }
    Return sc
]]></Implementation>
</Method>

<Method name="GetValue">
<Description>
Gets value from global array
indx - global subscript</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>indx:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    New $Namespace
    Return:(indx="") ""
    Set $Namespace = "%SYS"
    Return $Get(^zpm.settings(indx))
]]></Implementation>
</Method>

<Method name="GetDefaultValue">
<ClassMethod>1</ClassMethod>
<FormalSpec>indx:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    New $Namespace
    Return:(indx="") ""
    Set $Namespace = "%SYS"
    Return $Get(^zpm.settings(indx,"default"))
]]></Implementation>
</Method>

<Method name="SetValue">
<ClassMethod>1</ClassMethod>
<FormalSpec>indx:%String="",val:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Return:(indx="") ""
    New $Namespace   
    Set $Namespace = "%SYS"
    Set ^zpm.settings(indx) = val
    If ($Data(^zpm.settings(indx,"default"))=0) {
        Set ^zpm.settings(indx,"default") = val
    }
    Return $$$OK
]]></Implementation>
</Method>

<Method name="GetDefaultRegistry">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    Return ..GetValue(..#registry)
]]></Implementation>
</Method>

<Method name="SetDefaultRegistry">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    Return ..SetValue(..#registry, val)
]]></Implementation>
</Method>

<Method name="GetAnalyticsTrackingId">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    Return ..GetValue(..#trackingId)
]]></Implementation>
</Method>

<Method name="SetAnalyticsTrackingId">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[    Return ..SetValue(..#trackingId, val)
]]></Implementation>
</Method>

<Method name="GetAnalyticsAvailable">
<ClassMethod>1</ClassMethod>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[    Return ..GetValue(..#analytics)
]]></Implementation>
</Method>

<Method name="SetAnalyticsAvailable">
<ClassMethod>1</ClassMethod>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[    Return ..SetValue(..#analytics, +val)
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Client.Utils">
<IncludeCode>%occErrors</IncludeCode>
<TimeCreated>65797,80971.482885</TimeCreated>

<Method name="SearchRepositoriesForModule">
<Description>
Returns a list of all resolved module references matching the search criteria from configured repositories.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSearchCriteria:%ZPM.PackageManager.Core.SearchCriteria,*pResults:%Library.ListOfObjects(ELEMENTTYPE="%ZPM.PackageManager.Core.QualifiedModuleReference"),pForceRemoteRepo:%Boolean=0</FormalSpec>
<PublicList>registry</PublicList>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pResults = ##class(%Library.ListOfObjects).%New()
	Try {
		set registry = pSearchCriteria.Registry
		Set tRes = ##class(%SQL.Statement).%ExecDirect(,"select ID from %ZPM_PackageManager_Client.ServerDefinition where Enabled = 1 and (:registry is null or Name = :registry) order by %ZPM_PackageManager_Client.ServerDefinition_SortOrder(ID)")
		If (tRes.%SQLCODE < 0) {
			Set tSC = $$$ERROR($$$SQLCode,tRes.%SQLCODE,tRes.%Message)
			Quit
		}
		While (tRes.%Next(.tSC)) {
			If $$$ISERR(tSC) {
				Quit
			}
			
			Set tServer = ##class(%ZPM.PackageManager.Client.ServerDefinition).%OpenId(tRes.%Get("ID"),,.tSC)
			If $$$ISERR(tSC) {
				Quit
			}
			
			If pForceRemoteRepo && tServer.%IsA("%ZPM.PackageManager.Client.LocalServerDefinition") {
				Continue
			}
			
			// Only remote repositories support keywords, for now.
			If (pSearchCriteria.Keywords.Count() > 0) && tServer.%IsA("%ZPM.PackageManager.Client.FilesystemServerDefinition") {
				Continue
			}
			
			Set tClient = tServer.GetPackageService()
			If 'tClient.IsAvailable() {
				Continue
			}
			
			#dim tClientCriteria as %ZPM.PackageManager.Core.SearchCriteria
			Set tClientCriteria = pSearchCriteria.%ConstructClone(1)
			Set tClientCriteria.IncludePrerelease = tServer.Prereleases
			Set tClientCriteria.IncludeSnapshots = tServer.Snapshots
			Set tServerResults = tClient.ListModules(tClientCriteria)
			For i=1:1:tServerResults.Count() {
				Set item = tServerResults.GetAt(i)
        		#; Sorting versions
        		Set versions(tServer.Name, +item.Version.Major, +item.Version.Minor, +item.Version.Patch, " "_item.Version.Patch_"_"_item.Version.Prerelease) = item
			}
		}
    Set name = ""
    For {
      Set name = $Order(versions(name))
      Quit:name=""
      Set major = ""
      For {
        Set major = $Order(versions(name, major), -1)
        Quit:major=""
        Set minor = ""
        For  {
          Set minor = $Order(versions(name, major, minor), -1)
          Quit:minor=""
          Set patch = ""
          For  {
            Set patch = $Order(versions(name, major, minor, patch), -1)
            Quit:patch=""
            Set sub = ""
            For  {
              Set sub = $Order(versions(name, major, minor, patch, sub), 1, item)
              Quit:sub=""
              Do pResults.Insert(##class(%ZPM.PackageManager.Core.QualifiedModuleReference).%New(name, item))
            }
          }
        }
      }
    }
    
		If $$$ISERR(tSC) {
			Quit
		}
	} Catch e {
		If (e.Name["ZSOAP") && $Data(%objlasterror) {
			Set tSC = %objlasterror
		} Else {
			Set tSC = e.AsStatus()
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="RetrieveModuleManifest">
<Description>
Loads the module reference </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pQualifiedReference:%ZPM.PackageManager.Core.QualifiedModuleReference,*pManifestStream:%Stream.Object</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pManifestStream = $$$NULLOREF
	Try {
		Set tServer = ##class(%ZPM.PackageManager.Client.ServerDefinition).ServerDefinitionKeyOpen(pQualifiedReference.ServerName,,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tClient = tServer.GetPackageService()

		Set pManifestStream = tClient.GetModuleManifest(pQualifiedReference)
	} Catch e {
		If (e.Name["ZSOAP") && $Data(%objlasterror) {
			Set tSC = %objlasterror
		} Else {
			Set tSC = e.AsStatus()
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="RetrieveModulePackage">
<Description>
Loads the module reference </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pQualifiedReference:%ZPM.PackageManager.Core.QualifiedModuleReference,*pPackageStream:%Stream.Object</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pPackageStream = $$$NULLOREF
	Try {
		Set tServer = ##class(%ZPM.PackageManager.Client.ServerDefinition).ServerDefinitionKeyOpen(pQualifiedReference.ServerName,,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tClient = tServer.GetPackageService()
		
		Set pPackageStream = tClient.GetModule(pQualifiedReference)
	} Catch e {
		If (e.Name["ZSOAP") && $Data(%objlasterror) {
			Set tSC = %objlasterror
		} Else {
			Set tSC = e.AsStatus()
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="SearchRepositoriesForApplication">
<Description>
Returns a list of all resolved module references matching the search criteria from configured repositories.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSearchCriteria:%ZPM.PackageManager.Core.SearchCriteria,*pResults:%Library.ListOfObjects(ELEMENTTYPE="%ZPM.PackageManager.Core.QualifiedModuleReference"),pForceRemoteRepo:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pResults = ##class(%Library.ListOfObjects).%New()
	Try {
		Set tRes = ##class(%SQL.Statement).%ExecDirect(,"select ID from %ZPM_PackageManager_Client.ServerDefinition where Enabled = 1 order by %ZPM_PackageManager_Client.ServerDefinition_SortOrder(ID)")
		If (tRes.%SQLCODE < 0) {
			Set tSC = $$$ERROR($$$SQLCode,tRes.%SQLCODE,tRes.%Message)
			Quit
		}
		While (tRes.%Next(.tSC)) {
			If $$$ISERR(tSC) {
				Quit
			}
			
			Set tServer = ##class(%ZPM.PackageManager.Client.ServerDefinition).%OpenId(tRes.%Get("ID"),,.tSC)
			If $$$ISERR(tSC) {
				Quit
			}
			
			If pForceRemoteRepo && tServer.%IsA("%ZPM.PackageManager.Client.LocalServerDefinition") {
				Continue
			}
			
			Set tClient = tServer.GetPackageService()
			If 'tClient.Supports("ListApplications") {
				Continue
			}
			If 'tClient.IsAvailable() {
				Continue
			}
			
			#dim tClientCriteria as %ZPM.PackageManager.Core.SearchCriteria
			Set tClientCriteria = pSearchCriteria.%ConstructClone()
			Set tClientCriteria.IncludePrerelease = tServer.Prereleases
			Set tClientCriteria.IncludeSnapshots = tServer.Snapshots
			Set tServerResults = tClient.ListApplications(tClientCriteria)
			For i=1:1:tServerResults.Count() {
				Do pResults.Insert(##class(%ZPM.PackageManager.Core.QualifiedModuleReference).%New(tServer.Name,tServerResults.GetAt(i)))
			}
		}
		If $$$ISERR(tSC) {
			Quit
		}
	} Catch e {
		If (e.Name["ZSOAP") && $Data(%objlasterror) {
			Set tSC = %objlasterror
		} Else {
			Set tSC = e.AsStatus()
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="RetrieveApplicationManifest">
<Description>
Loads the module reference </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pQualifiedReference:%ZPM.PackageManager.Core.QualifiedModuleReference,*pManifestStream:%Stream.Object</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pManifestStream = $$$NULLOREF
	Try {
		Set tServer = ##class(%ZPM.PackageManager.Client.ServerDefinition).ServerDefinitionKeyOpen(pQualifiedReference.ServerName,,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tClient = tServer.GetPackageService()
		
		Set pManifestStream = tClient.GetApplicationManifest(pQualifiedReference)
	} Catch e {
		If (e.Name["ZSOAP") && $Data(%objlasterror) {
			Set tSC = %objlasterror
		} Else {
			Set tSC = e.AsStatus()
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="RetrieveApplicationPackage">
<Description>
Loads the application package </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pQualifiedReference:%ZPM.PackageManager.Core.QualifiedModuleReference,*pPackageStream:%Stream.Object</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pPackageStream = $$$NULLOREF
	Try {
		Set tServer = ##class(%ZPM.PackageManager.Client.ServerDefinition).ServerDefinitionKeyOpen(pQualifiedReference.ServerName,,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tClient = tServer.GetPackageService()
		
		Set pPackageStream = tClient.GetApplication(pQualifiedReference)
	} Catch e {
		If (e.Name["ZSOAP") && $Data(%objlasterror) {
			Set tSC = %objlasterror
		} Else {
			Set tSC = e.AsStatus()
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="InitializeLocalCache">
<Description>
Creates a local cache entry in the ServerDefinition table if none exists</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pCreated:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tLocalCache = ##class(%ZPM.PackageManager.Client.LocalServerDefinition).SingletonOpen(1,,.tSC)
		If $$$ISERR(tSC) && ($System.Status.GetErrorCodes(tSC) '= $$$KeyValueNotFoundOpen) {
			Quit
		}
		If $IsObject(tLocalCache) {
			Set pCreated = 1
			Quit
		}
		Set tLocalCache = ##class(%ZPM.PackageManager.Client.LocalServerDefinition).%New()
		Set tLocalCache.Name = "(Local Cache)"
		Set tLocalCache.Prereleases = 1
		Set tLocalCache.Snapshots = 1
		Set tSC = tLocalCache.%Save()
		If $$$ISERR(tSC) {
			Quit
		}
		Set pCreated = 1
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="InstallApplication">
<Description>
Does a fresh or upgrade installation</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pInstallInfo:%ZPM.PackageManager.Core.InstallationInfo</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set tSC = $$$OK
	Try {
		// TODO: Verbose/silent flags?
		// TODO: Logging to a file?
		
		// Get module manifest.
		Set tSC = ..RetrieveApplicationManifest(pInstallInfo.ModuleReference,.tManifestStream)
		If $$$ISERR(tSC) {
			Quit
		}
		
		// TODO: Validate module manifest?
		
		// Download application package.
		Set tSC = ..RetrieveApplicationPackage(pInstallInfo.ModuleReference,.tPackageStream)
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Extract application package.
		Set tTmpFileName = ##class(%File).TempFilename(".tgz")
		Set tFile = ##class(%Stream.FileBinary).%New()
		Set tSC = tFile.LinkToFile(tTmpFileName)
		If $$$ISERR(tSC) {
			Quit
		}
		Set tSC = tFile.CopyFromAndSave(tPackageStream)
		If $$$ISERR(tSC) {
			Quit
		}
		Set tExtractDir = ##class(%File).NormalizeDirectory($Piece(tTmpFileName,".tgz"))
		Set tSC = ##class(%ZPM.PackageManager.Developer.Archive).Extract(tTmpFileName,tExtractDir,.tOutput)
		For i=1:1:$Get(tOutput) {
			Write !,tOutput(i)
		}
		If $$$ISERR(tSC) {
			Quit
		}
		
		// TODO: Validate extracted package?
		
		// Configure databases - for now, just CODE and LOCAL may be configured.
		// CODE is always overridden. LOCAL and DATA may be copied if present, or otherwise will be
		// created blank.
		Set tDBDir = ##class(%File).NormalizeDirectory(tExtractDir_"db")
		For tDBName = "CODE","DATA","LOCAL" {
			Set tSourceFile = ""
			If ##class(%File).Exists(tDBDir_tDBName_".DAT") {
				Set tSourceFile = tDBDir_tDBName_".DAT"
			}
			Set tOverwrite = (tDBName="CODE")
			Set tName = pInstallInfo.Namespace_"-"_tDBName
			Set tSC = ##class(%ZPM.PackageManager.Developer.Build).CreateDatabase(tName,tSourceFile,tOverwrite,.tCreated)
			If $$$ISERR(tSC) {
				Quit
			}
			If (tCreated) {
				Write !,"Database ",tName," created."
			} ElseIf (tOverwrite) {
				Write !,"Database ",tName," overwritten."
			}
		}
		
		// Create new namespace.
		// TODO: Mappings for LOCAL database?
		Set tSC = ##class(%ZPM.PackageManager.Developer.Build).CreateNamespace(pInstallInfo.Namespace,pInstallInfo.Namespace_"-CODE",pInstallInfo.Namespace_"-DATA")
		If $$$ISERR(tSC) {
			Quit
		}
		Set $Namespace = pInstallInfo.Namespace
		
		// Import module.xml in that namespace without running "Compile"
		Set tSC = $System.OBJ.Load(tExtractDir_"module.xml","k",,.tLoaded)
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Run application "Configure" phase (should not compile/activate, or need to compile).
		Set tModName = $Piece(tLoaded,".ZPM")
		Set tModule = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(tModName,,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Configure module
		Kill tParams
		Set tParams("RootDirectory") = tExtractDir
		Set tParams("Configure","DatabaseName") = pInstallInfo.Namespace_"-CODE"
		// TODO: Populate tParams("Configure","Parameters") as module expects.
		Set tSC = tModule.Lifecycle.Configure(.tParams)
		If $$$ISERR(tSC) {
			Quit
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	
	// TODO: if tSC is an error, do any necessary cleanup depending on where failure occurred.
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="UninstallApplication">
<ClassMethod>1</ClassMethod>
<FormalSpec>pInstallInfo:%ZPM.PackageManager.Core.InstallationInfo</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// $Namespace intentionally not New'd
	Set tInitNS = $Namespace
	Set tSC = $$$OK
	Try {
		// Unconfigure application
		Set tModule = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(pInstallInfo.ModuleReference.Name,,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Kill tParams
		Set tParams("Configure","DatabaseName") = pInstallInfo.Namespace_"-CODE"
		Set tSC = tModule.Lifecycle.Unconfigure(.tParams)
		
		// Clean up at the Cach/Ensemble level.
		Set $Namespace = "%SYS" //Protection from <NAMESPACE>/etc.
		
		// TODO: Make the following steps optional? (Particularly, the deletion of user data / local code?)
		Set tCodeDBName = pInstallInfo.Namespace_"-CODE"
		Set tDataDBName = pInstallInfo.Namespace_"-DATA"
		Set tLocalDBName = pInstallInfo.Namespace_"-LOCAL"
		
		// These can fail safely.
		Do ##class(%Library.EnsembleMgr).DisableNamespace(pInstallInfo.Namespace)
		Do ##class(%ZPM.PackageManager.Developer.Build).DeleteNamespace(pInstallInfo.Namespace)
		Do ##class(%ZPM.PackageManager.Developer.Build).DeleteDatabase(tCodeDBName)
		Do ##class(%ZPM.PackageManager.Developer.Build).DeleteDatabase(tDataDBName)
		Do ##class(%ZPM.PackageManager.Developer.Build).DeleteDatabase(tLocalDBName)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	If ##class(%SYS.Namespace).Exists(tInitNS) {
		Set $Namespace = tInitNS
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetZPMVersion">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    New $Namespace
    Set $Namespace = "%SYS"
    Set module = ##class(%ZPM.PackageManager.Developer.Module).NameOpen("zpm")
    If ($IsObject(module)) {
        Return module.VersionString
    }
    Return ""
]]></Implementation>
</Method>
</Class>


<Routine name="%ZPM.PackageManager.Common" type="INC"><![CDATA[
#; Helper for XML import of documents
#define ZPMStudioDocumentModule %ZPMStudioDocumentModule

#; Local % Variable to track modules already handled for a given end goal
#define ZPMHandledModules %ZZPMHandledModules

#; Default packages for module lifecycle classes and 
#define DefaultLifecyclePackage "%ZPM.PackageManager.Developer.Lifecycle"
#define DefaultLifecyclePackageDot $$$DefaultLifecyclePackage_"."
#define DefaultProcessorPackage "%ZPM.PackageManager.Developer.Processor"
#define DefaultProcessorPackageDot $$$DefaultProcessorPackage_"."

#; Various globals
#define ZPMConfig ^ZPM.Config

#; CLI tools
#define HasModifier(%array,%x) ''$Data(%array("modifiers",%x))
#define GetModifier(%array,%x) $Get(%array("modifiers",%x))
#define GetModifierDef(%array,%x,%y) $Get(%array("modifiers",%x),%y)
#define YesNo(%val) $Select(%val:$$$Text("Yes"),1:$$$Text("No"))

#; Escape sequence for coloring the font
#define escClear $c(27)_"[0m"
#define escBg $Case(##class(%ZPM.PackageManager.Client.Settings).GetValue("ColorScheme"),"white":47,"dark":40,:0)
#define escGreen(%t) $Select($$$escBg=0:%t,1:$c(27)_"[1;32;"_$$$escBg_"m"_%t_$$$escClear)
#define escBlue(%t) $Select($$$escBg=0:%t,1:$c(27)_"[1;36;"_$$$escBg_"m"_%t_$$$escClear)
#define escDefault(%t) $Select($$$escBg=0:%t,1:$c(27)_"[1;3"_$Select($$$escBg=47:0,1:7)_";"_$$$escBg_"m"_%t_$$$escClear)
#define escYellow(%t) $Select($$$escBg=0:%t,1:$c(27)_"[1;33;"_$$$escBg_"m"_%t_$$$escClear)
#define escViolet(%t) $Select($$$escBg=0:%t,1:$c(27)_"[1;35;"_$$$escBg_"m"_%t_$$$escClear)
#define escSeq(%e,%t) $Select($$$escBg=0:%t,1:$c(27)_"["_%e_"m"_%t_$$$escClear)

#; Copied from HS.JSON.INC
#include %occReference
#if $$$comClassDefined("%Library.Object")
    #def1arg JsonMethodClassIsLatestVersion(%arg) $classIsLatestVersion(%arg)
    						//usage: obj.$$$JsonClassIsLatestVersion()
    #def1arg JsonMethodExtends(%arg) $extends(%arg)
    						//usage: {}.$$$JsonExtends(classname) 
	#def1arg JsonMethodFromJSON(%arg) $fromJSON(%arg)
    						//usage: {}.$$$JsonFromJSON(string) 
    #def1arg JsonMethodGetIterator(%arg) $getIterator(%arg)
    						//usage: obj.$$$JsonGetIterator()
    #def1arg JsonMethodGetNext(%arg) $getNext(%arg)
    						//usage: iterator.$$$JsonGetNext(.key, .value)
    #def1arg JsonMethodIsA(%arg) $isA(%arg)
    						//usage: obj.$$$JsonIsA(classname)
    #def1arg JsonMethodToJSON(%arg) $toJSON(%arg)
    						//usage: obj.$$$JsonToJSON()
    #def1arg JsonMethodGet(%arg) $get(%arg)
    						//usage: obj.$$$JsonGet(key)
    #def1arg JsonMethodGetTypeOf(%arg) $getTypeOf(%arg)
    						//usage: obj.$$$JsonMethodGetTypeOf(key)
    #def1arg JsonMethodIsDefined(%arg) $isDefined(%arg)
    						//usage: obj.$$$JsonIsDefined(key) 
    #def1arg JsonMethodRemove(%arg) $remove(%arg)
    						//usage: obj.$$$JsonRemove(key)
    #def1arg JsonMethodSet(%arg) $set(%arg)
    						//usage: obj.$$$JsonSet(key, val)
    #def1arg JsonMethodSize(%arg) $size(%arg)
    						// usage: obj.$$$JsonSize()
    #def1arg JsonMethodPop(%arg) $pop(%arg)
    						//usage: obj.$$$JsonPop()
    #def1arg JsonMethodPush(%arg) $push(%arg)
    						//usage: obj.$$$JsonPush(val)
	#define JsonClassAbstract %Library.AbstractObject
	#define JsonClassObject %Library.Object
	#define JsonClassArray %Library.Array
#else
    #def1arg JsonMethodClassIsLatestVersion(%arg) %ClassIsLatestVersion(%arg)
    						//usage: obj.$$$JsonClassIsLatestVersion()
    #def1arg JsonMethodExtends(%arg) %Extends(%arg)
    						//usage: {}.$$$JsonExtends(classname) 
    #def1arg JsonMethodFromJSON(%arg) %FromJSON(%arg)
    						//usage: {}.$$$JsonFromJSON(string) 
    #def1arg JsonMethodGetIterator(%arg) %GetIterator(%arg)
    						//usage: obj.$$$JsonGetIterator()
	#def1arg JsonMethodGetNext(%arg) %GetNext(%arg)
    						//usage: iterator.$$$JsonGetNext(.key, .value)
    #def1arg JsonMethodGetTypeOf(%arg) %GetTypeOf(%arg)
    						//usage: obj.$$$JsonMethodGetTypeOf(key)
	#def1arg JsonMethodIsA(%arg) %IsA(%arg)
    						//usage: obj.$$$JsonIsA(className)
    #def1arg JsonMethodToJSON(%arg) %ToJSON(%arg)
    						//usage: obj.$$$JsonToJSON()
    #def1arg JsonMethodGet(%arg) %Get(%arg)
    						//usage: obj.$$$JsonGet(key)
    #def1arg JsonMethodIsDefined(%arg) %IsDefined(%arg)
    						//usage: obj.$$$JsonIsDefined(key) 
    #def1arg JsonMethodRemove(%arg) %Remove(%arg)
    						//usage: obj.$$$JsonRemove(key)
    #def1arg JsonMethodSet(%arg) %Set(%arg)
    						//usage: obj.$$$JsonSet(key, val)
    #def1arg JsonMethodSize(%arg) %Size(%arg)
    						//usage: obj.$$$JsonSize()
    #def1arg JsonMethodPop(%arg) %Pop(%arg)
    						//usage: obj.$$$JsonPop()
    #def1arg JsonMethodPush(%arg) %Push(%arg)
    						//usage: obj.$$$JsonPush(val) 
	#define JsonClassAbstract %Library.DynamicAbstractObject
	#define JsonClassObject %Library.DynamicObject
	#define JsonClassArray %Library.DynamicArray
#endif

#define JsonDisableNode ^||ISC.HS.Config("JSON","DisableDynamic")
#define JsonDisable Set $$$JsonDisableNode = 1
#define JsonEnable Kill $$$JsonDisableNode
#define JsonIsEnabled '$Get($$$JsonDisableNode,0)

#define JsonQuotedClassAbstract ##Quote($$$JsonClassAbstract)
#define JsonQuotedClassObject ##Quote($$$JsonClassObject)
#define JsonQuotedClassArray ##Quote($$$JsonClassArray)

#if $$$comClassDefined($$$JsonQuotedClassObject)
	#define JsonIsSupported 1
#else
	#define JsonIsSupported 0
#endif
]]></Routine>


<Class name="%ZPM.PackageManager.Core.Application">
<Super>%RegisteredObject,%ZPM.PackageManager.Core.VersionedBase</Super>
<TimeCreated>65797,80971.577135</TimeCreated>

<Parameter name="XMLTYPE">
<Default>CoreApplication</Default>
</Parameter>

<Property name="Payload">
<Type>%Stream.GlobalBinary</Type>
</Property>
</Class>


<Class name="%ZPM.PackageManager.Core.IPackageService">
<Abstract>1</Abstract>
<TimeCreated>65797,80971.557734</TimeCreated>

<Method name="GetApplication">
<Abstract>1</Abstract>
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
</Method>

<Method name="GetApplicationDirectory">
<Abstract>1</Abstract>
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%String</ReturnType>
</Method>

<Method name="GetApplicationManifest">
<Abstract>1</Abstract>
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
</Method>

<Method name="GetModule">
<Abstract>1</Abstract>
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference,*AsArchive:%Boolean=0</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
</Method>

<Method name="GetModuleDirectory">
<Abstract>1</Abstract>
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%String</ReturnType>
</Method>

<Method name="GetModuleManifest">
<Abstract>1</Abstract>
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Stream.Object</ReturnType>
</Method>

<Method name="HasApplication">
<Abstract>1</Abstract>
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Boolean</ReturnType>
</Method>

<Method name="HasModule">
<Abstract>1</Abstract>
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Boolean</ReturnType>
</Method>

<Method name="ListApplications">
<Abstract>1</Abstract>
<FormalSpec>pSearchCriteria:%ZPM.PackageManager.Core.SearchCriteria</FormalSpec>
<ReturnType>%ListOfObjects</ReturnType>
<ReturnTypeParams>ELEMENTTYPE="%ZPM.PackageManager.Core.ResolvedModuleReference"</ReturnTypeParams>
</Method>

<Method name="ListModules">
<Abstract>1</Abstract>
<FormalSpec>pSearchCriteria:%ZPM.PackageManager.Core.SearchCriteria</FormalSpec>
<ReturnType>%ListOfObjects</ReturnType>
<ReturnTypeParams>ELEMENTTYPE="%ZPM.PackageManager.Core.ResolvedModuleReference"</ReturnTypeParams>
</Method>

<Method name="Supports">
<Description>
Returns 1 if the service supports a particular method.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMethod:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit 0
]]></Implementation>
</Method>

<Method name="IsAvailable">
<Description>
For run-time checks to ensure the service is available before attempting to invoke it.</Description>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit 1
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Core.IPublishService">
<Abstract>1</Abstract>
<TimeCreated>65797,80971.562489</TimeCreated>

<Method name="PublishModule">
<Abstract>1</Abstract>
<FormalSpec>pModule:%ZPM.PackageManager.Core.Module</FormalSpec>
<ReturnType>%Boolean</ReturnType>
</Method>

<Method name="PublishApplication">
<Abstract>1</Abstract>
<FormalSpec>pApplication:%ZPM.PackageManager.Core.Application</FormalSpec>
<ReturnType>%Boolean</ReturnType>
</Method>

<Method name="IsAvailable">
<Description>
For run-time checks to ensure the service is available before attempting to invoke it.</Description>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit 1
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Core.InstallationInfo">
<Super>%RegisteredObject</Super>
<TimeCreated>65797,80971.600829</TimeCreated>

<Property name="Namespace">
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="IsUpgrade">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Property name="ModuleReference">
<Type>%ZPM.PackageManager.Core.QualifiedModuleReference</Type>
<Required>1</Required>
</Property>

<Property name="Parameters">
<Type>%String</Type>
<Collection>array</Collection>
</Property>
</Class>


<Class name="%ZPM.PackageManager.Core.InvokeReference">
<Abstract>1</Abstract>
<Super>%XML.Adaptor</Super>
<TimeCreated>65797,80971.603784</TimeCreated>

<Parameter name="NAMESPACE">
<Type>STRING</Type>
<Default>http://www.intersystems.com/PackageManager</Default>
</Parameter>
</Class>


<Class name="%ZPM.PackageManager.Core.ListOfOptions">
<Super>%Library.List</Super>
<TimeCreated>65797,80971.667222</TimeCreated>

<Parameter name="VALUELIST">
<Description>
If specified, validation ensures that each element in the list is one of the specified values.</Description>
</Parameter>

<Parameter name="DISPLAYLIST">
<Description><![CDATA[
Used in conjunction with <parameter>VALUELIST</parameter>.]]></Description>
</Parameter>

<Method name="XSDToLogical">
<Description>
Converts the SOAP encoded input list value into a Cache $list value.
Overridden to generate even in non-XML enabled classes (implementation copied from parent and minimally modified)</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec>val:%String</FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set odbcdelim=%parameter("ODBCDELIMITER")
	If odbcdelim="," Set odbcdelim=""
	Set odbcdelim=$select(odbcdelim'="":","""_odbcdelim_"""",1:"")
	$$$GENERATE("	Quit $listfromstring(val"_odbcdelim_")")
]]></Implementation>
</Method>

<Method name="LogicalToXSD">
<Description>
Converts the Cache $list value to the canonical SOAP encoded value.
Overridden to generate even in non-XML enabled classes (implementation copied from parent and minimally modified)</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec>val:%List</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set odbcdelim=%parameter("ODBCDELIMITER")
	If odbcdelim="," Set odbcdelim=""
	Set odbcdelim=$select(odbcdelim'="":","""_odbcdelim_"""",1:",")
	$$$GENERATE("	Quit $zcvt($listtostring(val"_odbcdelim_",1),""O"",""XML"")")
]]></Implementation>
</Method>

<Method name="DisplayToLogical">
<Description><![CDATA[
Converts the input value <var>%val</var>, which is a string, into the logical string format,  based on <parameter>VALUELIST</parameter> and <parameter>DISPLAYLIST</parameter>.
Returns the logical value of the input string <var>%val</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>%val:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tDelimiter = %parameter("ODBCDELIMITER")
	Set tDelimiterCode = $Case(tDelimiter, ",":"", "":"", :","_$$$QUOTE(tDelimiter))
	If (%parameter("VALUELIST") '= "") && (%parameter("DISPLAYLIST") '= "") {
		Set tValuePointer = 0
		Set tDisplayPointer = 0
		Set tValueList = $ListFromString(%parameter("VALUELIST"))
		Set tDisplayList = $ListFromString(%parameter("DISPLAYLIST"))
		
		Do %code.WriteLine(" Set tLogicalList = """"")
		Do %code.WriteLine(" Set tPointer = 0")
		Do %code.WriteLine(" Set tVal = $ListFromString(%val"_tDelimiterCode_")")
		Do %code.WriteLine(" While $ListNext(tVal,tPointer,tValue) {")
		Do %code.WriteLine("  Set tLogicalList = tLogicalList_$ListBuild($Case(tValue")
		While $ListNext(tValueList,tValuePointer,tValue) && $ListNext(tDisplayList,tDisplayPointer,tDisplay) {
			Do %code.WriteLine("  ,"_$$$QUOTE(tDisplay)_":"_$$$QUOTE(tValue))
		}
		Do %code.WriteLine("  ))")
		Do %code.WriteLine(" }")
		Do %code.WriteLine(" Quit tLogicalList")
	} Else {
		Do %code.WriteLine(" Quit $ListFromString(%val"_tDelimiterCode_")")
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="LogicalToDisplay">
<Description><![CDATA[
Converts the value of <var>%val</var>, which is in logical format, into a display string, based on <parameter>VALUELIST</parameter> and <parameter>DISPLAYLIST</parameter>.
<p>Returns the string value of <var>%val</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>%val:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tDelimiter = %parameter("ODBCDELIMITER")
	Set tDelimiterCode = $Case(tDelimiter, ",":"", "":"", :","_$$$QUOTE(tDelimiter))
	If (%parameter("VALUELIST") '= "") && (%parameter("DISPLAYLIST") '= "") {
		Set tValuePointer = 0
		Set tDisplayPointer = 0
		Set tValueList = $ListFromString(%parameter("VALUELIST"))
		Set tDisplayList = $ListFromString(%parameter("DISPLAYLIST"))
		
		Do %code.WriteLine(" Set tDisplayList = """"")
		Do %code.WriteLine(" Set tPointer = 0")
		Do %code.WriteLine(" While $ListNext(%val,tPointer,tValue) {")
		Do %code.WriteLine("  Set tDisplayList = tDisplayList_$ListBuild($Case(tValue")
		While $ListNext(tValueList,tValuePointer,tValue) && $ListNext(tDisplayList,tDisplayPointer,tDisplay) {
			Do %code.WriteLine("  ,"_$$$QUOTE(tValue)_":"_$$$QUOTE(tDisplay))
		}
		Do %code.WriteLine("  ))")
		Do %code.WriteLine(" }")
		Do %code.WriteLine(" Quit $ListToString(tDisplayList"_tDelimiterCode_")")
	} Else {
		Do %code.WriteLine(" Quit $ListToString(%val"_tDelimiterCode_")")
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="IsValid">
<Description><![CDATA[
Tests if the logical value <var>%val</var>, which is a string, is valid.
The validation is based on the class parameter settings used for the class attribute this data type is associated with.
In this case, <a href="#MINLEN">MINLEN</a>, <a href="#MAXLEN">MAXLEN</a>, <a href="#VALUELIST">VALUELIST</a>, and <a href="#PATTERN">PATTERN</a>.]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>%val:%CacheString</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do %code.WriteLine(" If '$ListValid(%val) {")
	Do %code.WriteLine("  Quit $$$ERROR($$$DTFailure,%val)")
	Do %code.WriteLine(" }")
	If (%parameter("VALUELIST") '= "") {
		Set tValueList = $ListFromString(%parameter("VALUELIST"))
		Set tValuePointer = 0
		Do %code.WriteLine(" Set tPointer = 0, tIsValid = 1")
		Do %code.WriteLine(" While tIsValid && $ListNext(%val,tPointer,tValue) {")
		Do %code.WriteLine("  Set tIsValid = tIsValid && $Case(tValue")
		While $ListNext(tValueList,tValuePointer,tValue) {
			Do %code.WriteLine("  ,"_$$$QUOTE(tValue)_":1")
		}
		Do %code.WriteLine("  ,:0)")
		Do %code.WriteLine(" }")
		Do %code.WriteLine(" If 'tIsValid { Quit $$$ERROR($$$DTValueList,tValue,"_$$$quote(%parameter("VALUELIST"))_") }")
	}
	Do %code.WriteLine(" Quit $$$OK")
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Core.MappingReference">
<Abstract>1</Abstract>
<Super>%XML.Adaptor</Super>
<TimeCreated>65797,80971.659092</TimeCreated>

<Parameter name="NAMESPACE">
<Type>STRING</Type>
<Default>http://www.intersystems.com/PackageManager</Default>
</Parameter>

<Property name="Name">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="2048"/>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>
</Class>


<Class name="%ZPM.PackageManager.Core.Module">
<Super>%RegisteredObject,%ZPM.PackageManager.Core.VersionedBase</Super>
<TimeCreated>65797,80971.635201</TimeCreated>

<Parameter name="XMLTYPE">
<Default>CoreModule</Default>
</Parameter>

<Property name="Payload">
<Type>%Stream.GlobalBinary</Type>
<Parameter name="%JSONFIELDNAME" value="package"/>
</Property>
</Class>


<Class name="%ZPM.PackageManager.Core.ModuleInfo.QueryUtils">
<TimeCreated>65797,80971.760574</TimeCreated>

<Method name="moduleSqlToList">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pQuery:%String,pSearchCriteria:%ZPM.PackageManager.Core.SearchCriteria,&pArgs]]></FormalSpec>
<ReturnType>%Library.ListOfObjects</ReturnType>
<Implementation><![CDATA[
	If '$IsObject($Get(pSearchCriteria)) {
		 Set pSearchCriteria = ##class(%ZPM.PackageManager.Core.SearchCriteria).%New()
	}
	Merge tArgs = pArgs
	Set tKeywordList = ""
	Set tWhereParts = ""
	Set tOrderByParts = ""
	If (pSearchCriteria.Name '= "") {
		Set tArgs($i(tArgs)) = pSearchCriteria.Name
		If (pSearchCriteria.VersionExpression '= "") {
			Set tArgs($i(tArgs)) = pSearchCriteria.VersionExpression
		} Else {
			Set tArgs($i(tArgs)) = "*"
		}
	} Else {
		Set tArgs($i(tArgs)) = ""
		Set tArgs($i(tArgs)) = "*"
	}
	
	Set tSearchParams = ""
	If (pSearchCriteria.IncludeSnapshots) {
		Set tSearchParams = tSearchParams_$ListBuild("snapshot")
	}
	If (pSearchCriteria.IncludePrerelease) {
		Set tSearchParams = tSearchParams_$ListBuild("prerelease")
	}
	Set tArgs($i(tArgs)) = $ListToString(tSearchParams," ")
	
	If (pSearchCriteria.Keywords.Count() > 0) {
		Set tWhereParts = tWhereParts_$ListBuild("%SIMILARITY(Manifest,?) > 0")
		For i=1:1:pSearchCriteria.Keywords.Count() {
			Set tKeywordList = tKeywordList_$ListBuild(pSearchCriteria.Keywords.GetAt(i))
		}
		Set tKeywordList = $ListFromString(tKeywordList," ")
		Set tArgs($i(tArgs)) = tKeywordList
	}
	
	If (tWhereParts '= "") {
		Set pQuery = pQuery_" where "_$ListToString(tWhereParts," and ")
	}
	
	// List exact version matches first.
	If (pSearchCriteria.VersionExpression '= "") {
		Set tOrderByParts = tOrderByParts_$ListBuild("case m.VersionString when ? then 0 else 1 end")
		Set tArgs($i(tArgs)) = pSearchCriteria.VersionExpression
	}
	
	If (tKeywordList '= "") {
		// TODO: Find some way to order by max similarity (or just similarity of latest version of the module) instead?
		Set tOrderByParts = tOrderByParts_$ListBuild("%SIMILARITY(Manifest,?) desc")
		Set tOrderByArgs($i(tOrderByArgs)) = tKeywordList
	}
	
	// TVF returns items in correct order - so order by that.
	Set tOrderByParts = tOrderByParts_$ListBuild("m.%id asc")
	
	If (tOrderByParts '= "") {
		Set pQuery = pQuery_" order by "_$ListToString(tOrderByParts,",")
		For i=1:1:$Get(tOrderByArgs) {
			Set tArgs($i(tArgs)) = tOrderByArgs(i)
		}
	}
	
	Set tList = ##class(%Library.ListOfObjects).%New()
	Set tRes = ##class(%SQL.Statement).%ExecDirect(,pQuery,tArgs...)
	If (tRes.%SQLCODE < 0) {
		$$$ThrowStatus($$$ERROR($$$SQLCode,tRes.%SQLCODE,tRes.%Message))
	}
	While (tRes.%Next(.tStatus)) {
		If $$$ISERR(tStatus) {
			Quit
		}
		
		Set tModRef = ##class(%ZPM.PackageManager.Core.ResolvedModuleReference).%New()
		Set tModRef.Name = tRes.%Get("Name")
		Set tModRef.VersionString = tRes.%Get("VersionString")
		Do tList.Insert(tModRef)
	}
	If $$$ISERR(tStatus) {
		$$$ThrowStatus(tStatus)
	}
	Quit tList
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Core.ModuleInfo">
<Abstract>1</Abstract>
<StorageStrategy/>
<Super>%XML.Adaptor,%ZPM.JSON.Adaptor</Super>
<TimeCreated>65797,80971.634604</TimeCreated>

<Parameter name="NAMESPACE">
<Type>STRING</Type>
<Default>http://www.intersystems.com/PackageManager</Default>
</Parameter>

<Parameter name="XMLIGNOREINVALIDTAG">
<Default>1</Default>
</Parameter>

<Parameter name="XMLIGNOREINVALIDATTRIBUTE">
<Default>1</Default>
</Parameter>

<Property name="Name">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="%JSONFIELDNAME" value="name"/>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="Description">
<Type>%String</Type>
<Parameter name="%JSONFIELDNAME" value="description"/>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="Version">
<Type>%ZPM.PackageManager.Core.SemanticVersion</Type>
<Required>1</Required>
<Parameter name="%JSONINCLUDE" value="NONE"/>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="VersionString">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="%JSONFIELDNAME" value="version"/>
<Parameter name="MAXLEN" value="100"/>
<Parameter name="XMLNAME" value="Version"/>
</Property>

<Property name="Repo">
<Type>%String</Type>
<Parameter name="%JSONINCLUDE" value="NONE"/>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Method name="VersionStringSet">
<FormalSpec>tValue</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%VersionString = tValue
	Set ..Version = ##class(%ZPM.PackageManager.Core.SemanticVersion).FromString(tValue)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="VersionStringGet">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ..Version.ToString()
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Core.ModuleReference">
<Description>
@PublicAPI</Description>
<StorageStrategy/>
<Super>%SerialObject,%XML.Adaptor</Super>
<TimeCreated>65797,80971.646815</TimeCreated>

<Parameter name="NAMESPACE">
<Type>STRING</Type>
<Default>http://www.intersystems.com/PackageManager</Default>
</Parameter>

<Property name="Name">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="Version">
<Type>%ZPM.PackageManager.Core.SemanticVersionExpression</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="VersionString">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="100"/>
<Parameter name="XMLNAME" value="Version"/>
</Property>

<Property name="Scope">
<Description>
Restrict the scope in which this reference is relevant. Default is "all scopes"</Description>
<Type>%String</Type>
<Parameter name="VALUELIST" value=",test,verify"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="VersionStringSet">
<FormalSpec>tValue</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%VersionString = tValue
	Set tSC = ##class(%ZPM.PackageManager.Core.SemanticVersionExpression).FromString(tValue,.tExpression)
	If $$$ISOK(tSC) {
		Set ..Version = tExpression
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="NameSet">
<FormalSpec>val:%ZPM.cache.RawString</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set i%Name = $$$lcase(val)
	QUIT $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>ModuleReferenceState</State>
<StreamLocation>^ZPM.PackageManager9CFF.ModuleReferB471S</StreamLocation>
<Data name="ModuleReferenceState">
<Value name="1">
<Value>Name</Value>
</Value>
<Value name="2">
<Value>Version</Value>
</Value>
<Value name="3">
<Value>VersionString</Value>
</Value>
<Value name="4">
<Value>Scope</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Core.QualifiedModuleReference">
<Super>%ZPM.PackageManager.Core.ResolvedModuleReference</Super>
<TimeCreated>65797,80971.648692</TimeCreated>

<Property name="ServerName">
<Type>%String</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>pServerName:%String="",pResolvedReference:%ZPM.PackageManager.Core.ResolvedModuleReference=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If (pServerName '= "") {
		Set ..ServerName = pServerName
	}
	If (pResolvedReference '= "") {
		Set ..Name = pResolvedReference.Name
		Set ..Version = pResolvedReference.Version
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<Data name="ResolvedModuleReferenceState">
<Value name="1">
<Value>Name</Value>
</Value>
<Value name="2">
<Value>Version</Value>
</Value>
<Value name="3">
<Value>VersionString</Value>
</Value>
<Value name="4">
<Value>ServerName</Value>
</Value>
<Value name="5">
<Value>Repo</Value>
</Value>
<Value name="6">
<Value>Description</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Core.RegExString">
<Description><![CDATA[
A string datatype definition which extends <class>%Library.String</class> with additional regex pattern validation. <br />
From https://community.intersystems.com/post/string-datatype-regular-expression-validation]]></Description>
<ClassType>datatype</ClassType>
<Super>%Library.String</Super>
<TimeCreated>65797,80971.69071</TimeCreated>

<Parameter name="PATTERN">
<Description><![CDATA[
Set PATTERN to empty and final, as it is not relevant on
this type, but is inherited from <class>%Library.String</class>]]></Description>
<Final>1</Final>
</Parameter>

<Parameter name="VALUELIST">
<Description><![CDATA[
Set VALUELIST to empty and final, as it is not relevant on
this type, but is inherited from <class>%Library.String</class>]]></Description>
<Final>1</Final>
</Parameter>

<Parameter name="DISPLAYLIST">
<Description><![CDATA[
Set DISPLAYLIST to empty and final, as it is not relevant on
this type, but is inherited from <class>%Library.String</class>]]></Description>
<Final>1</Final>
</Parameter>

<Parameter name="REGEX">
<Description>
Set a valid regex pattern for value validation</Description>
<Type>STRING</Type>
</Parameter>

<Parameter name="XMLPATTERN">
<Description>
The XMLPATTERN to regex by default. Can be overridden.</Description>
<Expression>..#REGEX</Expression>
</Parameter>

<Method name="IsValid">
<Description><![CDATA[
Tests if the logical value <var>%val</var>, which is a string, is valid.
The validation is based on the class parameter settings used for the class attribute this data type is associated with.
In this case, <a href="#MINLEN">MINLEN</a>, <a href="#MAXLEN">MAXLEN</a>, and <a href="#REGEX">REGEX</a>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>%val:%CacheString</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>0</ServerOnly>
<Implementation><![CDATA[
    // Length checks
    if (..#MAXLEN '= "") {
        if ($length(%val) > ..#MAXLEN) {
            return $$$ERROR($$$DTMaxLen, %val, ..#MAXLEN)
        }
    }
    if (..#MINLEN '= "") {
        if ($length(%val) < ..#MINLEN) {
            return $$$ERROR($$$DTMinLen, %val, ..#MINLEN)
        }
    }
    // Regex check
    if (..#REGEX '= "") {
        try {
            if '$MATCH(%val, ..#REGEX) {
                return $$$ERROR($$$DTPattern, %val, ..#REGEX)
            }
        } catch e {
            return e.AsStatus()
        }
    }
    return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Core.ResolvedModuleReference">
<StorageStrategy/>
<Super>%SerialObject,%ZPM.PackageManager.Core.ModuleInfo</Super>
<TimeCreated>65797,80971.689623</TimeCreated>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>ResolvedModuleReferenceState</State>
<StreamLocation>^ZPM.PackageManager9CFF.ResolvedMod1E11S</StreamLocation>
<Data name="ResolvedModuleReferenceState">
<Value name="1">
<Value>Name</Value>
</Value>
<Value name="2">
<Value>Version</Value>
</Value>
<Value name="3">
<Value>VersionString</Value>
</Value>
<Value name="4">
<Value>Description</Value>
</Value>
<Value name="5">
<Value>Repo</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Core.ResourceReference">
<Abstract>1</Abstract>
<Super>%XML.Adaptor</Super>
<TimeCreated>65797,80971.716674</TimeCreated>

<Parameter name="NAMESPACE">
<Type>STRING</Type>
<Default>http://www.intersystems.com/PackageManager</Default>
</Parameter>

<Property name="Name">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="255"/>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>
</Class>


<Class name="%ZPM.PackageManager.Core.SearchCriteria">
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeCreated>65797,80971.726298</TimeCreated>

<Parameter name="NAMESPACE">
<Type>STRING</Type>
<Default>http://www.intersystems.com/PackageManager</Default>
</Parameter>

<Parameter name="XMLIGNOREINVALIDTAG">
<Default>1</Default>
</Parameter>

<Parameter name="XMLIGNOREINVALIDATTRIBUTE">
<Default>1</Default>
</Parameter>

<Property name="Name">
<Type>%String</Type>
</Property>

<Property name="VersionExpression">
<Type>%String</Type>
</Property>

<Property name="Registry">
<Type>%String</Type>
</Property>

<Property name="IncludePrerelease">
<Type>%Boolean</Type>
</Property>

<Property name="IncludeSnapshots">
<Type>%Boolean</Type>
</Property>

<Property name="Keywords">
<Type>%String</Type>
<Collection>list</Collection>
</Property>

<Method name="KeywordsSet">
<FormalSpec>%value</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If $IsObject(%value) {
		Set i%Keywords = %value
	} Else {
		Do ..Keywords.Clear()
		If '$ListValid(%value) {
			Set %value = $ListFromString(%value," ")
		}
		Set tPointer = 0
		While $ListNext(%value,tPointer,tValue) {
			If ($Get(tValue) '= "") {
				Do ..Keywords.Insert(tValue)
			}
		}
	}
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Core.SemVer.Comparator">
<Super>%SerialObject</Super>
<TimeCreated>65797,80971.780506</TimeCreated>

<Property name="Expression">
<Type>%String</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Operator">
<Type>%String</Type>
<InitialExpression>"="</InitialExpression>
<Required>1</Required>
<Parameter name="VALUELIST" value=",=,&lt;,&lt;=,&gt;,&gt;="/>
</Property>

<Property name="Major">
<Type>%Integer</Type>
<Required>1</Required>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="Minor">
<Type>%Integer</Type>
<Required>1</Required>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="Patch">
<Type>%Integer</Type>
<Required>1</Required>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="Prerelease">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100"/>
</Property>

<Property name="Build">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100"/>
</Property>

<Method name="%OnNew">
<FormalSpec>pExpr:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set i%Expression = pExpr
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ToString">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..Expression
]]></Implementation>
</Method>

<Method name="ToResolvedString">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..Operator_..Major_"."_..Minor_"."_..Patch_$Case(..Prerelease,"":"",:"-"_..Prerelease)_$Case(..Build,"":"",:"+"_..Build)
]]></Implementation>
</Method>

<Method name="FromString">
<ClassMethod>1</ClassMethod>
<FormalSpec>pExpr:%String,*pComparator:%ZPM.PackageManager.Core.SemVer.Comparator</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pComparator = ..%New(pExpr)
	Try {
		Set tFirst = $E(pExpr)
		Set tSecond = $E(pExpr,2)
		If (tFirst '= +tFirst) {
			If (tSecond '= +tSecond) {
				Set pComparator.Operator = tFirst_tSecond
				Set pExpr = $E(pExpr,3,*)
			} Else {
				Set pComparator.Operator = tFirst
				Set pExpr = $E(pExpr,2,*)
			}
		}
		
		// Ensure we got a valid operator.
		Set tSC = ##class(%ZPM.PackageManager.Core.SemVer.Comparator).OperatorIsValid(pComparator.Operator)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set pComparator.Major = $Piece(pExpr,".",1)
		Set pComparator.Minor = $Piece(pExpr,".",2)
		Set tEnd = $Piece(pExpr,".",3)
		Set pComparator.Patch = $Piece($Piece(tEnd,"-"),"+") // Before -prerelease and/or +build
		Set pComparator.Prerelease = $Piece($Piece(tEnd,"-",2),"+") // After - and possibly before +build
		Set pComparator.Build = $Piece(tEnd,"+",2)
		
		Set tSC = pComparator.%ValidateObject()
		If $$$ISERR(tSC) {
			Quit
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	If $$$ISERR(tSC) {
		Set tSC = $System.Status.EmbedStatus($$$ERROR($$$GeneralError,"Error parsing semantic version expression: "_pExpr),tSC)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="Evaluate">
<FormalSpec>pVersion:%ZPM.PackageManager.Core.SemanticVersion</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Must prereleases match?
	Set tEquals = (..Operator [ "=") && (pVersion.Major = ..Major) && (pVersion.Minor = ..Minor) && (pVersion.Patch = ..Patch) && (pVersion.Prerelease = ..Prerelease)
	If (..Operator = "=") {
		Quit tEquals
	}
	
	Set tCompVersion = ##class(%ZPM.PackageManager.Core.SemanticVersion).%New()
	Set tCompVersion.Major = ..Major
	Set tCompVersion.Minor = ..Minor
	Set tCompVersion.Patch = ..Patch
	Set tCompVersion.Prerelease = ..Prerelease
	
	If (..Operator [ "<") {
		Quit tCompVersion.Follows(pVersion) || tEquals
	} Else {
		Quit pVersion.Follows(tCompVersion) || tEquals
	}
	
	Quit 1
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>ComparatorState</State>
<StreamLocation>^ZPM.PackageManager.Core33CB.ComparatorS</StreamLocation>
<Data name="ComparatorState">
<Value name="1">
<Value>Operator</Value>
</Value>
<Value name="2">
<Value>Major</Value>
</Value>
<Value name="3">
<Value>Minor</Value>
</Value>
<Value name="4">
<Value>Patch</Value>
</Value>
<Value name="5">
<Value>Metadata</Value>
</Value>
<Value name="6">
<Value>Expression</Value>
</Value>
<Value name="7">
<Value>Prerelease</Value>
</Value>
<Value name="8">
<Value>Build</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Core.SemVer.Range">
<Super>%SerialObject</Super>
<TimeCreated>65797,80971.781727</TimeCreated>

<Property name="Expression">
<Type>%String</Type>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Comparators">
<Type>%ZPM.PackageManager.Core.SemVer.Comparator</Type>
<Collection>list</Collection>
</Property>

<Method name="%OnNew">
<FormalSpec>pRangeExpr:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
  Set i%Expression = pRangeExpr
  Quit $$$OK
]]></Implementation>
</Method>

<Method name="ToString">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..Expression
]]></Implementation>
</Method>

<Method name="ToResolvedString">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  Set tCompList = ""
  For i=1:1:..Comparators.Count() {
    Set tComp = ..Comparators.GetAt(i)
    Set tCompList = tCompList_$ListBuild(tComp.ToResolvedString())
  }
  Quit $ListToString(tCompList," ")
]]></Implementation>
</Method>

<Method name="FromString">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRangeExpr:%String,*pRange:%ZPM.PackageManager.Core.SemVer.Range</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  Set tSC = $$$OK
  Set pRange = ..%New(pRangeExpr)
  Try {
    // Separate AND-ed comparators, rejoining ranges with dashes to handle individually
    Set tSpaceParts = $ListFromString(pRangeExpr," ")
    Set tPtr = 0
    Set tExpressions = ""
    While $ListNext(tSpaceParts,tPtr,tPart) {
      If (tPart = "-") {
        // Convert hyphen ranges to simple comparators
        Set tFound = $ListNext(tSpaceParts,tPtr,tMax)
        If 'tFound {
          Set tSC = $$$ERROR($$$GeneralError,"Invalid range expression: "_pRangeExpr)
          Quit
        }
        
        Set tMin = $List(tExpressions,*)
        
        // Partial version as min version: add zeros.
        Set tMinDotLength = $Length(tMin,".")
        For i=3:-1:tMinDotLength {
          Set tMin = tMin_".0"
        }
        Set $List(tExpressions,*) = ">="_tMin
        
        // Partial version as max version: implied .x
        Set tMaxDotLength = $Length(tMax,".")
        Set tOp = "<="
        If (tMaxDotLength < 3) {
          Set tOp = "<"
          Set $Piece(tMax,".",tMaxDotLength) = 1 + $Piece(tMax,".",tMaxDotLength)
          For i=3:-1:tMaxDotLength {
            Set tMax = tMax_".0"
          }
        }
        Set tExpressions = tExpressions_$ListBuild(tOp_tMax)
      } Else {
        Set tExpressions = tExpressions_$ListBuild(tPart)
      }
    }
    If $$$ISERR(tSC) {
      Quit
    }
    
    // Convert advanced ranges to primitive comparators
    Set tComparators = ""
    Set tPtr = 0
    While $ListNext(tExpressions,tPtr,tExpr) {
      // Get part after operator and before build/metadata
      // Normalize x ranges
      Set tMajorMinorPatch = $Translate($ZStrip($Piece($Piece(tExpr,"-"),"+"),"<W","<>=^~"),"X*","xx")
      Set tMajor = $Piece(tMajorMinorPatch,".",1)
      Set tMinor = $Piece(tMajorMinorPatch,".",2)
      Set tPatch = $Piece(tMajorMinorPatch,".",3)
      
      // Detect different expression cases
      Set tIsXRange = (tMajorMinorPatch [ "x") || (tExpr = "") || (tExpr = "*") || (tMinor = "") || (tPatch = "")
      Set tIsTildeRange = ($Extract(tExpr) = "~")
      Set tIsCaretRange = ($Extract(tExpr) = "^")
      
      If '(tIsXRange || tIsTildeRange || tIsCaretRange) {
        // Primitive comparator
        Set tComparators = tComparators_$ListBuild(tExpr)
      } ElseIf tIsTildeRange {
        // Tilde ranges:
        // "Allows patch-level changes if a minor version is specified on the comparator. Allows minor-level changes if not."
        
        Set tExpr = $Extract(tExpr,2,*)
        Set tDotLength = $Length(tExpr,".")
        
        If (tDotLength < 3) {
          // Convert missing minor/patch to "X range":
          Set tExpr = tExpr_".x"
          Set tIsXRange = 1
        } Else {
          // Minimum: at least the full specified version
          Set tComparators = tComparators_$ListBuild(">="_tExpr)
          
          // Maximum based on leftmost nonzero value
          Set tMajor = $Piece(tExpr,".",1)
          Set tMinor = $Piece(tExpr,".",2)
          
          Set tComparators = tComparators_$ListBuild("<"_tMajor_"."_(tMinor+1)_".0")
        }
      } ElseIf tIsCaretRange {
        // Caret ranges:
        // "Allows changes that do not modify the left-most non-zero digit in the [major, minor, patch] tuple.
        // In other words, this allows patch and minor updates for versions 1.0.0 and above, patch updates for versions 0.X >=0.1.0,
        // and no updates for versions 0.0.X."
        // This case also handles the "x range" and caret range in combination.
        
        Set tExpr = $Extract(tExpr,2,*)
        Set tDotLength = $Length(tExpr,".")
        Set tMajor = $Piece(tMajorMinorPatch,".",1)
        Set tMinor = $Piece(tMajorMinorPatch,".",2)
        Set tPatch = $Piece(tMajorMinorPatch,".",3)
        If (tDotLength < 3) {
          If (tMajor '= 0) && 'tIsXRange {
            Set tComparators = tComparators_$ListBuild(">="_$Replace(tExpr,".x",".0"),"<"_(tMajor+1)_".0.0")
            Set tIsXRange = 0
          } Else {
            // Detected and properly handled by X-range.
          }
        } Else {
          // Minimum
          Set tComparators = tComparators_$ListBuild(">="_$Replace(tExpr,".x",".0"))
          
          Set tMax = ""
          If (+tMajor = 0) && (tMinor '= "x") {
            If (+tMinor = 0) && (tPatch '= "x") {
              Set tMax = "0.0."_(tPatch+1)
            } Else {
              Set tMax = "0."_(tMinor+1)_".0"
            }
          } Else {
            Set tMax = (tMajor+1)_".0.0"
          }
          
          // Maximum
          Set tComparators = tComparators_$ListBuild("<"_tMax)
          
          // X ranges have been handled for this case - disable adding another comparator later.
          Set tIsXRange = 0
        }
      }
      
      If tIsXRange {
        // X ranges
        // Recompute tMajorMinorPatch based on tExpr (possibly modified in other parsing)
        Set tMajorMinorPatch = $Translate($ZStrip($Piece($Piece(tExpr,"-"),"+"),"<W","<>="),"X*","xx")
        Set tMajor = $Piece(tMajorMinorPatch,".",1)
        Set tMinor = $Piece(tMajorMinorPatch,".",2)
        Set tPatch = $Piece(tMajorMinorPatch,".",3)
        
        If (tExpr = "") || (tExpr = "*") || (tMajor = "") {
          // Accept anything!
          Set tComparators = tComparators_$ListBuild(">=0.0.0")
        } ElseIf (tMinor = "") || (tMinor = "x") {
          Set tComparators = tComparators_$ListBuild(">="_tMajor_".0.0","<"_(tMajor+1)_".0.0")
        } ElseIf (tPatch = "") || (tPatch = "x") {
          Set tComparators = tComparators_$ListBuild(">="_tMajor_"."_tMinor_".0","<"_tMajor_"."_(tMinor+1)_".0")
        }
      }
    }
    If $$$ISERR(tSC) {
      Quit
    }
    
    // Actually add primitive comparators to the list.
    Set tPtr = 0
    While $ListNext(tComparators,tPtr,tExpr) {
      // >=0.0.0 seems to be a no-op, so skip it. (Implications for prerelease 0.0.0 versions?)
      If (tExpr '= ">=0.0.0") {
        Set tSC = ##class(%ZPM.PackageManager.Core.SemVer.Comparator).FromString(tExpr,.tComparator)
        If $$$ISERR(tSC) {
          Quit
        }
        Do pRange.Comparators.Insert(tComparator)
      }
    }
  } Catch e {
    Set tSC = e.AsStatus()
  }
  Quit tSC
]]></Implementation>
</Method>

<Method name="InRange">
<FormalSpec>pVersion:%ZPM.PackageManager.Core.SemanticVersion</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  Set tSatisfied = 1
  For i=1:1:..Comparators.Count() {
    If '..Comparators.GetAt(i).Evaluate(pVersion) {
      Set tSatisfied = 0
      Quit
    }
  }
  Quit tSatisfied
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>RangeState</State>
<StreamLocation>^ZPM.PackageManager.Core.SemVer.RangeS</StreamLocation>
<Data name="RangeState">
<Value name="1">
<Value>Comparators</Value>
</Value>
<Value name="2">
<Value>Expression</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Core.SemanticVersion">
<StorageStrategy/>
<Super>%SerialObject,%XML.Adaptor</Super>
<TimeCreated>65797,80971.737667</TimeCreated>

<Parameter name="NAMESPACE">
<Type>STRING</Type>
<Default>http://www.intersystems.com/PackageManager</Default>
</Parameter>

<Property name="Major">
<Type>%Integer</Type>
<Required>1</Required>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="Minor">
<Type>%Integer</Type>
<Required>1</Required>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="Patch">
<Type>%Integer</Type>
<Required>1</Required>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="Prerelease">
<Type>RegExString</Type>
<Parameter name="MAXLEN" value="100"/>
<Parameter name="REGEX" value="([0-9A-Za-z-])+(\.([0-9A-Za-z-])+)*"/>
</Property>

<Property name="Build">
<Type>RegExString</Type>
<Parameter name="MAXLEN" value="100"/>
<Parameter name="REGEX" value="([0-9A-Za-z-])+(\.([0-9A-Za-z-])+)*"/>
</Property>

<Method name="ToString">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..Major_"."_..Minor_"."_..Patch_$Case(..Prerelease,"":"",:"-"_..Prerelease)_$Case(..Build,"":"",:"+"_..Build)
]]></Implementation>
</Method>

<Method name="FromString">
<ClassMethod>1</ClassMethod>
<FormalSpec>pString:%String</FormalSpec>
<ReturnType>%ZPM.PackageManager.Core.SemanticVersion</ReturnType>
<Implementation><![CDATA[
	Set tVer = ..%New()
	Set tVer.Major = $Piece(pString,".",1)
	Set tVer.Minor = $Piece(pString,".",2)
	Set tVer.Patch = $Piece($Piece($Piece(pString,".",3),"-"),"+")
	Set tVer.Prerelease = $Piece($Piece($Piece(pString,".",3,*),"-",2,*),"+")
	Set tVer.Build = $Piece(pString,"+",2)
	Quit tVer
]]></Implementation>
</Method>

<Method name="FromListBuild">
<ClassMethod>1</ClassMethod>
<FormalSpec>pList:%List</FormalSpec>
<ReturnType>%ZPM.PackageManager.Core.SemanticVersion</ReturnType>
<Implementation><![CDATA[
	Set tVer = ..%New()
	Do tVer.%SetSerial(pList)
	Quit tVer
]]></Implementation>
</Method>

<Method name="IsValid">
<ClassMethod>1</ClassMethod>
<FormalSpec>pString:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tVer = ..FromString(pString)
	Quit tVer.%ValidateObject()
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%ValidateObject</METHOD> method to 
provide notification that the current object is being validated.

<P>If this method returns an error then <METHOD>%ValidateObject</METHOD> will fail.]]></Description>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If (..Major '= +..Major) {
		Quit $$$ERROR($$$GeneralError,$$$FormatText("Major version (%1) must be a positive integer without trailing zeros.",..Major))
	}
	If (..Minor '= +..Minor) {
		Quit $$$ERROR($$$GeneralError,$$$FormatText("Minor version (%1) must be a positive integer without trailing zeros.",..Minor))
	}
	If (..Patch '= +..Patch) {
		Quit $$$ERROR($$$GeneralError,$$$FormatText("Patch version (%1) must be a positive integer without trailing zeros.",..Patch))
	}
	Set tSC = $$$OK
	Set tPointer = 0
	Set tPreIdentifiers = $ListFromString(..Prerelease,".")
	While $ListNext(tPreIdentifiers,tPointer,tIdentifier) {
		If (+tIdentifier > 0) && (+tIdentifier '= tIdentifier) {
			Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Numeric identifier (%1) in version's prerelease (%2) cannot contain leading zeros.",tIdentifier,..Prerelease))
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="IsSnapshot">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit ($ZConvert(..Build,"L") = "snapshot")
]]></Implementation>
</Method>

<Method name="IsCompatibleWith">
<Description><![CDATA[
Returns 1 if this version's number indicates that it supports in <var>pVersion</var>.
That is, it has the same major and minor version as <var>pVersion</var>.]]></Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pVersion:%ZPM.PackageManager.Core.SemanticVersion</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[(pVersion.Major = ..Major) && (pVersion.Minor = ..Minor)
]]></Implementation>
</Method>

<Method name="IsBackwardCompatibleWith">
<Description><![CDATA[
Returns 1 if this version's number indicates that it will also support everything in <var>pVersion</var>.
That is, it has the same major and a later or equal minor version to <var>pVersion</var>.]]></Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pVersion:%ZPM.PackageManager.Core.SemanticVersion</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[(pVersion.Major = ..Major) && (pVersion.Minor <= ..Minor)
]]></Implementation>
</Method>

<Method name="Follows">
<Description><![CDATA[
Returns 1 if this version is a later version than <var>pVersion</var>.
TODO: Account for prerelease?]]></Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pVersion:%ZPM.PackageManager.Core.SemanticVersion</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
(..Major > pVersion.Major) ||
	((..Major = pVersion.Major) && (..Minor > pVersion.Minor)) ||
	((..Major = pVersion.Major) && (..Minor = pVersion.Minor) && (..Patch > pVersion.Patch))
]]></Implementation>
</Method>

<Method name="Satisfies">
<FormalSpec>pExpression:%ZPM.PackageManager.Core.SemanticVersionExpression</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit pExpression.IsSatisfiedBy($this)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>SemanticVersionState</State>
<StreamLocation>^ZPM.PackageManager9CFF.SemanticVerF1F5S</StreamLocation>
<Data name="SemanticVersionState">
<Value name="1">
<Value>Major</Value>
</Value>
<Value name="2">
<Value>Minor</Value>
</Value>
<Value name="3">
<Value>Patch</Value>
</Value>
<Value name="4">
<Value>Prerelease</Value>
</Value>
<Value name="5">
<Value>Build</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Core.SemanticVersionExpression">
<StorageStrategy/>
<Super>%SerialObject,%XML.Adaptor</Super>
<TimeCreated>65797,80971.7572</TimeCreated>

<Property name="Options">
<Type>%ZPM.PackageManager.Core.SemVer.Range</Type>
<Collection>list</Collection>
</Property>

<Property name="Expression">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Method name="%OnNew">
<FormalSpec>pRangeExpr:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set i%Expression = $Get(pRangeExpr)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ExpressionSet">
<FormalSpec>pValue:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tOptions = $ListFromString(pValue,"||")
		Set tPtr = 0
		While $ListNext(tOptions,tPtr,tRangeExpr) {
			Set tRangeExpr = $ZStrip(tRangeExpr,"<>W")
			Set tSC = ##class(%ZPM.PackageManager.Core.SemVer.Range).FromString(tRangeExpr,.tOption)
			If $$$ISERR(tSC) {
				Quit
			}
			Do ..Options.Insert(tOption)
		}
		Set i%Expression = pValue
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ToString">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..Expression
]]></Implementation>
</Method>

<Method name="ToResolvedString">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tOptList = ""
	For i=1:1:..Options.Count() {
		Set tOpt = ..Options.GetAt(i)
		Set tOptList = tOptList_$ListBuild(tOpt.ToResolvedString())
	}
	Quit $ListToString(tOptList," || ")
]]></Implementation>
</Method>

<Method name="FromString">
<ClassMethod>1</ClassMethod>
<FormalSpec>pString:%String,*pExpr:%ZPM.PackageManager.Core.SemanticVersionExpression</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pExpr = ..%New(pString)
		Set tOptions = $ListFromString(pString,"||")
		Set tPtr = 0
		While $ListNext(tOptions,tPtr,tRangeExpr) {
			Set tRangeExpr = $ZStrip(tRangeExpr,"<>W")
			Set tSC = ##class(%ZPM.PackageManager.Core.SemVer.Range).FromString(tRangeExpr,.tOption)
			If $$$ISERR(tSC) {
				Quit
			}
			Do pExpr.Options.Insert(tOption)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="IsSatisfiedBy">
<FormalSpec>pVersion:%ZPM.PackageManager.Core.SemanticVersion</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tSatisfied = (..Options.Count() = 0)
	For i=1:1:..Options.Count() {
		If ..Options.GetAt(i).InRange(pVersion) {
			Set tSatisfied = 1
			Quit
		}
	}
	Quit tSatisfied
]]></Implementation>
</Method>

<Method name="And">
<FormalSpec>pVersionExpression:%ZPM.PackageManager.Core.SemanticVersionExpression</FormalSpec>
<ReturnType>%ZPM.PackageManager.Core.SemanticVersionExpression</ReturnType>
<Implementation><![CDATA[
	For i=1:1:pVersionExpression.Options.Count() {
		Set tOption = pVersionExpression.Options.GetAt(i)
		If (..Options.Count() = 0) {
			Do ..Options.Insert(tOption)
		} Else {
			For j=1:1:..Options.Count() {
				For k=1:1:tOption.Comparators.Count() {
					Do ..Options.GetAt(j).Comparators.Insert(tOption.Comparators.GetAt(k))
				}
			}
		}
	}
	Set i%Expression = ..ToResolvedString()
	Quit $This
]]></Implementation>
</Method>

<Method name="Or">
<FormalSpec>pVersionExpression:%ZPM.PackageManager.Core.SemanticVersionExpression</FormalSpec>
<ReturnType>%ZPM.PackageManager.Core.SemanticVersionExpression</ReturnType>
<Implementation><![CDATA[
	For i=1:1:pVersionExpression.Options.Count() {
		Do ..Options.Insert(pVersionExpression.Options.GetAt(i))
	}
	Set i%Expression = ..ToResolvedString()
	Quit $This
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>SemanticVersionExpressionState</State>
<StreamLocation>^ZPM.PackageManager9CFF.SemanticVer1833S</StreamLocation>
<Data name="SemanticVersionExpressionState">
<Value name="1">
<Value>Expression</Value>
</Value>
<Value name="2">
<Value>Options</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Core.VersionedBase">
<Abstract>1</Abstract>
<Super>%ZPM.PackageManager.Core.ModuleInfo</Super>
<TimeCreated>65797,80971.747398</TimeCreated>

<Property name="Manifest">
<Type>%Stream.GlobalCharacterSearchable</Type>
<Parameter name="%JSONFIELDNAME" value="manifest"/>
<Parameter name="SIMILARITYINDEX" value="ManifestSearchIndex"/>
</Property>

<Property name="Installer">
<Type>%Stream.GlobalCharacterSearchable</Type>
<Parameter name="%JSONFIELDNAME" value="installer"/>
</Property>

<Property name="Payload">
<Type>%Stream.Object</Type>
</Property>

<Index name="ManifestSearchIndex">
<Description>
NOTE: Must be redeclared in subclasses (?)</Description>
<Data>Manifest(ELEMENTS)</Data>
<Properties>Manifest(KEYS)</Properties>
</Index>

<Method name="ManifestBuildValueArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pDocument:%Library.Binary,&pValueArray:%Library.Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tKeywords,tXSLT As %Stream.Object
	Set tSC = $$$OK
	Try {
		Set tDocument = $Select(pDocument="":"",1:$classmethod($classname(),"ManifestOpen",pDocument))
		If '$IsObject(tDocument) {
			Quit
		}
		Set tXData = ##class(%Dictionary.XDataDefinition).%OpenId("%ZPM.PackageManager.Core.VersionedBase||ManifestTransform",,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		Set tXSL = tXData.Data
		Set tSC = ##class(%XML.XSLT.Transformer).TransformStream(tDocument,tXSL,.tKeywords)
		If $$$ISERR(tSC) {
			Quit
		}
		Set tSC = ##class(%Text.English).BuildValueArray(tKeywords.Read($$$MaxStringLength),.pValueArray)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="CloneFrom">
<ClassMethod>1</ClassMethod>
<FormalSpec>pSource:%ZPM.PackageManager.Core.VersionedBase</FormalSpec>
<ReturnType>%ZPM.PackageManager.Core.VersionedBase</ReturnType>
<Implementation><![CDATA[
	Set tInst = ..%New()
	Set tInst.Name = pSource.Name
	Set tInst.Version = pSource.Version
	Set tInst.Manifest = pSource.Manifest.%ConstructClone()
	Set tInst.Payload = pSource.Payload.%ConstructClone()
	Quit tInst
]]></Implementation>
</Method>

<XData name="ManifestTransform">
<Data><![CDATA[
<xsl:stylesheet version="1.0"
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
 <xsl:output method="text"/>
 <xsl:preserve-space elements="*" />
 <xsl:template match="/">
 <xsl:value-of select="concat(Module/Name,' ')" />
 <xsl:value-of select="concat(Module/ExternalName,' ')" />
 <xsl:value-of select="concat(Module/Description,' ')" />
 <xsl:value-of select="concat(Module/Keywords,' ')" />
 <xsl:value-of select="concat(Module/Author/*,' ')"/>
 </xsl:template>
</xsl:stylesheet>
]]></Data>
</XData>
</Class>


<Class name="%ZPM.PackageManager.Developer.API.ErrorMessages">
<TimeCreated>65797,80972.028748</TimeCreated>

<Method name="GetMessageFile">
<Description><![CDATA[
<var>pDocName</var> is the full document name (including the .LOC extension) <br />
<var>pFileObject</var> is an instance of %ZPM.PackageManager.Developer.ErrorMessages.MsgFile corresponding to the document's content. <br />
@PrivateAPI]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDocName:%String,*pFileObject:%ZPM.PackageManager.Developer.ErrorMessages.MsgFile</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pFileObject = $$$NULLOREF
	Try {
		Set tRtn = ##class(%Library.RoutineMgr).%OpenId(pDocName)
		If (tRtn = $$$NULLOREF) {
			Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Error message document '%1' does not exist.",pDocName))
			Quit
		}
		
		Set tReader = ##class(%XML.Reader).%New()
		Do tReader.Correlate("MsgFile","%ZPM.PackageManager.Developer.ErrorMessages.MsgFile")
		$$$ThrowOnError(tReader.OpenStream(tRtn.Code))
		
		Do tReader.Next(.pFileObject,.tSC)
		$$$ThrowOnError(tSC)
	} Catch e {
		Set pFileObject = $$$NULLOREF
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="SaveMessageFile">
<Description><![CDATA[
<var>pDocName</var> is the full document name (including the .LOC extension) <br />
<var>pFileObject</var> is an instance of %ZPM.PackageManager.Developer.ErrorMessages.MsgFile corresponding to the document's content. <br />
If <var>pCompile</var> is set to 1 (by default, it is), then the file will be compiled after save. <br />
<var>pConsoleOutput</var> is an integer-subscripted array of lines of output from everything that happened. <br />
@PrivateAPI]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDocName:%String,pFileObject:%ZPM.PackageManager.Developer.ErrorMessages.MsgFile,pCompile:%Boolean=1,*pConsoleOutput</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tSC = ..Export(pDocName, pFileObject, .pConsoleOutput)
		If $$$ISERR(tSC) {
			Quit
		}
		
		If (pCompile) {
			Set tRtn = ##class(%Library.RoutineMgr).%OpenId(pDocName)
			If (tRtn = $$$NULLOREF) {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Error message document '%1' does not exist.",pDocName))
				Quit
			}
			Do ##class(%ZPM.PackageManager.Developer.Utils).BeginCaptureOutput(.tCookie)
			Set tSC = tRtn.Compile("ckvd")
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	If $Data(tCookie) {
		Do ##class(%ZPM.PackageManager.Developer.Utils).EndCaptureOutput(tCookie,.pConsoleOutput)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="Export">
<Description>
Utility method to export an error message document (with a given name).</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDocName:%String,pSource:%ZPM.PackageManager.Developer.ErrorMessages.MsgFile,*pSourceControlOutput</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		New %SourceControl
		
		Do ##class(%ZPM.PackageManager.Developer.Utils).BeginCaptureOutput(.tCookie)
		
		Do ##class(%Studio.SourceControl.Interface).SourceControlCreate()
		
		Set tSC = ##class(%Studio.SourceControl.Interface).GetStatus(pDocName,,.tIsEditable)
		If $$$ISERR(tSC) {
			Quit
		}
		
		If 'tIsEditable {
			Set tSC = $$$ERROR($$$ItemNotCheckedOut,tDocName)
			Quit
		}
		
		// Use document API
		#dim tExportStream As %Stream.Object
		Set tSC = pSource.XMLExportToStream(.tExportStream,,"literal,indent")
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tRtn = ##class(%Library.RoutineMgr).%OpenId(pDocName)
		If (tRtn = $$$NULLOREF) {
			Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Error message document '%1' does not exist.",pDocName))
			Quit
		}
		Do tRtn.Code.ImportFromXML(tExportStream)
		
		Set tSC = tRtn.%Save()
		If $$$ISERR(tSC) {
			Quit
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	
	// Ensure I/O redirection ends.
	Do ##class(%ZPM.PackageManager.Developer.Utils).EndCaptureOutput(tCookie,.pSourceControlOutput)
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.API">
<IncludeCode>%occInclude,%occErrors,%ZPM.PackageManager.Common</IncludeCode>
<TimeCreated>65797,80971.8371</TimeCreated>

<Method name="CreateModule">
<Description><![CDATA[
Converts <var>pObject</var> to a Module object and returns it by reference.
(The caller may then export it to XML, for example.)]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pObject:%ZEN.proxyObject,*pModule:%ZPM.PackageManager.Developer.Module</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tInitTLevel = $TLevel
	Try {
		Set pModule = ##class(%ZPM.PackageManager.Developer.Module).%New()
		Set tSC = ..ProxyToModule(pObject,pModule)
		$$$ThrowOnError(tSC)
		$$$ThrowOnError(pModule.%ValidateObject())
		TSTART
		Do ..CreateInstallerClass(pModule)
		Do ..CreateLifecycleClass(pModule)
		TCOMMIT
	} Catch e {
		Set tSC = e.AsStatus()
	}
	While ($TLevel > tInitTLevel) { TROLLBACK 1 }
	Quit tSC
]]></Implementation>
</Method>

<Method name="UpdateModule">
<Description><![CDATA[
Converts <var>pObject</var> to a Module object and saves it.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pModuleName:%String,pObject:%ZEN.proxyObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tInitTLevel = $TLevel
	Try {
		Set tModule = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(pModuleName,,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		Set tOldInstaller = tModule.InstallerClass
		Set tOldLifecycle = tModule.LifecycleClass
		TSTART
		Set tSC = ..ProxyToModule(pObject,tModule,1)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tSC = ..ExportDocumentForObject(tModule,.tOutput)
		If $$$ISERR(tSC) {
			Quit
		}
		
		// TODO: Something with tOutput
		
		Do ..CreateInstallerClass(tModule)
		Do ..CreateLifecycleClass(tModule)
		TCOMMIT
	} Catch e {
		Set tSC = e.AsStatus()
	}
	While ($TLevel > tInitTLevel) { TROLLBACK 1 }
	Quit tSC
]]></Implementation>
</Method>

<Method name="UpdateAPIDocumentation">
<Description>
@PrivateAPI</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pModuleName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tInitTLevel = $TLevel
	Try {
		Set tModule = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(pModuleName,,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		
		TSTART
		Set tSC = tModule.UpdateAPIDocumentation()
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tSC = ..ExportDocumentForObject(tModule,.tOutput)
		If $$$ISERR(tSC) {
			Quit
		}
		TCOMMIT
	} Catch e {
		Set tSC = e.AsStatus()
	}
	While ($TLevel > tInitTLevel) { TROLLBACK 1 }
	Quit tSC
]]></Implementation>
</Method>

<Method name="ExportDocumentForObject">
<ClassMethod>1</ClassMethod>
<FormalSpec>pSourceModule:%ZPM.PackageManager.Developer.Module,*pSourceControlOutput</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		New %SourceControl
		
		Do ##class(%ZPM.PackageManager.Developer.Utils).BeginCaptureOutput(.tCookie)
		
		Do ##class(%Studio.SourceControl.Interface).SourceControlCreate()
		
		Set tDocName = pSourceModule.Name_".ZPM"
		
		Set tSC = ##class(%Studio.SourceControl.Interface).GetStatus(tDocName,,.tIsEditable)
		If $$$ISERR(tSC) {
			Quit
		}
		
		If 'tIsEditable {
			Set tSC = $$$ERROR($$$ItemNotCheckedOut,tDocName)
			Quit
		}
		
		Set tModuleStream = ##class(%ZPM.PackageManager.Developer.Document.ModuleStream).NameOpen(pSourceModule.Name,,.tSC)
		If $ListFind($ListFromString($System.Status.GetErrorCodes(tSC)),$$$KeyValueNotFoundOpen) {
			// It's possible that only the module exists - we'll skip the merge with the document's content if it does.
			Set tSC = $$$OK
		}
		If $$$ISERR(tSC) {
			Quit
		}
		
		If $IsObject(tModuleStream) {
			// Extract comments from existing document stream
			Set tHandler = ##class(%ZPM.PackageManager.Developer.XML.CommentHandler).%New()
			Set tReader = ##class(%XML.SAX.Parser).%New()
			Set tSC = ##Class(%XML.SAX.Parser).ParseStream(tModuleStream.Contents,tHandler)
			$$$ThrowOnError(tSC)
		}
		
		// Use document API
		#dim tExportStream As %Stream.Object
		Set tSC = pSourceModule.XMLExportToStream(.tExportStream,,"literal,indent")
		If $$$ISERR(tSC) {
			Quit
		}
		
		If $IsObject(tModuleStream) {
			// Reapply comments to exported XML stream
			Set tSC = tHandler.Reapply(.tExportStream)
			$$$ThrowOnError(tSC)
		}
		
		// Save the document.
		Set tRtn = ##class(%Library.RoutineMgr).%OpenId(tDocName)
		If (tRtn = $$$NULLOREF) {
			Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Module %1 does not exist.",pModuleName))
			Quit
		}
		
		// NOTE: tRtn.Code is a %ZPM.PackageManager.Developer.Document.Module
		Do tRtn.Code.Code.Clear()
		Set tHeader = tExportStream.ReadLine()
		If ($Extract(tHeader,1,2) '= "<?") {
			Do tRtn.Code.Code.WriteLine("<?xml version=""1.0""?>")
		}
		Do tExportStream.Rewind()
		Set tSC = tRtn.Code.Code.CopyFrom(tExportStream)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tSC = tRtn.%Save()
		If $$$ISERR(tSC) {
			Quit
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	
	// Ensure I/O redirection ends.
	Do ##class(%ZPM.PackageManager.Developer.Utils).EndCaptureOutput(tCookie,.pSourceControlOutput)
	Quit tSC
]]></Implementation>
</Method>

<Method name="CreateInstallerClass">
<ClassMethod>1</ClassMethod>
<FormalSpec>pSource:%ZPM.PackageManager.Developer.Module</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	If (pSource.InstallerClass '= "") && '$$$defClassDefined(pSource.InstallerClass) && '$$$comClassDefined(pSource.InstallerClass) {
		// Create stub class
		Set tDef = ##class(%Dictionary.ClassDefinition).%New()
		Set tDef.Name = pSource.InstallerClass
		Set tDef.Super = "%ZPM.AbstractInstaller"
		Set tDef.ProcedureBlock = 1
		Do tDef.ProcedureBlockReset()
		$$$ThrowOnError(tDef.%Save())
		$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.ClassUtils).OverrideAbstractMembers(pSource.InstallerClass))
		
		// TODO: Add class to module (if not already covered by a package that's part of the module)
	}
]]></Implementation>
</Method>

<Method name="CreateLifecycleClass">
<ClassMethod>1</ClassMethod>
<FormalSpec>pSource:%ZPM.PackageManager.Developer.Module</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	If (pSource.LifecycleClass '= "") && '$$$defClassDefined(pSource.LifecycleClass) && '$$$comClassDefined(pSource.LifecycleClass) && '$$$comClassDefined($$$DefaultLifecyclePackageDot_pSource.LifecycleClass) {
		Set tDef = ##class(%Dictionary.ClassDefinition).%New()
		Set tDef.Name = pSource.LifecycleClass
		$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.Lifecycle.Base).GetBaseClassForPackaging(pSource.Packaging,.tBaseClass))
		Set tDef.Super = tBaseClass
		Set tDef.ProcedureBlock = 1
		Do tDef.ProcedureBlockReset()
		$$$ThrowOnError(tDef.%Save())
		$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.ClassUtils).OverrideAbstractMembers(pSource.LifecycleClass))
		
		// TODO: Add class to module as a "preload" resource
	}
]]></Implementation>
</Method>

<Method name="ProxyToModule">
<ClassMethod>1</ClassMethod>
<FormalSpec>pObject:%ZEN.proxyObject,pModule:%ZPM.PackageManager.Developer.Module,pSave:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pModule.Name = pObject.ModuleName
		For tModuleProp = "GlobalScope","VersionString","ExternalName","Description","LifecycleClass","InstallerClass","Packaging","Keywords" {
			Set $Property(pModule,tModuleProp) = $Property(pObject,tModuleProp)
		}
		For tAuthorProp = "Person","Organization","CopyrightDate","License","Notes" {
			Set $Property(pModule.Author,tAuthorProp) = $Property(pObject.Author,tAuthorProp)
		}
		
		// Dependencies
		// Build maps of name -> index in pObject.Dependencies, bidirectionally for pModule.Dependencies
		Kill tSrcMap,tDestMap
		If (pObject.dependencyObj && pObject.dependencyObj.children) {
			For i=1:1:pObject.dependencyObj.children.Count() {
				Set tDep = pObject.dependencyObj.children.GetAt(i)
				If ('tDep.isDelete) && (tDep.ModuleName '= "") {
					Set tSrcMap(tDep.ModuleName,$Case(tDep.Scope,"":$c(0),:tDep.Scope)) = i
				}
			}
		}
		For i=1:1:pModule.Dependencies.Count() {
			Set tDep = pModule.Dependencies.GetAt(i)
			Set tDestMap(0,i) = $lb(tDep.Name,tDep.Scope)
			Set tDestMap(1,tDep.Name,$Case(tDep.Scope,"":$c(0),:tDep.Scope)) = i
		}
		
		// Create/update based on pObject.Dependencies
		Set tNameKey = ""
		For {
			Set tNameKey = $Order(tSrcMap(tNameKey))
			Quit:(tNameKey="")
			
			Set tScopeKey = ""
			For {
				Set tScopeKey = $Order(tSrcMap(tNameKey,tScopeKey),1,tSrcIdx)
				Quit:(tScopeKey="")
				
				Set tSrc = pObject.dependencyObj.children.GetAt(tSrcIdx)
				
				If $Data(tDestMap(1,tNameKey,tScopeKey),tDestIdx) {
					// Update
					Set tDep = pModule.Dependencies.GetAt(tDestIdx)
					
					// Remove from tDestMap
					Kill tDestMap(0,tDestIdx)
					Kill tDestMap(1,tNameKey,tScopeKey)
				} Else {
					// Create
					Set tDep = ##class(%ZPM.PackageManager.Core.ModuleReference).%New()
					Set tDep.Name = tNameKey
					Do pModule.Dependencies.Insert(tDep)
				}
				
				Set tDep.VersionString = tSrc.Version
				Set tDep.Scope = tSrc.Scope
			}
		}
		
		// Remove remaining items in tDestMap(0) in reverse order
		Set tDeleteKey = ""
		For {
			Set tDeleteKey = $Order(tDestMap(0,tDeleteKey),-1)
			Quit:(tDeleteKey="")
			
			Do pModule.Dependencies.RemoveAt(tDeleteKey)
		}
		
		// References
		// Build maps of name -> index in pObject.Resources, bidirectionally for pModule.Resources
		Kill tSrcMap,tDestMap
		If (pObject.resourceObj && pObject.resourceObj.children) {
			For i=1:1:pObject.resourceObj.children.Count() {
				Set tRes = pObject.resourceObj.children.GetAt(i)
				If ('tRes.isDelete) && (tRes.Name '= "") {
					Set tSrcMap(tRes.Name) = i
				}
			}
		}
		Set tResKey = ""
		For {
			Set tRes = pModule.Resources.GetNext(.tResKey)
			Quit:(tResKey="")
			Set tDestMap(0,tResKey) = tRes.Name
			Set tDestMap(1,tRes.Name) = tResKey
		}
		
		// Create/update based on pObject.Resources
		Set tNameKey = ""
		For {
			Set tNameKey = $Order(tSrcMap(tNameKey),1,tSrcIdx)
			Quit:(tNameKey="")
			
			Set tSrc = pObject.resourceObj.children.GetAt(tSrcIdx)
			
			If $Data(tDestMap(1,tNameKey),tDestIdx) {
				// Update
				Set tRes = pModule.Resources.GetAt(tDestIdx)
				
				// Remove from tDestMap
				Kill tDestMap(0,tDestIdx)
				Kill tDestMap(1,tNameKey)
			} Else {
				// Create
				Set tRes = ##class(%ZPM.PackageManager.Developer.ResourceReference).%New()
				Set tRes.Name = tNameKey
				Do pModule.Resources.Insert(tRes)
			}
			
			// TODO: Generated (Not yet supported in UI.)
			Set tRes.Preload = tSrc.Preload
			Set tRes.Scope = tSrc.Scope
			Set tRes.ProcessorClass = tSrc.ProcessorClass
			
			// Clone of the resource for comparison to default values.
			Set tResClone = ##class(%ZPM.PackageManager.Developer.ResourceReference).%New()
			Set tResClone.Name = tRes.Name
			Set tResClone.Scope = tRes.Scope
			Set tResClone.Preload = tRes.Preload
			Set tResClone.ProcessorClass = tRes.ProcessorClass
			Set tResClone.Module = tRes.Module
			
			Kill tAttrMap
			If $IsObject(tResClone.Processor) && $IsObject(tSrc.ProcessorClassAttributes) && tSrc.ProcessorClassAttributes.%IsA("%Collection.AbstractList") {
				For i=1:1:tSrc.ProcessorClassAttributes.Count() {
					Set tSrcAttr = tSrc.ProcessorClassAttributes.GetAt(i)
					Set tMethod = tSrcAttr.Name_"XSDToLogical"
					Set tValue = $Select(
						$System.CLS.IsMthd(tResClone.Processor,tMethod):$Method(tResClone.Processor,tMethod,tSrcAttr.Value),
						1:tSrcAttr.Value)
					If (tValue = $Property(tResClone.Processor,tSrcAttr.Name)) {
						// If the logical value matches the default value for the resource processor, omit it from the module XML.
						Do tRes.Attributes.RemoveAt(tSrcAttr.Name)
					} Else {
						Do tRes.Attributes.SetAt(tSrcAttr.Value,tSrcAttr.Name)
					}
				}
			}
			
			// Just to be safe...
			Set tResClone.Module = $$$NULLOREF
			
			If (pSave) {
				// Shallow save just this resource. (Seems to not happen otherwise sometimes... ?)
				Set tSC = tRes.%Save(0)
			}
			If $$$ISERR(tSC) {
				Quit
			}
		}
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Remove remaining items in tDestMap(0) in reverse order
		Set tDeleteKey = ""
		For {
			Set tDeleteKey = $Order(tDestMap(0,tDeleteKey),-1)
			Quit:(tDeleteKey="")
			
			Do pModule.Resources.RemoveAt(tDeleteKey)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetModuleProperties">
<ClassMethod>1</ClassMethod>
<FormalSpec>pModuleName:%String,*pObject:%ZEN.proxyObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tSC = $$$OK
		Set pObject = ##class(%ZEN.proxyObject).%New()
		Set pObject.error = ""
		Set tModuleName = $Piece(pModuleName,".ZPM",1)
		If tModuleName = "" {
			Set tModuleObj = ##class(%ZPM.PackageManager.Developer.Module).%New()
		} Else {
			Set tModuleObj = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(tModuleName,,.tSC)
			$$$ThrowOnError(tSC)
		}
		Set pObject.Name = tModuleObj.Name
		Set pObject.GlobalScope = tModuleObj.GlobalScope
		Set pObject.VersionString = tModuleObj.VersionString
		Set pObject.ExternalName = tModuleObj.ExternalName
		Set pObject.Description = tModuleObj.Description
		Set pObject.Keywords = tModuleObj.Keywords
		Set pObject.Packaging = tModuleObj.Packaging
		Set pObject.GlobalScope = tModuleObj.GlobalScope
		Set tSystemLifecycleClass = $Piece(tModuleObj.LifecycleClass,$$$DefaultLifecyclePackageDot,2,*)
		Set pObject.LifecycleClass = $Case(tSystemLifecycleClass,"":tModuleObj.LifecycleClass,:tSystemLifecycleClass)
		Set pObject.InstallerClass = tModuleObj.InstallerClass
		Set tAuthor = ##class(%ZEN.proxyObject).%New()
		Set tAuthor.Person = tModuleObj.Author.Person
		Set tAuthor.Organization = tModuleObj.Author.Organization
		Set tAuthor.CopyrightDate = tModuleObj.Author.CopyrightDate
		Set tAuthor.License = tModuleObj.Author.License
		Set tAuthor.Notes = tModuleObj.Author.Notes
		Set pObject.Author = tAuthor		
	} Catch ex {
		Set tSC = ex.AsStatus()
		Set pObject.error = tSC
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetPackagingListSQL">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pSQL:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pSQL = "select Packaging,BaseClass from %ZPM_PackageManager_Developer_Lifecycle.Base_Packaging()"
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetLifecycleClassListSQL">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pSQL:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pSQL = "select SUBSTRING(cd.Name,"_(1+$Length($$$DefaultLifecyclePackageDot))_") Name from "_
		"%Dictionary.ClassDefinition_SubclassOf('%ZPM.PackageManager.Developer.Lifecycle.Abstract') subs "_
		"join %Dictionary.CompiledClass cd on subs.Name = cd.Name "_
		"where cd.Abstract = 0 and cd.Name %STARTSWITH '"_$$$DefaultLifecyclePackageDot_"' "_
		"union "_
		"select cd.Name from "_
		"%Dictionary.ClassDefinition_SubclassOf('%ZPM.PackageManager.Developer.Lifecycle.Abstract') subs "_
		"join %Dictionary.CompiledClass cd on subs.Name = cd.Name "_
		"where cd.Abstract = 0 and not cd.Name %STARTSWITH '"_$$$DefaultLifecyclePackageDot_"'"
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetInstallerClassListSQL">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pSQL:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pSQL = "select cd.Name from "_
		"%Dictionary.ClassDefinition_SubclassOf('%ZPM.AbstractInstaller') subs "_
		"join %Dictionary.CompiledClass cd on subs.Name = cd.Name "_
		"where cd.Abstract = 0"
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetProcessorClassListSQL">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pSQL:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pSQL = "select SUBSTRING(cd.Name,"_(1+$Length($$$DefaultProcessorPackageDot))_") Name, "_
			"%ZPM_PackageManager_Developer_Processor.Abstract_GetDescription(cd.Name) Description from "_
		"%Dictionary.ClassDefinition_SubclassOf('%ZPM.PackageManager.Developer.Processor.Abstract') subs "_
		"join %Dictionary.CompiledClass cd on subs.Name = cd.Name "_
		"where cd.Abstract = 0 and cd.Name %STARTSWITH '"_$$$DefaultProcessorPackageDot_"' "_
		"union "_
		"select cd.Name,%ZPM_PackageManager_Developer_Processor.Abstract_GetDescription(cd.Name) Description from "_
		"%Dictionary.ClassDefinition_SubclassOf('%ZPM.PackageManager.Developer.Processor.Abstract') subs "_
		"join %Dictionary.CompiledClass cd on subs.Name = cd.Name "_
		"where cd.Abstract = 0 and not cd.Name %STARTSWITH '"_$$$DefaultProcessorPackageDot_"'"
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="ListProcessorAttributes">
<Type>%Query</Type>
<FormalSpec>pProcessorClass:%String</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Name:%String,Type:%String,Description:%String,Default:%String,Required:%Boolean,VALUELIST:%String,DISPLAYLIST:%String,MINLEN:%String,MAXLEN:%String,MINVAL:%Integer,MAXVAL:%Integer"/>
</Query>

<Method name="ListProcessorAttributesExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,pProcessorClass:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set qHandle("pointer") = ""
		Set tSuper = "%ZPM.PackageManager.Developer.Processor.Abstract"
		If '$$$comClassDefined(pProcessorClass) && $$$comClassDefined($$$DefaultProcessorPackageDot_pProcessorClass) {
			Set pProcessorClass = $$$DefaultProcessorPackageDot_pProcessorClass
		}
		If '$ClassMethod(pProcessorClass,"%Extends",tSuper) {
			Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Class '%1' does not extend '%2'"),pProcessorClass,tSuper)
			Quit
		}
		Set tSC = $ClassMethod(pProcessorClass,"GetAttributeMetadata",.tMetadata)
		If $$$ISERR(tSC) {
			Quit
		}
		Merge qHandle("data") = tMetadata
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ListProcessorAttributesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>ListAttributesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set qHandle("pointer") = $Order(qHandle("data",qHandle("pointer")),1,Row)
	If (qHandle("pointer") = "") {
		Set AtEnd = 1
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ListProcessorAttributesClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>ListAttributesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetInstalledModuleListSQL">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pSQL:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pSQL = "select Name from %ZPM_PackageManager_Developer.""Module"""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetModuleListSQL">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pSQL:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tSC = $$$OK
		Set pSQL = "select * from %ZPM_PackageManager_Developer.API_GetAvailableModuleNames()"

	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetDependencySQL">
<ClassMethod>1</ClassMethod>
<FormalSpec>pModuleName:%String,*pSQL:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pSQL = ""
	Set tSC = $$$OK
	Try {
		Set tModuleName = $Piece(pModuleName,".ZPM",1)
		If tModuleName '= "" {
			Set tWhere = "where ""Module""->Name="_##class(%ZEN.Auxiliary.QueryInfo).QuoteSQL(tModuleName)
			Set pSQL = "select Dependencies_Name as ModuleName, Dependencies_VersionString as Version, Dependencies_Scope as Scope from %ZPM_PackageManager_Developer.Module_Dependencies "_tWhere
			Quit
		}
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetResourceSQL">
<ClassMethod>1</ClassMethod>
<FormalSpec>pModuleName:%String,*pSQL:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pSQL = ""
	Set tSC = $$$OK
	Try {
		Set tModuleName = $Piece(pModuleName,".ZPM",1)
		If tModuleName '= "" {
			Set tWhere = "where ""Module""->Name="_##class(%ZEN.Auxiliary.QueryInfo).QuoteSQL(tModuleName)
			Set pSQL = "select Name,Preload,Scope,Deploy, "_
				"case when ProcessorClass %STARTSWITH '"_$$$DefaultProcessorPackageDot_"' "_
				"then SUBSTRING(ProcessorClass,"_(1+$Length($$$DefaultProcessorPackageDot))_") "_
				"else ProcessorClass end ProcessorClass "_
				"from %ZPM_PackageManager_Developer.ResourceReference "_
				tWhere
		}
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetResourceAttributeSQL">
<ClassMethod>1</ClassMethod>
<FormalSpec>pModuleName:%String,*pSQL:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pSQL = ""
	Set tSC = $$$OK
	Try {
		Set tModuleName = $Piece(pModuleName,".ZPM",1)
		If tModuleName '= "" {
			Set tWhere = "where ResourceReference->""Module""->Name="_##class(%ZEN.Auxiliary.QueryInfo).QuoteSQL(tModuleName)
			Set pSQL = "select ResourceReference->Name ResourceReference,element_key Name,Attributes Value from %ZPM_PackageManager_Developer.ResourceReference_Attributes " _ tWhere
		}
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetAPISQL">
<ClassMethod>1</ClassMethod>
<FormalSpec>pModuleName:%String,*pSQL:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pSQL = ""
	Set tSC = $$$OK
	Try {
		Set tModuleName = $Piece(pModuleName,".ZPM",1)
		If tModuleName '= "" {
			Set tWhere = "where ""Module""->Name="_##class(%ZEN.Auxiliary.QueryInfo).QuoteSQL(tModuleName)
			Set pSQL = "select API_Name,API_Type,API_SubType,API_Public from %ZPM_PackageManager_Developer.Module_API " _ tWhere
		}
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetServerListSQL">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pSQL:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pSQL = ""
	Set tSC = $$$OK
	Try {
		Set pSQL = "select Name from %ZPM_PackageManager_Client.ServerDefinition"
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetServerDefinitionList">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pObject:%ZEN.proxyObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pObject = ##class(%ZEN.proxyObject).%New()
	Set pObject.children = ##class(%ListOfObjects).%New()
	Set tSC = $$$OK
	Try {
		Set tRS = ##class(%ResultSet).%New()
		Set tRS.ClassName = "%Dictionary.ClassDefinition"
		Set tRS.QueryName = "SubclassOf"
		Set tSC = tRS.Execute("%ZPM.PackageManager.Client.ServerDefinition")
     	If $$$ISERR(tSC) {
	     	Quit	
     	}
     	While tRS.Next() {
	     	Set tClassObj = ##class(%ZEN.proxyObject).%New()
	     	Set tClassObj.ClassName = tRS.Data("Name")
    		Set tClassObj.DisplayName = $parameter(tRS.Data("Name"),"DISPLAYNAME")
    		Do pObject.children.Insert(tClassObj)
     	}
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetRepositorySQL">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pSQL:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pSQL = ""
	Set tSC = $$$OK
	Try {
		Set pSQL = "select * from %ZPM_PackageManager_Client.ServerDefinition order by ID"
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetInstallerMedaData">
<Description>
This method should return JSON metadata for the installer</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pParameter:%String,*pObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tSC = $$$OK
		Set pObject = {
		"products":[
		{	"id":25425,
			"family":"HealthShare",
			"product":"Patient Index",
			"majorVersion":19,
			"minorVersion":0,
			"patchVersion":0,
			"date":"2016-06-11",
			"notes":"This version of Patient Index features adiabatic tuning and fresnel searching!",
			"releaseNotes":"assets/release-notes.pdf",
			"image":"packagemanager/images/patient-index.jpg"
		},
		{	"id":23423,
			"family":"HealthShare",
			"product":"Provider Directory",
			"majorVersion":16,
			"minorVersion":0,
			"patchVersion":0,
			"date":"2016-07-11",
			"notes":"As featured on TV.",
			"releaseNotes":"assets/release-notes.pdf",
			"image":"packagemanager/images/provider-directory.jpg"
		},
		{	"id":23403,
			"family":"HealthShare",
			"product":"Personal Community",
			"majorVersion":15,
			"minorVersion":0,
			"patchVersion":0,
			"date":"2015-04-11",
			"releaseNotes":"assets/release-notes.pdf",
			"image":"packagemanager/images/personal-community.jpg"
		},
		{	"id":23423,
			"family":"HealthShare",
			"product":"Personal Community",
			"majorVersion":16,
			"minorVersion":0,
			"patchVersion":0,
			"date":"2016-04-11",
			"releaseNotes":"assets/release-notes.pdf",
			"image":"packagemanager/images/personal-community.jpg"
		},
		{	"id":23423,
			"family":"HealthShare",
			"product":"Personal Community",
			"majorVersion":17,
			"minorVersion":0,
			"patchVersion":0,
			"label":"beta",
			"date":"2016-08-17",
			"releaseNotes":"assets/release-notes.pdf",
			"image":"packagemanager/images/personal-community.jpg"
		},
		{	"id":34987,
			"family":"HealthShare",
			"product":"Information Exchange",
			"majorVersion":15,
			"minorVersion":0,
			"patchVersion":0,
			"date":"2016-08-02",
			"releaseNotes":"assets/release-notes.pdf",
			"image":"packagemanager/images/information-exchange.jpg"
		},
		{	"id":32287,
			"family":"HealthShare",
			"product":"Health Insight",
			"majorVersion":15,
			"minorVersion":0,
			"patchVersion":0,
			"date":"2016-08-02",
			"releaseNotes":"assets/release-notes.pdf",
			"image":"packagemanager/images/health-insight.jpg"
		},
		{	"id":32247,
			"family":"HealthShare",
			"product":"App Server",
			"majorVersion":11,
			"minorVersion":0,
			"patchVersion":0,
			"date":"2016-08-02",
			"releaseNotes":"assets/release-notes.pdf",
			"image":"packagemanager/images/app-server.jpg"
		},
		{	"id":26247,
			"family":"HealthShare",
			"product":"Health Connect",
			"majorVersion":13,
			"minorVersion":0,
			"patchVersion":0,
			"date":"2016-08-02",
			"releaseNotes":"assets/release-notes.pdf",
			"image":"packagemanager/images/health-connect.jpg"
		}
	],

	"productFilters":[
		{"text":"All Products", "value":""},
		{"text":"App Server", "value":"App Server"},
		{"text":"Health Connect", "value":"Health Connect"},
		{"text":"Health Insight", "value":"Health Insight"},
		{"text":"Information Exchange", "value":"Information Exchange"},
		{"text":"Personal Community", "value":"Personal Community"},
		{"text":"Patient Index", "value":"Patient Index"},
		{"text":"Provider Directory", "value":"Provider Directory"}
	],

	"versionFilters":[
		{"text":"All Versions", "value":""},
		{"text":"Latest Release", "value":"latest"},
		{"text":"Beta Releases", "value":"beta"}
	],

	"servers":[
		{"name":"HSINSTANCE1",
			"family":"InterSystems","product":"Platform","majorVersion":2016,"minorVersion":1,"patchVersion":3,
			"namespaces":[
				{"name":"", "isNew":true },
				{"name":"HSHC12", "family":"HealthShare","product":"Health Connect","majorVersion":12,"minorVersion":3,"patchVersion":14 },
				{"name":"HSPI19", "family":"HealthShare","product":"Patient Index","majorVersion":19,"minorVersion":1,"patchVersion":1 },
				{"name":"HSHI12", "family":"HealthShare","product":"Health Insight","majorVersion":14,"minorVersion":1,"patchVersion":1,"label":"beta-3" },
				{"name":"HSPD14", "family":"HealthShare","product":"Provider Directory","majorVersion":14,"minorVersion":9,"patchVersion":5 },
				{"name":"HSPD16", "family":"HealthShare","product":"Provider Directory","majorVersion":16,"minorVersion":0,"patchVersion":1 },
				{"name":"HSPD20", "family":"HealthShare","product":"Provider Directory","majorVersion":20,"minorVersion":1,"patchVersion":1 }
			]
		},
		{"name":"HSPORTAL",
			"family":"InterSystems","product":"Platform","majorVersion":2016,"minorVersion":2,"patchVersion":0,
			"namespaces":[
				{"name":"", "isNew":true },
				{"name":"HSPC15", "family":"HealthShare","product":"Personal Community","majorVersion":15,"minorVersion":1,"patchVersion":2  },
				{"name":"TEST" }
			]
		}
	]
	}
	Set pObject = pObject.%ToJSON()
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Query name="GetAvailableModuleNames">
<Type>%Query</Type>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Name:%String"/>
</Query>

<Method name="GetAvailableModuleNamesExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tSearchCriteria = ##class(%ZPM.PackageManager.Core.SearchCriteria).%New()
		Set tSC = ##class(%ZPM.PackageManager.Client.Utils).SearchRepositoriesForModule(tSearchCriteria,.tResults)
		If $$$ISERR(tSC) {
			Quit
		}
		
		For i=1:1:tResults.Count() {
			#dim tRef As %ZPM.PackageManager.Core.QualifiedModuleReference = tResults.GetAt(i)
			Set qHandle(tRef.Name) = ""
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetAvailableModuleNamesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>GetAvailableModuleNamesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set qHandle = $Order(qHandle($Get(qHandle)))
	If (qHandle = "") {
		Set AtEnd = 1
	} Else {
		Set Row = $ListBuild(qHandle)
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetAvailableModuleNamesClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>GetAvailableModuleNamesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Query name="GetAvailableModuleVersions">
<Type>%Query</Type>
<FormalSpec>pName:%String</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Version:%String,ServerKey:%String"/>
</Query>

<Method name="GetAvailableModuleVersionsExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,pName:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If ($Get(pName) '= "") {
		
			Set tSearchCriteria = ##class(%ZPM.PackageManager.Core.SearchCriteria).%New()
			Set tSearchCriteria.Name = pName
			Set tSC = ##class(%ZPM.PackageManager.Client.Utils).SearchRepositoriesForModule(tSearchCriteria,.tResults)
			If $$$ISERR(tSC) {
				Quit
			}
			
			For i=1:1:tResults.Count() {
				#dim tRef As %ZPM.PackageManager.Core.QualifiedModuleReference = tResults.GetAt(i)
				Set qHandle(i) = $ListBuild(tRef.VersionString,tRef.ServerName)
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetAvailableModuleVersionsFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>GetAvailableModuleVersionsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set qHandle = $Order(qHandle($Get(qHandle)),1,tRow)
	If (qHandle = "") {
		Set AtEnd = 1
	} Else {
		Set Row = tRow
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetAvailableModuleVersionsClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>GetAvailableModuleVersionsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.APIDocumentation">
<Super>%SerialObject,%XML.Adaptor</Super>
<TimeCreated>65797,80971.826292</TimeCreated>

<Parameter name="NAMESPACE">
<Type>STRING</Type>
<Default>http://www.intersystems.com/PackageManager</Default>
</Parameter>

<Property name="Type">
<Type>%String</Type>
<Parameter name="VALUELIST" value=",class,routine,include,other"/>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="SubType">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="Name">
<Type>%String</Type>
<Parameter name="MAXLEN" value="500"/>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="Public">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>APIDocumentationState</State>
<StreamLocation>^ZPM.PackageManager.APIDocumentS</StreamLocation>
<Data name="APIDocumentationState">
<Value name="1">
<Value>Type</Value>
</Value>
<Value name="2">
<Value>SubType</Value>
</Value>
<Value name="3">
<Value>Name</Value>
</Value>
<Value name="4">
<Value>Public</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Developer.Annotation.Utils">
<TimeCreated>65797,80972.060082</TimeCreated>

<Method name="ExtractAnnotations">
<Description>
@PublicAPI</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName:%String,pAnnotations:%Library.ListOfObjects(ELEMENTTYPE="%ZPM.PackageManager.Developer.Annotation")</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		If '$IsObject($Get(pAnnotations)) {
			Set pAnnotations = ##class(%Library.ListOfObjects).%New()
		}
		
		Set tTemplate = ##class(%ZPM.PackageManager.Developer.Annotation).%New()
		Set tTemplate.Classname = pClassName
		Set tStatus = ..ParseAnnotations($$$comClassKeyGet(pClassName,$$$cCLASSdescription),pAnnotations,tTemplate)
		If $$$ISERR(tStatus) {
			Quit
		}
		
		Set tSources = $ListBuild(
			$ListBuild($$$cCLASSfkey,$$$cFKEYdescription,"ForeignKey"),
			$ListBuild($$$cCLASSindex,$$$cINDEXdescription,"Index"),
			$ListBuild($$$cCLASSmethod,$$$cMETHdescription,"Method"),
			$ListBuild($$$cCLASSparameter,$$$cPARAMdescription,"Parameter"),
			$ListBuild($$$cCLASSprojection,$$$cPROJdescription,"Projection"),
			$ListBuild($$$cCLASSproperty,$$$cPROPdescription,"Property"),
			$ListBuild($$$cCLASSquery,$$$cQUERYdescription,"Query"),
			$ListBuild($$$cCLASSstorage,$$$cSDEFdescription,"Storage"),
			$ListBuild($$$cCLASStrigger,$$$cTRIGGERdescription,"Trigger"),
			$ListBuild($$$cCLASSxdata,$$$cXDATAdescription,"XData")
		)
		Set tPtr = 0
		While $ListNext(tSources,tPtr,tSource) {
			Set $ListBuild(tMemberType,tDescKey,tTypeDesc) = tSource
			Set tMember = ""
			For {
				Set tMember = $$$comMemberNext(pClassName,tMemberType,tMember)
				Quit:tMember=""
				
				Set tTemplate.MemberType = tTypeDesc
				Set tTemplate.MemberName = tMember
				Set tStatus = ..ParseAnnotations($$$comMemberKeyGet(pClassName,tMemberType,tMember,tDescKey),pAnnotations,tTemplate)
				If $$$ISERR(tStatus) {
					Quit
				}
			}
			If $$$ISERR(tStatus) {
				Quit
			}
		}
	} Catch e {
		Set tStatus = e.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="ParseAnnotations">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDescription:%String,pAnnotations:%Library.ListOfObjects(ELEMENTTYPE="%ZPM.PackageManager.Developer.Annotation"),pTemplate:%ZPM.PackageManager.Developer.Annotation</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		Set tParts = $ListFromString(pDescription,$$$NL)
		Set tPtr = 0
		While $ListNext(tParts,tPtr,tPart) {
			If ($Extract(tPart) = "@") {
				Set tPart = $Extract(tPart,2,*)
				Set tTag = $Piece(tPart,"(""")
				If (tTag '= "") {
					Set tAnnotation = pTemplate.%ConstructClone()
					Set tAnnotation.Tag = tTag
					Set tAnnotation.Value = $Piece($Piece(tPart,"(""",2),""")")
					Set tStatus = pAnnotations.Insert(tAnnotation)
					If $$$ISERR(tStatus) {
						Quit
					}
				}
			}
		}
	} Catch e {
		Set tStatus = e.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Annotation">
<Super>%SerialObject</Super>
<TimeCreated>65797,80971.829815</TimeCreated>

<Property name="Classname">
<Type>%Dictionary.CacheClassname</Type>
<Required>1</Required>
</Property>

<Property name="MemberType">
<Type>%String</Type>
<Parameter name="VALUELIST" value=",ForeignKey,Index,Method,Parameter,Projection,Property,Query,Storage,Trigger,XData"/>
</Property>

<Property name="MemberName">
<Type>%Dictionary.CacheIdentifier</Type>
</Property>

<Property name="Tag">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="50"/>
</Property>

<Property name="Value">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>AnnotationState</State>
<StreamLocation>^ZPM.PackageManager.Deve78FE.AnnotationS</StreamLocation>
<Data name="AnnotationState">
<Value name="1">
<Value>Classname</Value>
</Value>
<Value name="2">
<Value>MemberType</Value>
</Value>
<Value name="3">
<Value>MemberName</Value>
</Value>
<Value name="4">
<Value>Tag</Value>
</Value>
<Value name="5">
<Value>Value</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Developer.Archive">
<Super>%ZPM.PackageManager.Developer.IConfigurable</Super>
<TimeCreated>65797,80971.818411</TimeCreated>

<Method name="Create">
<Description><![CDATA[
Creates an archive with the contents of <var>pSourceDirectory</var> in <var>pArchiveFileName</var>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pSourceDirectory:%String,pArchiveFileName:%String,*pOutput</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pOutput
		Set pOutput = 0
		
		If ($Get(pSourceDirectory) = "") {
			Set tSC = $$$ERROR($$$GeneralError,"Source directory not specified.")
			Quit
		}
		If ($Get(pArchiveFileName) = "") {
			Set tSC = $$$ERROR($$$GeneralError,"Archive filename not specified.")
			Quit
		}
		If '##class(%File).DirectoryExists(pSourceDirectory) {
			Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Directory %1 does not exist",pArchiveFileName))
			Quit
		}
		Set pSourceDirectory = ##class(%File).NormalizeFilenameWithSpaces(##class(%File).NormalizeDirectory(pSourceDirectory))
		Set pArchiveFileName = ##class(%File).NormalizeFilenameWithSpaces(pArchiveFileName)

		set archive = ##class(%ZPM.Utils.FileBinaryTar).Compact(pSourceDirectory, 1, pArchiveFileName, pSourceDirectory)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="Extract">
<Description><![CDATA[
Extracts the contents of <var>pArchiveFileName</var> into <var>pTargetDirectory</var>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pArchiveFileName:%String,pTargetDirectory:%String,*pOutput</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pOutput
		Set pOutput = 0
		If ($Get(pArchiveFileName) = "") {
			Set tSC = $$$ERROR($$$GeneralError,"Archive filename not specified.")
			Quit
		}
		If ($Get(pTargetDirectory) = "") {
			Set tSC = $$$ERROR($$$GeneralError,"Target directory not specified.")
			Quit
		}
		If '##class(%File).DirectoryExists(pTargetDirectory) {
			Set tResult = ##class(%File).CreateDirectoryChain(pTargetDirectory,.tReturn)
			If 'tResult {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Error creating directory chain %1: %2",pTargetDirectory,tReturn))
				Quit
			}
		}
		If $ISOBJECT(pArchiveFileName),pArchiveFileName.%IsA("%Stream.Object") {
			Set tStream = ##class(%Stream.FileBinary).%New()
			Set tStream.Filename = ##class(%File).TempFilename("tgz")
			Do tStream.CopyFromAndSave(pArchiveFileName)
			Set tStream2 = ##class(%Stream.FileBinaryGzip).%New()
			Set tStream2.Filename = tStream.Filename
			Set extracted = ##class(%ZPM.Utils.FileBinaryTar).ExtractStream(tStream2, pTargetDirectory)
		} Else {
			Set extracted = ##class(%ZPM.Utils.FileBinaryTar).ExtractFile(pArchiveFileName, 1, pTargetDirectory)			
		}
		
		//set tSC = extracted.ExtractTo(pTargetDirectory)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Build">
<TimeCreated>65797,80971.873155</TimeCreated>

<Method name="InitializeBuildNamespace">
<Description>
@PrivateAPI</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pVerbose:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..InitializeNamespace("BUILD", pVerbose)
]]></Implementation>
</Method>

<Method name="InitializeNamespace">
<Description>
@PrivateAPI</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPostfix:%String,pVerbose:%Boolean=1,*pNewNamespace</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// TODO: Support custom mappings and additional databases.
	Set tSC = $$$OK
	Set pNewNamespace = ""
	Try {
		Set tInitNS = $Select($Namespace="%SYS": "USER", 1: $Namespace)
		Set pNewNamespace = tInitNS_"-"_pPostfix
		Set tBuildDBName = pNewNamespace_"-CODE"
		Set tDataDBName = pNewNamespace_"-DATA"
		
		// These can fail safely.
		Do ##class(%Library.EnsembleMgr).DisableNamespace(pNewNamespace)
		Do ..DeleteNamespace(pNewNamespace)
		Do ..DeleteDatabase(tBuildDBName)
		Do ..DeleteDatabase(tDataDBName)
		
		$$$ThrowOnError(..CreateDatabase(tBuildDBName))
		$$$ThrowOnError(..CreateDatabase(tDataDBName))
		$$$ThrowOnError(..CreateNamespace(pNewNamespace, tBuildDBName, tBuildDBName, pVerbose))
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="SwitchToBuildNamespace">
<Description>
@PrivateAPI</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tInitNS = $Select($Namespace="%SYS": "USER", 1: $Namespace)
		Set $Namespace = tInitNS_"-BUILD"
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="SwitchToNamespace">
<Description>
@PrivateAPI</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPostfix:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tInitNS = $Select($Namespace="%SYS": "USER", 1: $Namespace)
		Set $Namespace = tInitNS_"-"_pPostfix
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="RetrieveBuiltDatabase">
<Description>
@PrivateAPI</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pStream:%Stream.TmpBinary,pVerbose:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// TODO: Support retrieval of databases other than the code DB
	New $Namespace
	Set tSC = $$$OK
	Set pStream = ##class(%Stream.TmpBinary).%New()
	Try {
		Set tInitNS = $Select($Namespace="%SYS": "USER", 1: $Namespace)
		Set tCodeDBName = tInitNS_"-CODE"
		
		Set $Namespace = "%SYS"
		
		Set tDB = ##class(Config.Databases).Open(tCodeDBName,,.tSC)
		$$$ThrowOnError(tSC)
		If $IsObject(tDB) {
			// Dismount database
			$$$ThrowOnError(##class(SYS.Database).DismountDatabase(tDB.Directory))
			
			// Copy database to temp binary stream
			Set tDBFile = $SELECT($ZVERSION["IRIS": "IRIS.DAT", 1: "CACHE.DAT")
			Set tDBFile = ##class(%File).NormalizeFilename(tDBFile, tDB.Directory)
			Set tSourceStream = ##class(%Stream.FileBinary).%OpenId(tDBFile,,.tSC)
			$$$ThrowOnError(tSC)
			
			$$$ThrowOnError(pStream.CopyFrom(tSourceStream))
			
			Do pStream.Rewind()
			
			// Remount database
      Set tSysDB = ##class(SYS.Database).%OpenId(tDB.Directory)
      If ('tSysDB.Mounted) {
        $$$ThrowOnError(##class(SYS.Database).MountDatabase(tDB.Directory))      
      }
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="PrepareDatabase">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDBName:%String,pVerbose:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set tSC = $$$OK
	Try {
		Set $Namespace = "%SYS"
		
		Set tDB = ##class(Config.Databases).Open(pDBName,,.tSC)
		$$$ThrowOnError(tSC)
		If $IsObject(tDB) {
			// Compact
			Write:pVerbose !,"Compacting "_tDB.Directory_" ..."
			Set tSC = ##class(SYS.Database).CompactDatabase(tDB.Directory,100,.tMBProcessed,.tMBCompressed,0,$io)
			$$$ThrowOnError(tSC)
			Write:pVerbose !,$c(9),tMBProcessed,"MB processed; ",tMBCompressed,"MB compressed."
			
			// Defragment
			Write:pVerbose !,"Defragmenting "_tDB.Directory_" ..."
			Set tSC = ##class(SYS.Database).Defragment(tDB.Directory)
			$$$ThrowOnError(tSC)
			Write:pVerbose !,$c(9),"done."
			
			// Return unused space
			Write:pVerbose !,"Returning unused space in "_tDB.Directory_" ..."
			Set tSC = ##class(SYS.Database).ReturnUnusedSpace(tDB.Directory,,.tNewSize)
			$$$ThrowOnError(tSC)
			Write:pVerbose !,$c(9),"New file size: ",tNewSize,"MB"
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="CreateDatabase">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDBName:%String,pInitFile:%String="",pOverwrite:%Boolean=0,*pCreated:%Boolean</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set tSC = $$$OK
	Set pCreated = 0
	Try {
		Set $Namespace = "%SYS"
		Set tLowerName = $ZCVT(pDBName,"L")

		//Create directory
		Set tPath = ##class(%File).NormalizeDirectory(##class(%File).ManagerDirectory() _ pDBName)
		If '##class(%File).DirectoryExists(tPath) {
			Set tCreated = ##class(%File).CreateDirectory(tPath,.tResult)
			If 'tCreated {
				Set tSC = $$$ERROR($$$GeneralError,"Error creating directory '"_tPath_"': "_tResult)
				Quit
			}
		}

		// Create database
		Set tExists = 0
		If '##class(SYS.Database).%ExistsId(tPath) {
			Set tSC = ##class(SYS.Database).CreateDatabase(tPath)
			If $$$ISERR(tSC) {
				Quit
			}
		} Else {
			Set tExists = 1
		}
		Set tSC = ##class(SYS.Database).DismountDatabase(tPath)
		If $$$ISERR(tSC) {
			Quit
		}
		
		If (pInitFile '= "") && (pOverwrite || 'tExists) {
			Set tDBFile = tPath_$SELECT($ZVERSION["IRIS": "IRIS.DAT", 1: "CACHE.DAT")
			Set tGood = ##class(%File).CopyFile(pInitFile,tDBFile,pOverwrite,.tReturn)
			If 'tGood {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Error copying %1 to %2: %3",pInitFile,tDBFile,tReturn))
				Quit
			}
		}

		// Create (if necessary) and mount database
		If '##class(Config.Databases).Exists(pDBName) {
			Set tDBProps("Directory") = tPath
			Set tDBProps("MountRequired") = 1
			Set tSC = ##class(Config.Databases).Create(pDBName,.tDBProps)
			If $$$ISERR(tSC) {
				Quit
			}
			Set Properties("MountRequired") = 1
			Set tSC = ##class(Config.Databases).Modify(pDBName,.tDBProps)
			If $$$ISERR(tSC) {
				Quit
			}
			Set pCreated = 1
		}
    Set tDB = ##class(SYS.Database).%OpenId(tPath)
    If ('tDB.Mounted) {
		  $$$ThrowOnError(##class(SYS.Database).MountDatabase(tPath))      
    }    
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="DeleteDatabase">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDBName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set tFinalStatus = $$$OK
	Try {
		Set $Namespace = "%SYS"
		Set tLowerName = $ZCVT(pDBName,"L")
		Set tPath = ##class(%File).ManagerDirectory() _ pDBName
		
		// Delete database
		Set tSC = ##class(Config.Databases).Delete(pDBName)
		Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)

		// Delete database file
		Set tSC = ##class(SYS.Database).DeleteDatabase(tPath)
		Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)

		// Delete directories
		Set tDirRemoved = ##class(%File).RemoveDirectoryTree(tPath)
		If 'tDirRemoved {
			Set tFinalStatus = $$$ADDSC(tFinalStatus,$$$ERROR($$$GeneralError,"Error removing directory '"_tPath_"'"))
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="CreateNamespace">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNSName:%String,pCodeDBName:%String,pDataDBName:%String,pVerbose:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set tSC = $$$OK
	Try {
		Set $Namespace = "%SYS"
		Set tLowerName = $ZCVT(pNSName,"L")

		//Create CSP directory
		Set tWebPath = ##class(%File).NormalizeDirectory(##class(%File).ParentDirectoryName(##class(%File).ManagerDirectory()) _ "csp") _ pNSName
		Set tCreated = ##class(%File).CreateDirectory(tWebPath,.tResult)
		If 'tCreated,'##class(%File).DirectoryExists(tWebPath) {
			Set tSC = $$$ERROR($$$GeneralError,"Error creating directory '"_tWebPath_"': "_tResult)
			Quit
		}

		// Create namespace
		Set tNSProps("Globals") = pDataDBName
		Set tNSProps("Routines") = pCodeDBName
		If $ZVERSION["IRIS" {
			Set tNSProps("Library") = "IRISLIB"
			Set tNSProps("SysGlobals") = "IRISSYS"
			Set tNSProps("SysRoutines") = "IRISSYS"
			Set tNSProps("TempGlobals") = "IRISTEMP"
		} else {
			Set tNSProps("Library") = "CACHELIB"
			Set tNSProps("SysGlobals") = "CACHESYS"
			Set tNSProps("SysRoutines") = "CACHESYS"
			Set tNSProps("TempGlobals") = "CACHETEMP"
		}
		Set tSC = ##class(Config.Namespaces).Create(pNSName,.tNSProps)
		If $$$ISERR(tSC) {
			Quit
		}

		// Ensemble-enable namespace
		// PackageManager at some point will ignore Verbose = 0, so redirect output to the null device if we're not in verbose mode.
		Set tOldIO = $IO
		Try {
			Open ##class(%Device).GetNullDevice()
			Use ##class(%Device).GetNullDevice()
			Set tSC = ##class(%EnsembleMgr).EnableNamespace(pNSName)
			If $$$ISERR(tSC) {
				Quit
			}
		} Catch e {
			Set tSC = e.AsStatus()
		}
		Use tOldIO
		If $$$ISERR(tSC) {
			Quit
		}
		QUIT 
		#; // Temporarily, map HS.Registry to HSLIB...
		#; Set tSC = ##class(Utils).AddPackageMapping(pNSName,"HS.Registry","HSLIB")
		#; If $$$ISERR(tSC) {
		#; 	Quit
		#; }
		
		#; // ...but remove other HS.* mappings
		#; Set tSC = ##class(Utils).RemovePackageMapping(pNSName,"HS")
		#; If $$$ISERR(tSC) {
		#; 	Quit
		#; }
		
		#; Set tSC = ##class(Utils).RemoveRoutineMapping(pNSName,"HS.*")
		#; If $$$ISERR(tSC) {
		#; 	Quit
		#; }
		
		#; // Add mapping for ^ZPM.Dev.* to the CODE database
		#; Set tSC = ##class(Utils).AddGlobalMapping(pNSName,"%ZPM.Dev.*",pCodeDBName)
		#; If $$$ISERR(tSC) {
		#; 	Quit
		#; }

		// Create default web application
		Set tWebProps("AutheEnabled") = $$$AutheCache + $$$AutheUnauthenticated
		Set tWebProps("NameSpace") = pNSName
		Set tWebProps("Path") = tWebPath
		Set tWebProps("IsNameSpaceDefault") = 1
		Set tSC = ##class(Security.Applications).Modify("/csp/"_tLowerName,.tWebProps)
		If $$$ISERR(tSC) {
			Quit
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="DeleteNamespace">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNSName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set tFinalStatus = $$$OK
	Try {
		Set $Namespace = "%SYS"
		Set tLowerName = $ZCVT(pNSName,"L")
		Set tWebPath = ##class(%File).NormalizeDirectory(##class(%File).ParentDirectoryName(##class(%File).ManagerDirectory()) _ "csp") _ pNSName
		
		Set tSC = ##class(%Library.EnsembleMgr).deleteNamespace(pNSName)
		$$$ThrowOnError(tSC)

		// Delete Web Application
		Set tSC = ##class(Security.Applications).Delete("/csp/"_tLowerName)
		Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)

		// Delete namespace
		Set tSC = ##class(Config.Namespaces).Delete(pNSName)
		Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)

		// Delete secondary databases
		Set tSecondaryDB = pNSName_##class(%Library.EnsembleMgr).#SECONDARYSUFFIX
		Set tEnsTempDB = pNSName_##class(%Library.EnsembleMgr).#TEMPSUFFIX
		For tOtherDB = tSecondaryDB,tEnsTempDB {
			Set tSC = $$$OK
			Set tDB = ##class(Config.Databases).Open(tOtherDB,,.tSC)
			If $IsObject(tDB) {
				// Delete database
				Set tSC = ##class(Config.Databases).Delete(tOtherDB)
				Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)
				
				// Delete database file
				Set tOtherPath = tDB.Directory
				Set tSC = ##class(SYS.Database).DeleteDatabase(tOtherPath)
				Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)
			} ElseIf $$$ISERR(tSC) {
				Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)
			}
		}
		
		Set tDirRemoved = ##class(%File).RemoveDirectoryTree(tWebPath)
		If 'tDirRemoved {
			Set tFinalStatus = $$$ADDSC(tFinalStatus,$$$ERROR($$$GeneralError,"Error removing directory '"_tWebPath_"'"))
		}
	} Catch e {
		Set tFinalStatus = $$$ADDSC(tFinalStatus,e.AsStatus())
	}
	Quit tFinalStatus
]]></Implementation>
</Method>

<Method name="MapGlobalEquivalently">
<Description><![CDATA[
Maps <var>pGlobalName</var> in <var>pMappedToNamespace</var> to the same database in <var>pSourceNamespace</var>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pGlobalName:%String,pSourceNamespace:%String,pMappedToNamespace:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.CLI">
<IncludeCode>%occSAX,%syGluedef</IncludeCode>
<IncludeGenerator>%occSAX</IncludeGenerator>
<TimeCreated>65797,80971.888744</TimeCreated>

<XData name="Commands">
<Description>
Description of commands to use for this CLI</Description>
<XMLNamespace>http://www.intersystems.com/PackageManager/CLI</XMLNamespace>
<Data><![CDATA[
<?xml version="1.0"?>
<commands>
</commands>
]]></Data>
</XData>

<XData name="Schema">
<Description>
This is the Schema which defines the form of the Commands XData block</Description>
<Internal>1</Internal>
<Data><![CDATA[
<?xml version="1.0"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" >

<xs:element name="commands">
<xs:complexType>
<xs:choice minOccurs="0" maxOccurs="unbounded">
<xs:element name="command">
<xs:complexType>
<xs:choice minOccurs="0" maxOccurs="unbounded">

<!-- A modifier is a flag that controls the behavior of the command. -->
<xs:element name="modifier">
<xs:complexType>
<!-- Modifier name -->
<xs:attribute name="name" type="string" use="required"/>

<!-- Modifier name -->
<xs:attribute name="required" type="xs:boolean" use="optional" default="false"/>

<!-- Comma-separated list of aliases -->
<xs:attribute name="aliases" type="string" use="optional"/>

<!-- If true, the modifier name is followed in the command string by a value -->
<xs:attribute name="value" type="xs:boolean" use="optional" default="false"/>

<!-- If true, the modifier name is followed in the command string by a value -->
<xs:attribute name="description" type="string" use="optional"/>

<!-- If set, this provides a fixed list of valid values for the modifier -->
<xs:attribute name="valueList" type="string" use="optional"/>

<!-- If set, the value is put into the specified subscript of "data" instead of "parameters" -->
<xs:attribute name="dataAlias" type="string" use="optional"/>

<!-- If set, the specified value is put into the info("data","<dataAlias>") - for commands that don't take values -->
<xs:attribute name="dataValue" type="string" use="optional"/>
</xs:complexType>
</xs:element>

<!-- A parameter is a space-delimted string provided to a command without a modifier. These appear in order at the end of the command. -->
<xs:element name="parameter">
<xs:complexType>
<!-- Parameter name -->
<xs:attribute name="name" type="string" use="required"/>

<!-- Parameter required? -->
<xs:attribute name="required" type="xs:boolean" use="optional" default="false"/>

<!-- Description of what this parameter does -->
<xs:attribute name="description" type="string" use="optional"/>

<!-- If set to true (default is false), parameter will take all trailing input (including spaces) -->
<xs:attribute name="trailing" type="xs:boolean" use="optional" default="false"/>
</xs:complexType>
</xs:element>

<!-- Example of how to use the command -->
<xs:element name="example" type="example" />

<!-- Description of command -->
<xs:element name="description" type="description"/>
</xs:choice>

<!-- Name of the command -->
<xs:attribute name="name" type="string" use="optional"/>

<!-- If set to true, this is the default command if the parser does not match any. The name is ignored, and is instead treated as the first parameter. -->
<xs:attribute name="default" type="xs:boolean" use="optional" default="false"/>

<!-- Comma-separated list of aliases -->
<xs:attribute name="aliases" type="string" use="optional"/>

<!-- If true, modifiers are at the end of the command. -->
<xs:attribute name="trailingModifiers" type="xs:boolean" use="optional" default="false" />

<!-- If set, modifiers starting with this prefix are put into the "data" subscript of the command array. -->
<xs:attribute name="dataPrefix" type="string" use="optional" />
</xs:complexType>
</xs:element>
</xs:choice>
</xs:complexType>
</xs:element>

<!-- example element with content -->
<xs:complexType name="example">
<xs:simpleContent>
<xs:extension base="string">
<xs:attribute name="description" type="string" />
</xs:extension>
</xs:simpleContent>
</xs:complexType>

<!-- description element with content -->
<xs:complexType name="description">
<xs:simpleContent>
<xs:extension base="string">
</xs:extension>
</xs:simpleContent>
</xs:complexType>

<!-- disallow, allow, require  -->
<xs:simpleType name="modifierValue">
  <xs:restriction base="xs:string">
    <xs:enumeration value="disallow" />
    <xs:enumeration value="allow" />
    <xs:enumeration value="require" />
  </xs:restriction>
</xs:simpleType>

<!-- String of minimum length 1 -->
<xs:simpleType name="string">
<xs:restriction base="xs:string">
<xs:minLength value="1"/>
</xs:restriction>
</xs:simpleType>

</xs:schema>
]]></Data>
</XData>

<Method name="%Help">
<Description>
Displays help for a given command</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pCommandInfo]]></FormalSpec>
<Implementation><![CDATA[
	Set tCommand = $Get(pCommandInfo("parameters","command"))
	Set tVerbose = ''$Data(pCommandInfo("modifiers","verbose"))
	Set tMarkdown = ''$Data(pCommandInfo("modifiers","markdown"))
	Do ..%GetCommandStructure(.tCommandStruct)
	
	If (tCommand '= "") && '$Data(tCommandStruct(tCommand)) {
		// See if it's an alias. (If not, we'll show help for everything.)
		If $Data(tCommandStruct(1,tCommand),tCommand)
	}
	
	If (tCommand '= "") && (tCommand '= +tCommand) && $Data(tCommandStruct(tCommand)) {
		Kill tOneCommandStruct
		Merge tOneCommandStruct = tCommandStruct(tCommand)
		Do ..%HelpForCommand(tCommand,.tOneCommandStruct,1,tMarkdown)
	} Else {
		// For markdown mode only, merge aliases into main part of tCommandStruct array.
		// This gets the commands in alphabetical order.
		If tMarkdown {
			Set tCommand = ""
			For {
				Set tCommand = $Order(tCommandStruct(1,tCommand))
				Quit:(tCommand="")
				
				Set tCommandStruct(tCommand) = tCommandStruct(1,tCommand)
			}
		}
		
		// List commands
		Write:'tMarkdown !,"Available commands: "
		Set tCommand = ""
		For {
			Set tCommand = $Order(tCommandStruct(tCommand))
			Quit:(tCommand="")
			Continue:(tCommand=+tCommand) // Skip numbered subscripts.
			
			Kill tOneCommandStruct
			Merge tOneCommandStruct = tCommandStruct(tCommand)
			Do ..%HelpForCommand(tCommand,.tOneCommandStruct,tVerbose,tMarkdown)
			
			Write !
		}
		
		Write:'tVerbose !,"For more detail, run:",!?2,"help <command-name>",!,"or",!?2,"help -v"
	}
]]></Implementation>
</Method>

<Method name="%HelpForCommand">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pCommandName:%String,&pCommandStruct,pDetailed:%Boolean=0,pMarkdownFormat:%Boolean=0]]></FormalSpec>
<Implementation><![CDATA[
	#define ESCAPE(%string) $Select(pMarkdownFormat:$Replace(%string,"[","\["),1:%string)
	Set tIndent = 2
	Set tIsAlias = $Data(pCommandStruct)<10
	If pMarkdownFormat && tIsAlias {
		Write !,"----",!,"h2. ",pCommandName
		Write !,"_Alias for [",pCommandStruct,"|#",pCommandStruct,"]_"
	}
	
	// Don't show full documentation for aliases 
	Quit:tIsAlias
	
	Write !,$Select(pMarkdownFormat:"----",1:""),!
	Write:pMarkdownFormat "h2. "
	Write pCommandName
	
	Write:pMarkdownFormat !,"Syntax: {{",pCommandName
	
	If $Data(pCommandStruct("modifiers")) && '$Get(pCommandStruct("trailingModifiers"),0) {
		Write $$$ESCAPE(" [flags]")
	}
	
	If $Data(pCommandStruct("parameters")) {
		Set tKey = ""
		Set tEndingBrackets = 0
		For {
			Set tKey = $Order(pCommandStruct("parameters",tKey),1,tParamName)
			Quit:(tKey="")
			Quit:(tKey'=+tKey) //Only deal with ordered parameters, not named
			
			Write " "
			If 'pCommandStruct("parameters",tParamName,"required") {
				Write $$$ESCAPE("[")
				Set tEndingBrackets = tEndingBrackets + 1
			}
			Write "<",tParamName,">"
		}
		
		For i=1:1:tEndingBrackets {
			Write $$$ESCAPE("]")
		}
	}
	
	If $Data(pCommandStruct("modifiers")) && $Get(pCommandStruct("trailingModifiers"),0) {
		Write $$$ESCAPE(" [flags]")
	}
	
	Write:pMarkdownFormat "}}"
	
	Write:$Data(pCommandStruct("aliases")) !,"Alias",$Case($Length(pCommandStruct("aliases"),","),1:"",:"es"),": ",$Replace(pCommandStruct("aliases"),",",", ")
	
	Write:$Data(pCommandStruct("description")) !,?tIndent,pCommandStruct("description")
	If (pDetailed) {
		// Modifiers
		If $Data(pCommandStruct("modifiers")) {
			Write !!
			If (pMarkdownFormat) {
				Write "h3."
			} Else {
				Write ?tIndent
			}
			Write "Flags"
			If pMarkdownFormat {
				Write !,"||Flag||Description||Aliases||"
			}
			Set tKey = 1000
			For {
				Set tKey = $Order(pCommandStruct("modifiers",tKey))
				Quit:(tKey="")
				
				Write !
				If pMarkdownFormat {
					Write "|"
				} Else {
					Write ?(tIndent*2)
				}
				Write "-",tKey
				
				Kill tModInfo Merge tModInfo = pCommandStruct("modifiers",tKey)
				If $Get(tModInfo("value")) {
					If $Data(tModInfo("valueList"),tValueList) {
						Write " <",$Replace(tValueList,",","/"),">"
					} Else {
						Write " <value>"
					}
				}
				Write:pMarkdownFormat " |"
				If ($Data(tModInfo("description"),tDesc)) {
					If 'pMarkdownFormat {
						Write !,?(tIndent*3)
					}
					Write tDesc
				}
				Write:pMarkdownFormat " |"
				If ($Data(tModInfo("aliases"),tAliases)) {
					If 'pMarkdownFormat {
						Write !,?(tIndent*3),"alias(es): -"
					}
					Write $Replace(tAliases,",",", -")
				}
				Write:pMarkdownFormat " |"
			}
		}
		
		// Arguments
		If $Data(pCommandStruct("parameters")) {
			Write !!
			If (pMarkdownFormat) {
				Write "h3."
			} Else {
				Write ?tIndent
			}
			Write "Arguments"
			If pMarkdownFormat {
				Write !,"||Name||Description||"
			}
			Set tKey = ""
			For {
				Set tKey = $Order(pCommandStruct("parameters",tKey),1,tParamName)
				Quit:(tKey="")
				Quit:(tKey'=+tKey) //Only deal with ordered parameters, not named
				
				Write !
				If pMarkdownFormat {
					Write "|"
				} Else {
					Write ?(tIndent*2)
				}
				Write tParamName
				Write:pMarkdownFormat " |"
				
				Kill tParamInfo Merge tParamInfo = pCommandStruct("parameters",tParamName)
				If ($Data(tParamInfo("description"),tDesc)) {
					If 'pMarkdownFormat {
						Write !,?(tIndent*3)
					}
					Write tDesc
				}
				Write:pMarkdownFormat " |"
			}
		}
		
		// Examples
		If $Data(pCommandStruct("examples")) {
			Write !!
			If (pMarkdownFormat) {
				Write "h3."
			} Else {
				Write ?tIndent
			}
			Write "Examples"
			If pMarkdownFormat {
				Write !,"||Command||Description||"
			}
			Set tKey = ""
			For {
				Set tKey = $Order(pCommandStruct("examples",tKey))
				Quit:(tKey="")
				
				
				Write !
				Write:pMarkdownFormat "|{{"
				Write pCommandStruct("examples",tKey)
				Write:pMarkdownFormat "}}|"
				Write:'pMarkdownFormat ?(tIndent*2)
				If $Data(pCommandStruct("examples",tKey,"description"),tDesc) {
					Write:'pMarkdownFormat !,?(tIndent*3)
					Write tDesc
				} Else {
					Write:'pMarkdownFormat ?(tIndent*2)
				}
				Write:pMarkdownFormat " |"
			}
		}
	}
]]></Implementation>
</Method>

<Method name="%ParseCommandInput">
<Description><![CDATA[
Parses a command, validating it based on the Commands XData block and structuring output as follows:
pCommandInfo = "<command name>"
pCommandInfo("modifiers","<modifier-name>") = "<modifier-value>"
pCommandInfo("parameters","<parameter-name>") = "<parameter-value>"
pCommandInfo("data","<data-name>") = "<data-value>"]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCommandString:%String,*pCommandInfo</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
  Kill pCommandInfo
	Try {
		Do ..%GetCommandStructure(.tCommandStructure)
		
		// Parser states:
		// 0 - looking for next item (following a space)
		// 1 - in command
		// 2 - in modifier identifier
		// 3 - in modifier value
		// 4 - in quoted modifier value
		// 5 - in parameter value
		// 6 - in quoted parameter value
		// 7 - just saw the escape character (\) while in a quoted string
		// 8 - in a trailing parameter, so capture the rest of the string as the final parameter (including spaces)
		// 9 - in the name for a data element (following command's dataPrefix)
		
		#define PREARGUMENT 0
		#define COMMAND 1
		#define MODIFIERNAME 2
		#define MODIFIERVALUE 3
		#define MODIFIERVALUEQUOTED 4
		#define PARAMETERVALUE 5
		#define PARAMETERVALUEQUOTED 6
		#define ESCAPECHAR 7
		#define TRAILINGPARAMETERVALUE 8
		#define DATANAME 9
		
		Set tState = $$$COMMAND
		Set tPos = 1
		Set tAccum = ""
		Set tModifier = ""
		Set tDataName = ""
		Set tParamCount = 0
		Set tPreEscapeState = ""
		For {
			Set tChar = $Extract(pCommandString,tPos)
			Set tPos = tPos + 1
			
			If (tChar = " ") || (tChar = "") {
				If (tState = $$$COMMAND) && (tAccum'="") {
					If $Data(tCommandStructure(tAccum)) {
						// tAccum contains command name.
						Set pCommandInfo = tAccum
					} ElseIf $Data(tCommandStructure(1,tAccum),tAliasFor) {
						// tAccum contains an alias - use the real name.
						Set pCommandInfo = tAliasFor
					} ElseIf $Data(tCommandStructure(0,"default"),tDefaultCommand) {
						// tAccum just got the first parameter, so pass it along to the default command.
						Set pCommandInfo = tDefaultCommand
						Set tParamName = $Get(tCommandStructure(tDefaultCommand,"parameters",$i(tParamCount)))
						If (tParamName = "") {
							$$$ThrowStatus($$$ERROR($$$GeneralError,$$$FormatText("Too many parameters to command '%1'; only %2 expected.",pCommandInfo,tParamCount-1)))
						}
						Set pCommandInfo("parameters",tParamName) = tAccum
					} Else {
						$$$ThrowStatus($$$ERROR($$$GeneralError,$$$FormatText("Unknown command: %1",tAccum)))
					}
					Set tAccum = ""
					Set tState = $$$PREARGUMENT
				} ElseIf (tState = $$$MODIFIERNAME) {
					If $Data(tCommandStructure(pCommandInfo,"modifiers",tAccum)) {
						Set tModifier = tAccum
					} ElseIf $Data(tCommandStructure(pCommandInfo,"modifiers",1,tAccum),tAliasFor) {
						Set tModifier = tAliasFor
					} Else {
						$$$ThrowStatus($$$ERROR($$$GeneralError,$$$FormatText("Unknown modifier for command '%1': %2",pCommandInfo,tAccum)))
					}
					If $Data(tCommandStructure(pCommandInfo,"modifiers",tModifier,"dataAlias"),tDataAlias) {
						Set tDataName = tDataAlias
						If $Data(tCommandStructure(pCommandInfo,"modifiers",tModifier,"dataValue"),tDataValue) {
							Do ..SetData(.pCommandInfo,tDataAlias,tDataValue)
							Set tState = $$$PREARGUMENT
						} Else {
							Set tState = $$$MODIFIERVALUE
						}
					} ElseIf tCommandStructure(pCommandInfo,"modifiers",tModifier,"value") {
						Set tState = $$$MODIFIERVALUE
					} Else {
						Set pCommandInfo("modifiers",tModifier) = ""
						Set tState = $$$PREARGUMENT
					}
					Set tAccum = ""
				} ElseIf (tState = $$$MODIFIERVALUE) {
					If ($Get(tDataName) '= "") {
						Do ..SetData(.pCommandInfo,tDataName,tAccum,1)
						Set tDataName = ""
					} Else {
						Set pCommandInfo("modifiers",tModifier) = tAccum
					}
					Set tAccum = ""
					Set tState = $$$PREARGUMENT
				} ElseIf (tState = $$$PARAMETERVALUE) || ((tState = $$$TRAILINGPARAMETERVALUE) && (tChar = "")) {
					Set tParamName = $Get(tCommandStructure(pCommandInfo,"parameters",$i(tParamCount)))
					If (tParamName = "") {
						$$$ThrowStatus($$$ERROR($$$GeneralError,$$$FormatText("Too many parameters to command '%1'; only %2 expected.",pCommandInfo,tParamCount-1)))
					}
					Set pCommandInfo("parameters",tParamName) = tAccum
					Set tAccum = ""
					Set tState = $$$PREARGUMENT
				} ElseIf (tState = $$$TRAILINGPARAMETERVALUE) {
					Set tAccum = tAccum_tChar
				}
				
				If '((tState = $$$MODIFIERVALUEQUOTED) || (tState = $$$PARAMETERVALUEQUOTED)) {
					Quit:(tChar="")
					Continue
				}
			} ElseIf (tChar = "-") {
				If (tState = $$$PREARGUMENT) {
					Set tState = $$$MODIFIERNAME
					Set tModifier = ""
					Continue
				} ElseIf ((tState = $$$PARAMETERVALUE) || (tState = $$$TRAILINGPARAMETERVALUE))
					&& $Get(tCommandStructure(pCommandInfo,"trailingModifiers")) {
						Set tParamName = $Get(tCommandStructure(pCommandInfo,"parameters",$i(tParamCount)))
						If (tParamName = "") {
							$$$ThrowStatus($$$ERROR($$$GeneralError,$$$FormatText("Too many parameters to command '%1'; only %2 expected.",pCommandInfo,tParamCount-1)))
						}
						If ($Extract(tAccum,*) = " ") {
							Set pCommandInfo("parameters",tParamName) = $Extract(tAccum,1,*-1) // Strip the space.
						} Else {
							Set pCommandInfo("parameters",tParamName) = tAccum
						}
						Set tAccum = ""
						Set tState = $$$MODIFIERNAME
						Set tModifier = ""
						Continue
					}
			} ElseIf (tChar = "\") {
				If (tState = $$$MODIFIERVALUEQUOTED) || (tState = $$$PARAMETERVALUEQUOTED) {
					Set tPreEscapeState = tState
					Set tState = $$$ESCAPECHAR
					Continue
				}
			} ElseIf (tChar = """") {
				If (tState = $$$PREARGUMENT) {
					Set tState = $$$PARAMETERVALUEQUOTED
					Continue
				} If (tState = $$$MODIFIERVALUE) && (tAccum = "") {
					Set tState = $$$MODIFIERVALUEQUOTED
					Continue
				} ElseIf (tState = $$$PARAMETERVALUE) && (tAccum = "") {
					Set tState = $$$PARAMETERVALUEQUOTED
					Continue
				} ElseIf (tState = $$$MODIFIERVALUEQUOTED) {
					If ($Get(tDataName) '= "") {
						Do ..SetData(.pCommandInfo,tDataName,tAccum,1)
					} Else {
						Set pCommandInfo("modifiers",tModifier) = tAccum
					}
					Set tAccum = ""
					Set tState = $$$PREARGUMENT
					Continue
				} ElseIf (tState = $$$PARAMETERVALUEQUOTED) {
					Set tParamName = $Get(tCommandStructure(pCommandInfo,"parameters",$i(tParamCount)))
					If (tParamName = "") {
						$$$ThrowStatus($$$ERROR($$$GeneralError,$$$FormatText("Too many parameters to command '%1'; only %2 expected.",pCommandInfo,tParamCount-1)))
					}
					Set pCommandInfo("parameters",tParamName) = tAccum
					Set tAccum = ""
					Set tState = $$$PREARGUMENT
					Continue
				}
			} ElseIf (tChar = "=") {
				If (tState = $$$DATANAME) {
					Set tDataName = tAccum
					Set tState = $$$MODIFIERVALUE
					Set tAccum = ""
					Continue
				}
			} Else {
				If (tState = $$$PREARGUMENT) {
					Set tParamName = $Get(tCommandStructure(pCommandInfo,"parameters",tParamCount+1))
					If (tParamName = "") {
						$$$ThrowStatus($$$ERROR($$$GeneralError,$$$FormatText("Too many parameters to command '%1'; only %2 expected.",pCommandInfo,tParamCount)))
					}
					If $Get(tCommandStructure(pCommandInfo,"parameters",tParamName,"trailing")) {
						Set tState = $$$TRAILINGPARAMETERVALUE
					} Else {
						Set tState = $$$PARAMETERVALUE
						Set tEndPos = $Locate(pCommandString, "\s", tPos)
						If (tEndPos > 0) {
							Set tAccum = tChar_ $Extract(pCommandString, tPos, tEndPos - 1)
						} Else {
							Set tAccum = tChar_ $Extract(pCommandString, tPos, *)
						}
						Set tPos = tEndPos
						Continue
					}
				} ElseIf (tState = $$$MODIFIERNAME) {
					Set tDataPrefix = $Get(tCommandStructure(pCommandInfo,"dataPrefix"))
					If (tAccum = "") && (tDataPrefix '= "") && (tChar = tDataPrefix) {
						Set tState = $$$DATANAME
						Set tDataName = ""
						Continue
					}
				}
			}
			
			If (tChar = "") {
				$$$ThrowStatus($$$ERROR($$$GeneralError,$$$FormatText("Invalid trailing input: %1",tAccum)))
			}
			
			// Default: accumulate
			Set tAccum = tAccum _ tChar
			
			If (tState = $$$ESCAPECHAR) {
				Set tState = tPreEscapeState
			}
		}
		
		// TODO: Extra validation.
	} Catch e {
		If e.%IsA("%Exception.SystemException") {
			Set tSC = $System.Status.EmbedStatus($$$ERROR($$$GeneralError,$$$FormatText("Error parsing command: %1",pCommandString)),e.AsStatus())
		} Else {
			Set tSC = e.AsStatus()
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%GetCommandStructure">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>*pCommandStructure</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tClassName = %classname

		#; Don't run on base class
		If (tClassName = "%ZPM.PackageManager.Developer.CLI") {
			Quit
		}

		#; Find named XDATA block
		If ##class(%Dictionary.CompiledXData).%ExistsId(tClassName_"||Commands") {
			Set tCompiledClass = ##class(%Dictionary.CompiledClass).%OpenId(tClassName,,.tSC)
			If '$IsObject(tCompiledClass)||$$$ISERR(tSC) Quit

			Set tIndex = tCompiledClass.XDatas.FindObjectId(tClassName_"||Commands")
			If (tIndex = "") {
				Set tSC = $$$ERROR($$$XDataBlockMissing,tClassName,"Commands")
				Quit
			}

			#; Get XDATA as stream
			Set tStream = tCompiledClass.XDatas.GetAt(tIndex).Data
			Do tStream.Rewind()

			#; Create an XML import handler ( use the internal handler )
			Set tHandler = ##class(%XML.ImportHandler).%New("CacheTemp",$$$IntHandler) 

			#; Create the Entity Resolver
			Set tResolver = ##class(%XML.SAX.XDataEntityResolver).%New(tClassName)

			#; Parse the XML data in the specfied stream
			Set tSC = ##Class(%XML.SAX.Parser).ParseStream(tStream,tHandler,tResolver,,,"Schema")
			If $$$ISERR(tSC) {
				Quit
			}
        
            #; Copy tree because handler will delete it's copy when it goes out of scope
            Merge tMap = ^CacheTemp(tHandler.Tree)
            
			If $Data(tMap("error"))||$Data(tMap("warning")) {
				Set tSC = $$$ERROR($$$GeneralError,"Could not parse Commands XData block.")
				For tType = "error","warning" {       
					Set tIndex = ""
					For {
						Set tIndex = $Order(tMap(tType,tIndex),1,tError)
						If (tIndex = "") {
							Quit
						}
						Set tSC = $$$ADDSC(tSC,$$$ERROR($$$GeneralError,tError))
					}
				}
				Quit
			}
			
			Do %code.WriteLine(" Kill pCommandStructure")
			
			Set tChild = ""
			For {
				Set tChild = $Order(tMap(1,"c",tChild))
				Quit:(tChild="")
				#Define empty """"""
				If (tMap(tChild) = "command") {
					Set tName = $$$QUOTE(tMap(tChild,"a","name"))
					Set tExample = $$$QUOTE($Get(tMap(tChild,"a","example")))
					If ($Get(tMap(tChild,"a","default")) = "true") {
						Do %code.WriteLine(" Set pCommandStructure(0,""default"") = "_tName)
					}
					If $Data(tMap(tChild,"a","aliases")) {
						Do %code.WriteLine(" Set pCommandStructure("_tName_",""aliases"") = "_$$$QUOTE(tMap(tChild,"a","aliases")))
						Set tAliasList = $ListFromString(tMap(tChild,"a","aliases"))
						Set tPtr = 0
						While $ListNext(tAliasList,tPtr,tAlias) {
							Do %code.WriteLine(" Set pCommandStructure(1,"_$$$QUOTE(tAlias)_") = "_tName)
						}
					}
					If $Data(tMap(tChild,"a","dataPrefix"),tDataPrefix) {
						Do %code.WriteLine(" Set pCommandStructure("_tName_",""dataPrefix"") = "_$$$QUOTE(tDataPrefix))
					}
					If $Data(tMap(tChild,"a","trailingModifiers"),tTrailingModifiers) {
						Do %code.WriteLine(" Set pCommandStructure("_tName_",""trailingModifiers"") = "_$Case(tTrailingModifiers,"true":1,:0))
					}
					
					// Children of command
					Set tCommChild = ""
					For {
						Set tCommChild = $Order(tMap(tChild,"c",tCommChild))
						Quit:(tCommChild="")
						
						Set tDesc = $$$QUOTE($Get(tMap(tCommChild,"a","description")))
						
						If (tMap(tCommChild) = "example") {
							Set tContentNode = $Order(tMap(tCommChild,"c",0))
							If (tContentNode '= "") {
								// Different version of $$$QUOTE to convert newlines into $c(10) (for example) - this is what zwrite calls.
								Set tExampleContent = $$Quote^%qcr($Replace($ZStrip(tMap(tContentNode),"<>C"),$c(10),$c(13,10)))
								Do %code.WriteLine(" Set pCommandStructure("_tName_",""examples"",$i(pCommandStructure("_tName_",""examples""))) = "_tExampleContent)
								Do:(tDesc'=$$$empty) %code.WriteLine(" Set pCommandStructure("_tName_",""examples"",pCommandStructure("_tName_",""examples""),""description"") = "_tDesc)
							}
						} ElseIf (tMap(tCommChild) = "description") {
							Set tContentNode = $Order(tMap(tCommChild,"c",0))
							If (tContentNode '= "") {
								// Different version of $$$QUOTE to convert newlines into $c(10) (for example) - this is what zwrite calls.
								Set tDescContent = $$Quote^%qcr($Replace($ZStrip(tMap(tContentNode),"<>C"),$c(10),$c(13,10)))
								Do %code.WriteLine(" Set pCommandStructure("_tName_",""description"") = "_tDescContent)
							}
						} Else {
							// Common: name, required, description
							Set tChildName = $$$QUOTE(tMap(tCommChild,"a","name"))
							Set tRequired = $Case($Get(tMap(tCommChild,"a","required")),"true":1,:0)
							
							If (tMap(tCommChild) = "modifier") {
								// Also: aliases, value, valueList
								Set tValue = $Get(tMap(tCommChild,"a","value"))
								Set tValueList = $$$QUOTE($Get(tMap(tCommChild,"a","valueList")))
								Set tDataAlias = $$$QUOTE($Get(tMap(tCommChild,"a","dataAlias")))
								Set tDataValue = $$$QUOTE($Get(tMap(tCommChild,"a","dataValue")))
								If $Data(tMap(tCommChild,"a","aliases")) {
									Do %code.WriteLine(" Set pCommandStructure("_tName_",""modifiers"","_tChildName_",""aliases"") = "_$$$QUOTE(tMap(tCommChild,"a","aliases")))
									Set tAliasList = $ListFromString(tMap(tCommChild,"a","aliases"))
									Set tPtr = 0
									While $ListNext(tAliasList,tPtr,tAlias) {
										Do %code.WriteLine(" Set pCommandStructure("_tName_",""modifiers"",1,"_$$$QUOTE(tAlias)_") = "_tChildName)
									}
								}
								Do %code.WriteLine(" Set pCommandStructure("_tName_",""modifiers"","_tChildName_",""value"") = "_$Case(tValue,"true":1,:0))
								Do %code.WriteLine(" Set pCommandStructure("_tName_",""modifiers"","_tChildName_",""required"") = "_tRequired)
								Do:(tDesc'=$$$empty) %code.WriteLine(" Set pCommandStructure("_tName_",""modifiers"","_tChildName_",""description"") = "_tDesc)
								Do:(tValueList'=$$$empty) %code.WriteLine(" Set pCommandStructure("_tName_",""modifiers"","_tChildName_",""valueList"") = "_tValueList)
								Do:(tDataAlias'=$$$empty) %code.WriteLine(" Set pCommandStructure("_tName_",""modifiers"","_tChildName_",""dataAlias"") = "_tDataAlias)
								Do:(tDataValue'=$$$empty) %code.WriteLine(" Set pCommandStructure("_tName_",""modifiers"","_tChildName_",""dataValue"") = "_tDataValue)
							} ElseIf (tMap(tCommChild) = "parameter") {
								// Also: example
								Set tExample = $$$QUOTE($Get(tMap(tCommChild,"a","example")))
								Set tTrailing = $Case($Get(tMap(tCommChild,"a","trailing")),"true":1,:0)
								Do %code.WriteLine(" Set pCommandStructure("_tName_",""parameters"",$i(pCommandStructure("_tName_",""parameters""))) = "_tChildName)
								Do %code.WriteLine(" Set pCommandStructure("_tName_",""parameters"","_tChildName_",""trailing"") = "_tTrailing)
								Do %code.WriteLine(" Set pCommandStructure("_tName_",""parameters"","_tChildName_",""required"") = "_tRequired)
								Do:(tDesc'=$$$empty) %code.WriteLine(" Set pCommandStructure("_tName_",""parameters"","_tChildName_",""description"") = "_tDesc)
								Do:(tExample'=$$$empty) %code.WriteLine(" Set pCommandStructure("_tName_",""parameters"","_tChildName_",""example"") = "_tExample)
							}
						}
					}
				}
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()  
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="SetData">
<Description><![CDATA[
Utility method for setting multiple subscripts based on .-delimited <var>pDataName</var>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTargetArray,pDataName,pDataValue,pCustomParam=0</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	If (pCustomParam && (pDataName'[".")) {
		Set pDataName = "zpm."_pDataName
	}
	Set tPieces = $ListFromString(pDataName,".")
	Set tValue = pDataValue
	For i=$ListLength(tPieces):-1:1 {
		Kill tData
		Merge tData($ListGet(tPieces,i)) = tValue
		Kill tValue
		Merge tValue = tData
	}
	Merge pTargetArray("data") = tValue
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.ClassUtils">
<TimeCreated>65797,80971.861669</TimeCreated>

<Method name="OverrideAbstractMembers">
<Description><![CDATA[
Overrides all abstract methods, properties, of <var>pClassName</var>'s parents (removing the [ Abstract ] flag) and saves the class definition.
If <var>pDefaultToSuper</var> is 1, defaults method implementations to call ##super() (either do or quit depending on the return type).
If the parent class method is unimplemented, this won't be done.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName:%String,pDefaultToSuper:%Boolean=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// Ensure class is compiled first.
		$$$ThrowOnError($System.OBJ.Compile(pClassName,"-d"))
		
		Set tClassDef = ##class(%Dictionary.ClassDefinition).%OpenId(pClassName,,.tSC)
		$$$ThrowOnError(tSC)
		
		// $Order over member definitions in compiled class that might be marked as [Abstract]
		// That is: parameters and methods. (I'd thought class queries too, but apparently not.)
		For tMemberType = $$$cCLASSparameter,$$$cCLASSmethod {
			Set tAbstract = $Case(tMemberType,$$$cCLASSparameter:$$$cPARAMabstract,$$$cCLASSmethod:$$$cMETHabstract)
			Set tMember = ""
			For {
				Set tMember = $$$comMemberNext(pClassName,tMemberType,tMember)
				Quit:tMember=""
				
				// Skip non-abstract methods.
				Continue:'$$$comMemberKeyGet(pClassName,tMemberType,tMember,tAbstract)
				
				// Get the origin for abstract methods.
				Set tOrigin = $$$comMemberKeyGet(pClassName,tMemberType,tMember,$$$cXXXXorigin)
				Continue:(tOrigin="%Library.SystemBase")
				Continue:(tOrigin="%Library.RegisteredObject")
				
				// Copy member from origin to pClassName (using Objects)
				If (tMemberType = $$$cCLASSmethod) {
					#dim tSourceMethod,tDestMethod As %Dictionary.MethodDefinition
					Set tSourceMethod = ##class(%Dictionary.MethodDefinition).%OpenId(tOrigin_"||"_tMember)
					Set tDestMethod = tSourceMethod.%ConstructClone()
					Set tDestMethod.Abstract = 0
					If (pDefaultToSuper) && (tDestMethod.Implementation.Size > 0) {
						// Make implementation a call to do or quit ##super()
						Do tDestMethod.Implementation.Clear()
						Set tCommand = $Case(tSourceMethod.ReturnType,"":"Do",:"Quit")
						Do tDestMethod.Implementation.Write($c(9)_" "_tCommand_" ##super(")
						Set tFormalSpecParsed = $$$comMemberKeyGet(tOrigin,$$$cCLASSmethod,tMember,$$$cMETHformalspecparsed)
						Set tPointer = 0
						Set tParamCount = 0
						While $ListNext(tFormalSpecParsed,tPointer,tMethParam) {
							Set tStart = $Case($Increment(tParamCount),1:".",:",.")
							Do tDestMethod.Implementation.Write(tStart_$List(tMethParam))
						}
						Do tDestMethod.Implementation.WriteLine(")")
					}
					$$$ThrowOnError(tClassDef.Methods.Insert(tDestMethod))
				} ElseIf (tMemberType = $$$cCLASSparameter) {
					#dim tSourceParam,tDestParam As %Dictionary.ParameterDefinition
					Set tSourceParam = ##class(%Dictionary.ParameterDefinition).%OpenId(tOrigin_"||"_tMember)
					Set tDestParam = tSourceParam.%ConstructClone()
					Set tDestParam.Abstract = 0
					$$$ThrowOnError(tClassDef.Parameters.Insert(tDestParam))
				}
			}
		}
		
		// Save updated class definition
		$$$ThrowOnError(tClassDef.%Save())
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Document.AbstractDocument">
<Abstract>1</Abstract>
<Owner>%Developer</Owner>
<Super>%Studio.AbstractDocument</Super>
<TimeCreated>65797,80972.105904</TimeCreated>

<Parameter name="EXTENSION">
<Abstract>1</Abstract>
</Parameter>

<Parameter name="INFOGLOBAL">
<Abstract>1</Abstract>
</Parameter>

<Method name="CompileDocument">
<Description>
CompileDocument is called when the document is to be compiled
It has already called the source control hooks at this point</Description>
<FormalSpec><![CDATA[&qstruct:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// SuspendErrorCount allows things this calls to return error statuses without resulting in:
	// ERROR #6084: Unknown errors detected, but no error code reported
	// There may be cases where error statuses are not exceptional cases and are handled properly
	// without needing to return the error status.
	$$$SuspendErrorCount
	
	Set tSC = $$$OK
	Set tInitTLevel = $TLevel
	Try {
		Set tSC = ..%ValidateName(..Name)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tSC = ..OnCompileDocument(.qstruct)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	While ($TLevel > tInitTLevel) { TROLLBACK 1 }
	
	If $Get(qstruct("displaylog")) && $$$ISERR(tSC) {
		Write !,$System.Status.GetErrorText(tSC)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="Save">
<Description>
Save the module definition document.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tName = ..Name
	Set tSC = ..ImportStream(.tName,..Code)
	If $$$ISERR(tSC) {
		Quit tSC
	}
	Set ..Name = tName
	Quit ..Load()
]]></Implementation>
</Method>

<Method name="ExportToXML">
<Description>
Export this document to the current device in XML format</Description>
<FormalSpec>flags:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..Code.LineTerminator=$c(10)
	Do ..Code.Rewind()
	Do ..Code.ReadLine()  // omit xml header
	While '(..Code.AtEnd) {
		Write ..Code.Read(16000)
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ImportFromXML">
<Description>
Import from the stream in XML format</Description>
<FormalSpec>stream:%RegisteredObject,flags:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..Code.Clear()
	Do ..Code.WriteLine("<?xml version=""1.0""?>") //add XML header
	Do ..Code.CopyFrom(stream)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="CompileTime">
<Description>
Return the compile time of routine 'name' in %TimeStamp format. The format should be $zdatetime($horolog,3),
or "" if the routine does not exist.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%TimeStamp</ReturnType>
<Implementation><![CDATA[
	If '..%ValidateName(name) {
		Quit ""
	}
	
	Quit $Get(@..#INFOGLOBAL@($Piece(name,".",1,*-1),"compile"),0)
]]></Implementation>
</Method>

<Method name="%ValidateName">
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	If (("."_$ZConvert($Piece(name,".",*),"U")) '= ..#EXTENSION) {
		Set tSC = $$$ERROR($$$GeneralError,"Invalid name '"_name_"' - doesn't match "_("."_$ZConvert($Piece(name,".",*),"L")))
	}
	Quit tSC
]]></Implementation>
</Method>

<Query name="ItemList">
<Description>
Subclasses must override</Description>
<Type>%SQLQuery</Type>
<SqlProc>1</SqlProc>
<SqlQuery>	select top 0 null,null</SqlQuery>
<Parameter name="ROWSPEC" value="name:%String,modified:%TimeStamp"/>
</Query>

<Query name="List">
<Type>%Query</Type>
<FormalSpec>Directory:%String,Flat:%Boolean,System:%Boolean</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="name:%String,modified:%TimeStamp,size:%Integer,directory:%String"/>
</Query>

<Method name="ListExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,Directory:%String,Flat:%Boolean,System:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If (Directory '= "") Set qHandle = "" Quit $$$OK
	Set tSC = $$$OK
	Set tStmt = ##class(%SQL.Statement).%New()
	Set tSC = tStmt.%PrepareClassQuery($classname(),"ItemList")
	If $$$ISERR(tSC) {
		Quit tSC
	}
	Set qHandle = tStmt.%Execute()
	If (qHandle.%SQLCODE < 0) {
		Set tSC = $$$ERROR($$$SQLCode,qHandle.%SQLCODE,qHandle.%Message)
	}
	If $$$ISERR(tSC) {
		Quit tSC
	}
	If 'qHandle.%Next(.tSC) {
		Set qHandle = ""
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ListFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>ListExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:qHandle="" $$$OK
	Set Row = $ListBuild(qHandle.%GetData(1)_..#EXTENSION,qHandle.%GetData(2),1000,"")
	Set AtEnd = 'qHandle.%Next(.tSC)
	Quit tSC
]]></Implementation>
</Method>

<Method name="ListClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>ListExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Document.AbstractStream">
<Abstract>1</Abstract>
<Super>%Persistent</Super>
<TimeCreated>65797,80972.129114</TimeCreated>
<NoExtent>1</NoExtent>

<Index name="Name">
<Properties>Name</Properties>
<Unique>1</Unique>
</Index>

<Property name="Name">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100"/>
</Property>

<Property name="Contents">
<Type>%Stream.FileCharacter</Type>
</Property>

<Property name="Hash">
<Type>%Binary</Type>
</Property>

<Property name="LastModifiedTimestamp">
<Type>%TimeStamp</Type>
</Property>

<Method name="NameSet">
<FormalSpec>val:%ZPM.cache.RawString</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%Name = $$$lcase(val)
	Return $$$OK
]]></Implementation>
</Method>

<Method name="%OnAddToSaveSet">
<Description><![CDATA[
This callback method is invoked when the current object is added to the SaveSet,
either because %Save() was invoked on this object or on an object that references this object.
%OnAddToSaveSet can modify the current object. It can also add other objects to the current
SaveSet by invoking %AddToSaveSet or remove objects by calling %RemoveFromSaveSet.

<P>If this method returns an error status then %Save() will fail and the transaction
will be rolled back.]]></Description>
<FormalSpec>depth:%Integer=3,insert:%Integer=0,callcount:%Integer=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// See if the module definition has actually changed
		Set tHash = $System.Encryption.SHA1HashStream(..Contents,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		If (..Hash '= tHash) {
			Set ..Hash = tHash
			Set ..LastModifiedTimestamp = $zdt($h,3)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Document.ErrorMessages">
<Super>%ZPM.PackageManager.Developer.Document.AbstractDocument</Super>
<TimeCreated>65797,80972.087524</TimeCreated>

<Projection name="RegisterExtension">
<Type>%Projection.StudioDocument</Type>
<Parameter name="DocumentDescription" value="Localizable Error Messages"/>
<Parameter name="DocumentExtension" value="LOC"/>
<Parameter name="DocumentNew" value="1"/>
<Parameter name="DocumentType" value="xml"/>
<Parameter name="XMLNamespace" value="http://www.intersystems.com/PackageManager/ErrorMessages"/>
</Projection>

<Parameter name="EXTENSION">
<Default>.LOC</Default>
</Parameter>

<Parameter name="INFOGLOBAL">
<Default>^ZPM.Dev.Doc.ErrorMessages</Default>
</Parameter>

<Method name="Load">
<Description><![CDATA[
Load the error message file <property>Name</property> into the stream <property>Code</property>]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tSC = ..%ValidateName(..Name)
		If $$$ISERR(tSC) {
			Quit
		}
		Set tMsgFile = ##class(%ZPM.PackageManager.Developer.ErrorMessages.MessageFileStream).NameOpen($Piece(..Name,".",1,*-1),,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		Set tSC = ..Code.CopyFrom(tMsgFile.Contents)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnCompileDocument">
<FormalSpec><![CDATA[&qstruct:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		TSTART
		Set tMsgFile = ##class(%ZPM.PackageManager.Developer.ErrorMessages.MessageFileStream).NameOpen($Piece(..Name,".",1,*-1),,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tSC = ..Save()
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tTmpFileStream = ##class(%Stream.FileCharacter).%New()
		Set ..Code.LineTerminator = $c(10)
		Do ..Code.Rewind()
		Do ..Code.ReadLine()  // omit xml header
		While '(..Code.AtEnd) {
			Set tSC = tTmpFileStream.Write(..Code.Read(16000))
			If $$$ISERR(tSC) {
				Quit
			}
		}
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tSC = tTmpFileStream.%Save()
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set file = tTmpFileStream.Filename
		
		// Copied from HSLIB error load process
		Set tSC=$$Import^%occMsgXML(file,.domains,1)
		If $$$ISERR(tSC) {
			Quit
		}

		// Belt and suspenders:
		// Generate include files with all the plausible names.
		// This needs to be improved at some point..
		Set errdomains=""
		Set domain="" For {
			Set domain=$O(domains(domain)) Quit:domain=""
			// Generate the include
			Set errdomains = errdomains_$lb(domain)
		}
		Do GenerateInclude^%occMsgXML(tMsgFile.Name,0,$lts(errdomains),1)
		
		Set @..#INFOGLOBAL@("compile",tMsgFile.Name) = $zdt($zts,3)
		TCOMMIT
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ImportStream">
<Description>
Save the message file document from stream to database.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String,pStream:%GlobalCharacterStream</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tInitTLevel = $TLevel
	Try {
		TSTART
		Set tSC = ..%ValidateName(pName)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tName = $Piece(pName,".",1,*-1)
		If ##class(%ZPM.PackageManager.Developer.ErrorMessages.MessageFileStream).NameExists(tName) {
			Set tMsgFile = ##class(%ZPM.PackageManager.Developer.ErrorMessages.MessageFileStream).NameOpen(tName,.tSC)
			If $$$ISERR(tSC) {
				Quit
			}
		} Else {
			Set tMsgFile = ##class(%ZPM.PackageManager.Developer.ErrorMessages.MessageFileStream).%New()
			Set tMsgFile.Name = tName
		}
		
		Set tSC = tMsgFile.Contents.CopyFrom(pStream)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tSC = tMsgFile.%Save()
		If $$$ISERR(tSC) {
			Quit
		}
		TCOMMIT
	} Catch e {
		Set tSC = e.AsStatus()
	}
	While ($TLevel > tInitTLevel) { TROLLBACK 1 }
	Quit tSC
]]></Implementation>
</Method>

<Method name="Delete">
<Description><![CDATA[
Delete the message file <var>name</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tInitTLevel = $TLevel
	Try {
		Set tSC = ..%ValidateName(name)
		If $$$ISERR(tSC) {
			Quit
		}
		Set tName = $Piece(name,".",1,*-1) // Strip extension
		TSTART
		Set tSC = ##class(%ZPM.PackageManager.Developer.ErrorMessages.MessageFileStream).NameDelete(tName)
		$$$ThrowOnError(tSC)
		Set tName = tName_".inc"
		If ##class(%Library.Routine).Exists(tName) {
			Set tSC = ##class(%Library.Routine).Delete(tName)
			$$$ThrowOnError(tSC)
		}
		TCOMMIT
	} Catch e {
		Set tSC = e.AsStatus()
	}
	While ($TLevel > tInitTLevel) { TROLLBACK 1 }
	Quit tSC
]]></Implementation>
</Method>

<Method name="TimeStamp">
<Description>
Return the timestamp of schema category 'name' in %TimeStamp format, i.e. $zdatetime($horolog,3).
This is used to determine if the category has been updated on the server and so needs reloading into Studio.
So the format should be $zdatetime($horolog,3), or "" if the category does not exist.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%TimeStamp</ReturnType>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	If '..%ValidateName(name) {
		Quit ""
	}
	
	Set tStamp = ""
	Set tNameNoExt = $Piece(name,".",1,*-1)
	Set tMsgFile = ##class(%ZPM.PackageManager.Developer.ErrorMessages.MessageFileStream).NameOpen(tNameNoExt)
	If $IsObject(tMsgFile) {
		Set tStamp = tMsgFile.LastModifiedTimestamp
	}
	Quit tStamp
]]></Implementation>
</Method>

<Method name="Exists">
<Description>
Return 1 if the given document exists and 0 if it does not.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tExists = 0
	Try {
		Set tSC = ..%ValidateName(name)
		If $$$ISERR(tSC) {
			Quit
		}
		Set tExists = ##class(%ZPM.PackageManager.Developer.ErrorMessages.MessageFileStream).NameExists($Piece(name,".",1,*-1))
	} Catch e {
		Set tExists = 0
	}
	Quit tExists
]]></Implementation>
</Method>

<Query name="ItemList">
<Description>
Subclasses must override</Description>
<Type>%SQLQuery</Type>
<SqlProc>1</SqlProc>
<SqlQuery>	select Name, LastModifiedTimestamp from %ZPM_PackageManager_Developer_ErrorMessages.MessageFileStream</SqlQuery>
<Parameter name="ROWSPEC" value="name:%String,modified:%TimeStamp"/>
</Query>

<Method name="ImportFromXML">
<Description>
Import from the stream in XML format</Description>
<FormalSpec>stream:%RegisteredObject,flags:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..Code.Clear()
	Do ..Code.WriteLine("<?xml version=""1.0""?>") //add XML header
	Do ..Code.CopyFrom(stream)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetOther">
<Description>
Return other document types that this is related to.
Passed a name and you return a comma separated list of the other documents it is related to
or "" if it is not related to anything. Note that this can be passed a document of another type
for example if your 'test.XXX' document creates a 'test.INT' routine then it will also be called
with 'test.INT' so you can return 'test.XXX' to complete the cycle.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Name:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tOther = ""
	Set tName = $Piece(Name,".",1,*-1)
	Set tExt = $Piece(Name,".",*)
	If (tExt = "LOC") {
		Set tExpected = tName_".INC"
		If ##class(%Routine).Exists(tExpected) {
			Set tOther = tExpected
		}
	} ElseIf (tExt = "INC") {
		// Not actually supported in Studio, but it's still correct.
		Set tExpected = tName_".LOC"
		If ..Exists(tExpected) {
			Set tOther = tExpected
		}
	}
	Quit tOther
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Document.Module">
<IncludeCode>%ZPM.PackageManager.Common,%occErrors</IncludeCode>
<Super>%ZPM.PackageManager.Developer.Document.AbstractDocument</Super>
<TimeCreated>65797,80972.129261</TimeCreated>

<Projection name="RegisterExtension">
<Type>%Projection.StudioDocument</Type>
<Parameter name="DocumentDescription" value="Application Module"/>
<Parameter name="DocumentExtension" value="ZPM"/>
<Parameter name="DocumentNew" value="1"/>
<Parameter name="DocumentType" value="xml"/>
<Parameter name="XMLNamespace" value="http://www.intersystems.com/PackageManager"/>
</Projection>

<Parameter name="EXTENSION">
<Default>.ZPM</Default>
</Parameter>

<Parameter name="INFOGLOBAL">
<Default>^ZPM.Dev.Doc.Module</Default>
</Parameter>

<Method name="Load">
<Description><![CDATA[
Load the module definition <property>Name</property> into the stream <property>Code</property>]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$SuspendErrorCount
	Set tSC = $$$OK
	Try {
		Set tSC = ..%ValidateName(..Name)
		If $$$ISERR(tSC) {
			Quit
		}
		Set tName = $Piece(..Name,".",1,*-1)
		Set tModStream = ##class(%ZPM.PackageManager.Developer.Document.ModuleStream).NameOpen(tName,,.tSC)
		If $$$ISERR(tSC) && ($Piece($System.Status.GetErrorCodes(tSC),",") = $$$KeyValueNotFoundOpen) {
			Set tSC = $$$OK
			
			// Fall back to direct rendering of XML from persistent object
			Set tModule = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(tName,,.tSC)
			If $$$ISERR(tSC) {
				Quit
			}
			
			Do ..Code.WriteLine("<?xml version=""1.0""?>")
			Set tSC = tModule.XMLExportToStream(..Code,,"literal,indent")
			If $$$ISERR(tSC) {
				Quit
			}
		} Else {
			Set tSC = ..Code.CopyFrom(tModStream.Contents)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="Save">
<Description>
Save the module definition document.</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tName = ..Name
	Set tSC = ..ImportStream(.tName,..Code)
	If $$$ISERR(tSC) {
		Quit tSC
	}
	Set ..Name = tName
	Quit ..Load()
]]></Implementation>
</Method>

<Method name="UpdatePersistentFromStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>pStream:%ZPM.PackageManager.Developer.Document.ModuleStream,*pModule:%ZPM.PackageManager.Developer.Module</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pModule = $$$NULLOREF
	Try {
		New $$$ZPMStudioDocumentModule
		If ##class(%ZPM.PackageManager.Developer.Module).NameExists(pStream.Name) {
			Set pModule = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(pStream.Name,,.tSC)
			If $$$ISERR(tSC) {
				Quit
			}
		} Else {
			Set pModule = ##class(%ZPM.PackageManager.Developer.Module).%New()
		}
		
		If (pStream.Contents.Size = 0) {
			Set pModule.Name = pStream.Name
			Set pModule.VersionString = "0.0.1+snapshot"
		} Else {
			Set tReader = ##class(%XML.Reader).%New()
			Do pStream.Contents.Rewind()
			Set tSC = tReader.OpenStream(pStream.Contents)
			If $$$ISERR(tSC) {
				Quit
			}
			
			// Dependencies and Resources will be re-populated upon import.
			Do pModule.Dependencies.Clear()
			Do pModule.Resources.Clear()
			Do pModule.Defaults.Clear()
			Do pModule.Mappings.Clear()
			Do pModule.API.Clear()
			Do pModule.Invokes.Clear()
			
			If (pModule.%Id() '= "") {
				// Save to prevent unique index violations on re-insert of things that weren't actually removed.
				// At some point a more robust approach would be to match existing items in collections/relationships by such unique indices.
				Set tSC = pModule.%Save()
				If $$$ISERR(tSC) {
					Quit
				}
			}
			
			Set $$$ZPMStudioDocumentModule = pModule //Stash for use in %ZPM.PackageManager.Developer.Module:XMLNew
			Do tReader.Correlate("Module","%ZPM.PackageManager.Developer.Module")
			Do tReader.Next(.tModule,.tSC)
			If $$$ISERR(tSC) {
				Quit
			}
			
			If (pStream.Name '= pModule.Name) {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Module document name '%1' and module name in manifest '%2' must be the same.",pStream.Name,tModule.Name))
				Quit
			}
		}
		
		Set tSC = pModule.%Save()
		If $$$ISERR(tSC) {
			Quit
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnCompileDocument">
<FormalSpec><![CDATA[&qstruct:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tNameNoExt = $Piece(..Name,".",1,*-1)
		Set tModStream = ##class(%ZPM.PackageManager.Developer.Document.ModuleStream).NameOpen(tNameNoExt,,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Do tModStream.Contents.Clear()
		Set tSC = tModStream.Contents.CopyFrom(..Code)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tSC = ..UpdatePersistentFromStream(tModStream,.tModule)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set ..Name = tModule.Name_..#EXTENSION
		
		Set tSC = tModule.%Compile()
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set @..#INFOGLOBAL@("compile",tModStream.Name) = $zdt($zts,3)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ImportStream">
<Description>
Save the module definition document from stream to database.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String,pStream:%GlobalCharacterStream</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tInitTLevel = $TLevel
	Try {
		Set tSC = ..%ValidateName(pName)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tName = $Piece(pName,".",1,*-1)
		If ##class(%ZPM.PackageManager.Developer.Document.ModuleStream).NameExists(tName) {
			Set tModStream = ##class(%ZPM.PackageManager.Developer.Document.ModuleStream).NameOpen(tName,.tSC)
			If $$$ISERR(tSC) {
				Quit
			}
		} Else {
			Set tModStream = ##class(%ZPM.PackageManager.Developer.Document.ModuleStream).%New()
			Set tModStream.Name = tName
		}
		
		Do tModStream.Contents.Clear()
		Do pStream.Rewind()
		While '(pStream.AtEnd) {
			Set tSC = tModStream.Contents.Write(pStream.Read(16000))
			If $$$ISERR(tSC) {
				Quit
			}
		}
		If $$$ISERR(tSC) {
			Quit
		}
		
		TSTART
		Set tSC = tModStream.%Save()
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tSC = ..UpdatePersistentFromStream(tModStream,.tModule)
		If $$$ISERR(tSC) {
			Quit
		}
		TCOMMIT
	} Catch e {
		Set tSC = e.AsStatus()
	}
	While ($TLevel > tInitTLevel) { TROLLBACK 1 }
	Quit tSC
]]></Implementation>
</Method>

<Method name="Delete">
<Description><![CDATA[
Delete the module definition <var>name</var>.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tSC = ..%ValidateName(name)
		If $$$ISERR(tSC) {
			Quit
		}
		Set tSC = ##class(%ZPM.PackageManager.Developer.Document.ModuleStream).NameDelete($Piece(name,".",1,*-1))
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="TimeStamp">
<Description>
Return the timestamp of schema category 'name' in %TimeStamp format, i.e. $zdatetime($horolog,3).
This is used to determine if the category has been updated on the server and so needs reloading into Studio.
So the format should be $zdatetime($horolog,3), or "" if the category does not exist.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%TimeStamp</ReturnType>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	If '..%ValidateName(name) {
		Quit ""
	}
	
	Set tStamp = ""
	Set tNameNoExt = $Piece(name,".",1,*-1)
	Set tModStream = ##class(%ZPM.PackageManager.Developer.Document.ModuleStream).NameOpen(tNameNoExt)
	If $IsObject(tModStream) {
		Set tStamp = tModStream.LastModifiedTimestamp
	} Else {
		Set tModule = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(tNameNoExt)
		If $IsObject(tModule) {
			Set tStamp = tModule.LastModifiedTimestamp
		}
	}
	Quit tStamp
]]></Implementation>
</Method>

<Method name="Exists">
<Description>
Return 1 if the given document exists and 0 if it does not.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tExists = 0
	Try {
		Set tSC = ..%ValidateName(name)
		If $$$ISERR(tSC) {
			Quit
		}
		Set tName = $Piece(name,".",1,*-1)
		Set tExists = ##class(%ZPM.PackageManager.Developer.Document.ModuleStream).NameExists(tName)
			|| ##class(%ZPM.PackageManager.Developer.Module).NameExists(tName)
	} Catch e {
		Set tExists = 0
	}
	Quit tExists
]]></Implementation>
</Method>

<Query name="ItemList">
<Description>
Subclasses must override</Description>
<Type>%SQLQuery</Type>
<SqlProc>1</SqlProc>
<SqlQuery>	select Name, LastModifiedTimestamp from %ZPM_PackageManager_Developer_Document.ModuleStream
	union
	select Name, LastModifiedTimestamp from %ZPM_PackageManager_Developer."Module"
		where Name not in (select Name from %ZPM_PackageManager_Developer_Document.ModuleStream)</SqlQuery>
<Parameter name="ROWSPEC" value="name:%String,modified:%TimeStamp"/>
</Query>

<Method name="Lock">
<Description>
Lock the current routine, default method just unlocks the ^ROUTINE global with the name of the routine.
If it fails then return a status code of the error, otherise return $$$OK</Description>
<FormalSpec>flags:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	If ..Locked Set ..Locked=..Locked+1 Quit $$$OK
	If ##class(%ZPM.PackageManager.Developer.Document.ModuleStream).NameExists($Piece(..Name,".",1,*-1),.tID) {
		Set tSC = ##class(%ZPM.PackageManager.Developer.Document.ModuleStream).%LockId(tID)
	}
	Set ..Locked=1
	Quit tSC
]]></Implementation>
</Method>

<Method name="Unlock">
<Description>
Unlock the current routine, default method just unlocks the ^ROUTINE global with the name of the routine</Description>
<FormalSpec>flags:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	If ##class(%ZPM.PackageManager.Developer.Document.ModuleStream).NameExists($Piece(..Name,".",1,*-1),.tID) {
		Set tSC = ##class(%ZPM.PackageManager.Developer.Document.ModuleStream).%UnlockId(tID)
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ExportToXML">
<Description>
Export this document to the current device in XML format</Description>
<FormalSpec>flags:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tXSL=##class(%Dictionary.CompiledXData).%OpenId(..%ClassName(1)_"||ExternalXSL").Data

	Set tSC = ##class(%XML.XSLT.Transformer).TransformStream(..Code, tXSL, .tOutput)
	If $$$ISERR(tSC) Quit tSC
	
	Set tSC = ##class(%XML.Document).GetDocumentFromStream(tOutput, .tDoc)
	If $$$ISERR(tSC) Quit tSC
	Set tXML = ##class(%XML.Writer).%New()
	Set tXML.NoXMLDeclaration = 1
	Set tXML.Indent = 2
	Set tSC = tXML.Document(tDoc)
	If $$$ISERR(tSC) Quit tSC
	Do tXML.OutputToDevice()
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ImportFromXML">
<Description>
Import from the stream in XML format</Description>
<FormalSpec>stream:%RegisteredObject,flags:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tXSL = ##class(%Dictionary.CompiledXData).%OpenId(..%ClassName(1)_"||InternalXSL").Data

	Set tSC = ##class(%XML.XSLT.Transformer).TransformStream(stream, tXSL, .tOutput)
	If $$$ISERR(tSC) Quit tSC
  #; do tOutput.OutputToDevice()
	
	Do ..Code.Clear()
	#; Do ..Code.WriteLine("<?xml version=""1.0""?>") //add XML header
	Do ..Code.CopyFrom(tOutput)

	Quit $$$OK
]]></Implementation>
</Method>

<XData name="ExternalXSL">
<Data><![CDATA[
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:output omit-xml-declaration="yes" method="xml" encoding="utf-8" indent="yes" />
  <xsl:strip-space elements="*" />
  <xsl:template match="Resources">
    <xsl:apply-templates select="*" />
  </xsl:template>
  <xsl:template match="@*|node()">
    <xsl:copy>
      <xsl:apply-templates select="@*|node()" />
    </xsl:copy>
  </xsl:template>
  <xsl:template name="resource">
    <xsl:copy-of select="@*"/>
    <xsl:for-each select="*">
      <xsl:attribute name="{@Name}">
        <xsl:value-of select="text()" />
      </xsl:attribute>
    </xsl:for-each>
  </xsl:template>
  <xsl:template match="Resource[@ProcessorClass]">
    <xsl:element name="{@ProcessorClass}">
      <xsl:attribute name="Name">
        <xsl:value-of select="@Name" />
      </xsl:attribute>
      <xsl:call-template name="resource" />
    </xsl:element>
  </xsl:template>
  <xsl:template match="Resource[not(@ProcessorClass)]">
    <xsl:element name="Resource">
      <xsl:call-template name="resource" />
    </xsl:element>
  </xsl:template>
</xsl:stylesheet>
]]></Data>
</XData>

<XData name="InternalXSL">
<Data><![CDATA[
<xsl:stylesheet version="1.0" xmlns:ext="http://exslt.org/common" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:output omit-xml-declaration="yes" method="xml" encoding="utf-8" indent="yes" />
  <xsl:strip-space elements="*" />
	
  <xsl:variable name="vrtfPass1">
    <xsl:apply-templates />
  </xsl:variable>
  <xsl:template match="@*|node()">
    <xsl:copy>
      <xsl:apply-templates select="@*|node()" />
    </xsl:copy>
  </xsl:template>
  <xsl:template match="@*|node()" mode="pass2">
    <xsl:copy>
      <xsl:apply-templates select="@*|node()" mode="pass2" />
    </xsl:copy>
  </xsl:template>
  <xsl:template name="attributes">
    <xsl:param name="except" />
    <xsl:for-each select="@*">
      <xsl:element name="Attribute">
        <xsl:attribute name="Name">
          <xsl:choose>
            <xsl:when test="name()='SourcePath'">Path</xsl:when>
            <xsl:when test="name()='DeployPath'">Directory</xsl:when>
            <xsl:otherwise><xsl:value-of select="name()" /></xsl:otherwise>
          </xsl:choose>
        </xsl:attribute>
        <xsl:value-of select="." />
      </xsl:element>
    </xsl:for-each>
  </xsl:template>
  <xsl:template name="resource">
    <xsl:param name="name" />
		<xsl:element name="Resource">
			<xsl:copy-of select="@*"/>
			<xsl:if test="not(name()='Resource')">
				<xsl:attribute name="ProcessorClass">
					<xsl:value-of select="name()" />
				</xsl:attribute>
      </xsl:if>
      <xsl:attribute name="Name">
        <xsl:value-of select="@*[name()=$name]" />
      </xsl:attribute>
      <xsl:call-template name="attributes">
        <xsl:with-param name="except" select="$name" />
      </xsl:call-template>
    </xsl:element>
  </xsl:template>
  <xsl:template match="Resources">
    <xsl:apply-templates select="*" />
  </xsl:template>
  <xsl:template match="Module/*[@Name]">
    <xsl:call-template name="resource">
      <xsl:with-param name="name" select="'Name'" />
    </xsl:call-template>
  </xsl:template>
  <xsl:template match="Module/*[@Path]">
    <xsl:call-template name="resource">
      <xsl:with-param name="name" select="'Path'" />
    </xsl:call-template>
  </xsl:template>
  <xsl:template match="Module/*[@SourcePath]">
    <xsl:call-template name="resource">
      <xsl:with-param name="name" select="'SourcePath'" />
    </xsl:call-template>
  </xsl:template>
  <xsl:template match="Module/*[@Url and not(@SourcePath) and not(@Path)] ">
    <xsl:call-template name="resource">
      <xsl:with-param name="name" select="'Url'" />
    </xsl:call-template>
  </xsl:template>
  <xsl:template match="Module/Invoke">
    <xsl:element name="Invokes">
      <xsl:copy-of select="." />
    </xsl:element>
  </xsl:template>
  <xsl:template match="Module/Default|Module/Parameter">
    <xsl:element name="Defaults">
      <xsl:element name="Default">
        <xsl:copy-of select="./@*" />
      </xsl:element>
    </xsl:element>
  </xsl:template>
  <xsl:template match="Module/Resource">
    <xsl:call-template name="resource">
      <xsl:with-param name="name" select="'Name'" />
    </xsl:call-template>
	</xsl:template>
	<xsl:template match="Module" mode="pass2">
    <xsl:copy>
      <xsl:apply-templates select="./@*" mode="pass2" />
      <xsl:apply-templates mode="pass2" />
      <xsl:element name="Resources">
        <xsl:for-each select="Resource">
          <xsl:copy-of select="." />
        </xsl:for-each>
      </xsl:element>
    </xsl:copy>
  </xsl:template>
  <xsl:template match="Resource" mode="pass2"></xsl:template>
  <xsl:template match="/">
    <xsl:apply-templates select="ext:node-set($vrtfPass1)/*" mode="pass2" />
  </xsl:template>
</xsl:stylesheet>
]]></Data>
</XData>
</Class>


<Class name="%ZPM.PackageManager.Developer.Document.ModuleStream">
<Super>%ZPM.PackageManager.Developer.Document.AbstractStream</Super>
<TimeCreated>65797,80972.089965</TimeCreated>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^ZPM.Dev.ModuleDocD</DataLocation>
<DefaultData>ModuleStreamDefaultData</DefaultData>
<IdLocation>^ZPM.Dev.ModuleDocD</IdLocation>
<IndexLocation>^ZPM.Dev.ModuleDocI</IndexLocation>
<StreamLocation>^ZPM.Dev.ModuleDocS</StreamLocation>
<Data name="ModuleStreamDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>Contents</Value>
</Value>
<Value name="4">
<Value>Hash</Value>
</Value>
<Value name="5">
<Value>LastModifiedTimestamp</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Developer.ErrorMessages.MessageFileStream">
<Super>%ZPM.PackageManager.Developer.Document.AbstractStream</Super>
<TimeCreated>65797,80972.109953</TimeCreated>

<Method name="Convert">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFilePath:%String,pSave:%Boolean=1,*pObject:%ZPM.PackageManager.Developer.ErrorMessages.MessageFileStream</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tFileName = $Piece(##class(%File).GetFilename(pFilePath),".xml")
		Set tSourceStream = ##class(%Stream.FileCharacter).%New()
		Set tSC = tSourceStream.LinkToFile(pFilePath)
		If $$$ISERR(tSC) {
			Quit
		}
		
		If ..NameExists(tFileName) {
			Set pObject = ..NameOpen(tFileName,.tSC)
			If $$$ISERR(tSC) {
				Quit
			}
		} Else {
			Set pObject = ..%New()
			Set pObject.Name = $Piece(##class(%File).GetFilename(pFilePath),"xml")
		}
		Set tSC = pObject.Contents.CopyFrom(tSourceStream)
		If $$$ISERR(tSC) {
			Quit
		}
		
		If (pSave) {
			Set tSC = pObject.%Save()
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	If $$$ISERR(tSC) {
		Set pObject = $$$NULLOREF
	}
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^ZPM.Dev.MsgFileD</DataLocation>
<DefaultData>MessageFileStreamDefaultData</DefaultData>
<IdLocation>^ZPM.Dev.MsgFileD</IdLocation>
<IndexLocation>^ZPM.Dev.MsgFileI</IndexLocation>
<StreamLocation>^ZPM.Dev.MsgFileS</StreamLocation>
<Data name="MessageFileStreamDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>Contents</Value>
</Value>
<Value name="4">
<Value>LastModifiedTimestamp</Value>
</Value>
<Value name="5">
<Value>Hash</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Developer.ErrorMessages.MsgDomain">
<Description>
Registered object representation of a domain in a localized error message document</Description>
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeCreated>65797,80972.14423</TimeCreated>

<Parameter name="NAMESPACE">
<Type>STRING</Type>
<Default>http://www.intersystems.com/PackageManager/ErrorMessages</Default>
</Parameter>

<Property name="Messages">
<Type>%String</Type>
<Collection>array</Collection>
<Parameter name="MAXLEN"/>
<Parameter name="XMLKEYNAME" value="Id"/>
<Parameter name="XMLNAME" value="Message"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%ZPM.PackageManager.Developer.ErrorMessages.MsgFile">
<Description>
Registered object representation of a localized error message document</Description>
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeCreated>65797,80972.186872</TimeCreated>

<Parameter name="NAMESPACE">
<Type>STRING</Type>
<Default>http://www.intersystems.com/PackageManager/ErrorMessages</Default>
</Parameter>

<Property name="Language">
<Type>%String</Type>
<InitialExpression>$$$DefaultLanguage</InitialExpression>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Domains">
<Type>%ZPM.PackageManager.Developer.ErrorMessages.MsgDomain</Type>
<Collection>array</Collection>
<Parameter name="XMLKEYNAME" value="Domain"/>
<Parameter name="XMLNAME" value="MsgDomain"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>
</Class>


<Class name="%ZPM.PackageManager.Developer.File">
<Description>
Wraps a set of more robust file operations</Description>
<TimeCreated>65797,80971.873651</TimeCreated>

<Method name="RemoveDirectoryTree">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRoot:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New %objlasterror
	Set tSC = $$$OK
	Set tBadSC = $$$ERROR($$$GeneralError,$$$FormatText("Error removing directory %1",pRoot))
	Try {
		If $$$isUNIX {
			Kill %objlasterror
			If '##class(%File).RemoveDirectoryTree(pRoot) {
				Set tLastErr = $Get(%objlasterror)
				Set tSC = $$$EMBEDSC(tBadSC,tLastErr)
			}
		} ElseIf $$$isWINDOWS {
			// Handle long directories
			// Based on https://superuser.com/a/620474/227743
			Set tEmptyDir = ##class(%File).NormalizeDirectory(##class(%File).TempFilename()_"dir")
			If '##class(%File).CreateDirectory(tEmptyDir,.tReturn) {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Error creating directory %1: %2",tEmptyDir,$zu(209,tReturn)))
				Quit
			}
			Set pRoot = ##class(%File).NormalizeDirectory(pRoot)
			
			Set tCmd = "ROBOCOPY "_tEmptyDir_" "_pRoot_" /MIR"
			Set tSC = ##class(%ZPM.PackageManager.Developer.Utils).RunCommandViaZF(tCmd,.tLog,.tErr)
			If $$$ISERR(tSC) {
				Quit
			}
			
			// Don't bother checking if these succeed - dirs will be empty so it always will
			Do ##class(%File).RemoveDirectory(pRoot)
			Do ##class(%File).RemoveDirectory(tEmptyDir) 
		}
	} Catch e {
		Set tSC = $$$EMBEDSC(tBadSC,e.AsStatus())
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="CopyDir">
<ClassMethod>1</ClassMethod>
<FormalSpec>pSource:%String,pDest:%String,pDeleteFirst:%Boolean=1,pVerbose:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New %objlasterror
	Set tSC = $$$OK
	Set tBadSC = $$$ERROR($$$GeneralError,$$$FormatText("Error copying directory %1 to %2",pSource,pDest))
	Try {
		If $$$isUNIX {
			Kill %objlasterror
			If '##class(%File).CopyDir(pSource,pDest,1,.tCreated,pDeleteFirst) {
				Set tLastErr = $Get(%objlasterror)
				Set tSC = $$$EMBEDSC(tBadSC,tLastErr)
			}
		} ElseIf $$$isWINDOWS {
			If pDeleteFirst {
				Set tSC = ..RemoveDirectoryTree(pDest)
				If $$$ISERR(tSC) {
					Quit
				}
			}
			Set pSource = ##class(%File).NormalizeDirectory(pSource)
			Set pDest = ##class(%File).NormalizeDirectory(pDest)
			Set tCmd = "ROBOCOPY "_pSource_" "_pDest_" /E"
      Set tSC = ##class(%ZPM.PackageManager.Developer.Utils).RunCommandViaZF(tCmd,.tLog,.tErr)
      If (pVerbose) {
        For i=1:1:$Get(tLog) {
          Write tLog(i),!
        }
      }
		}
	} Catch e {
		Set tSC = $$$EMBEDSC(tBadSC,e.AsStatus())
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="MakeDirectoryWriteable">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDirectory:%String,*pCmd,*pOutputLog,*pErrLog</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pCmd = ""
	Try {
		Kill pOutputLog
		Kill pErrLog
		If $$$isWINDOWS {
			Set pCmd = "attrib -r "_##class(%File).NormalizeDirectory(pDirectory)_"*.* /s"
		} ElseIf $$$isUNIX {
			Set pCmd = "chmod -R 775 "_##class(%File).NormalizeDirectory(pDirectory)
		}
		Set tSC = ##class(%ZPM.PackageManager.Developer.Utils).RunCommandViaZF(pCmd,.pOutputLog,.pErrLog)
		$$$ThrowOnError(tSC)
    if ($get(pErrLog(1))'="") {
      set error = pErrLog(1)
      Throw ##class(%Exception.General).%New(error)
    }
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="FindFiles">
<ClassMethod>1</ClassMethod>
<FormalSpec>pPath:%String,pWildcards:%String="",*pList</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Kill pList
	Set pList = 0
	Set fileSetRS = ##class(%File).FileSetFunc(##class(%File).NormalizeDirectory(pPath), pWildcards, , 1)
	While fileSetRS.%Next() {
		If (fileSetRS.Type = "D") {
			Do ..FindFiles(fileSetRS.Name, pWildcards, .tList)
			for i=1:1:tList {
				Set pList($i(pList)) = tList(i)
			}
		} Else {
			Set pList($i(pList)) = $LISTBUILD(fileSetRS.ItemName, fileSetRS.Name)
		}
	}

	Return pList
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.IConfigurable">
<Description>
Interface for classes that require some level of configuration.
SETTINGS and DESCRIPTION are used to dynamically populate %ZPM.PackageManager.Developer.Extension.PackageManager.UI.Configuration
with all classes that implement IConfigurable.</Description>
<Abstract>1</Abstract>
<TimeCreated>65797,80971.896312</TimeCreated>

<Parameter name="SETTINGS">
<Description>
A delimited string in the format:
Key:Description[|Key:Description...]</Description>
</Parameter>

<Parameter name="DESCRIPTION">
<Description>
A string to show in the grouping of settings for this class</Description>
</Parameter>

<Method name="SettingIsDefined">
<Description><![CDATA[
Returns true if a value is defined for setting <var>pName</var>.]]></Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
</Method>

<Method name="GetSettingValue">
<Description><![CDATA[
Clears vale of setting <var>pName</var>]]></Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
</Method>

<Method name="ClearSettingValue">
<Description><![CDATA[
Clears vale of setting <var>pName</var>]]></Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>

<Method name="SetSettingValue">
<Description><![CDATA[
Sets setting <var>pName</var> to <var>pValue</var>. Should return an error %Status if <var>pValue</var> is invalid.]]></Description>
<Abstract>1</Abstract>
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String,pValue:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
</Method>

<Query name="ListSettings">
<Type>%Query</Type>
<Final>1</Final>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Source:%String,SourceDescription:%String,Name:%String,Description:%String,Defined:%Boolean,Value:%String,IsFirstForSource:%Boolean"/>
</Query>

<Method name="ListSettingsExecute">
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tStmt = ##class(%SQL.Statement).%New()
		Set tSC = tStmt.%PrepareClassQuery("%Dictionary.ClassDefinition","SubclassOf")
		If $$$ISERR(tSC) {
			Quit
		}
		
		#dim tClassRes As %SQL.StatementResult
		Set tClassRes = tStmt.%Execute($classname())
		If (tClassRes.%SQLCODE < 0) {
			Set tSC = $$$ERROR($$$SQLCode,tClassRes.%SQLCODE,tClassRes.%Message)
			Quit
		}
		
		Set qHandle("classes") = tClassRes
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ListSettingsFetch">
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>ListSettingsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		#dim tClassRes As %SQL.StatementResult
		Set tClassRes = qHandle("classes")
		Set tListEnd = 1
		Set tFirstForSource = 0
		
		If $Data(qHandle("settings"),tSettingList) {
			Set tCurrentClass = qHandle("class")
			Set tPointer = qHandle("pointer")
			Set tListEnd = '$ListNext(tSettingList,tPointer,tSetting)
		}
			
		If tListEnd {
			Kill qHandle("class"),qHandle("settings"),qHandle("pointer")
			
			For {
				Set AtEnd = 'tClassRes.%Next(.tSC)
				Quit:AtEnd
				
				$$$ThrowOnError(tSC)
				Set tCurrentClass = tClassRes.%GetData(1)
				Set tSettingList = $ListFromString($Parameter(tCurrentClass,"SETTINGS"),"|")
				Continue:'$ListLength(tSettingList)
				
				Set qHandle("settings") = tSettingList
				Set qHandle("class") = tCurrentClass
				Set tPointer = 0
				Set tFirstForSource = 1
				Set tListEnd = '$ListNext(tSettingList,tPointer,tSetting)
				Quit
			}
		}
		
		If (AtEnd) {
			Quit
		}
		
		Set qHandle("pointer") = tPointer
		
		Set tClassDesc = $Parameter(tCurrentClass,"DESCRIPTION")
		Set tName = $Piece(tSetting,":")
		Set tDesc = $Piece(tSetting,":",2,*)
		Set tIsDefined = $ClassMethod(tCurrentClass,"SettingIsDefined",tName)
		Set tSettingValue = $ClassMethod(tCurrentClass,"GetSettingValue",tName)
		Set Row = $ListBuild(tCurrentClass,tClassDesc,tName,tDesc,tIsDefined,tSettingValue,tFirstForSource)
	} Catch e {
		Write ! zw e w !
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ListSettingsClose">
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>ListSettingsExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.InvokeReference">
<Super>%Persistent,%ZPM.PackageManager.Core.InvokeReference</Super>
<TimeCreated>65797,80971.920684</TimeCreated>

<Property name="Class">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="255"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Method">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="255"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Phase">
<Type>%String</Type>
<InitialExpression>"Configure"</InitialExpression>
<Parameter name="MAXLEN" value="255"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="When">
<Type>%String</Type>
<InitialExpression>"After"</InitialExpression>
<Parameter name="MAXLEN" value="255"/>
<Parameter name="VALUELIST" value=",Before,After"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="CheckStatus">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Arg">
<Type>%String</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Arg"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Module">
<Type>%ZPM.PackageManager.Developer.Module</Type>
<Cardinality>parent</Cardinality>
<Inverse>Invokes</Inverse>
<Relationship>1</Relationship>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Method name="GetArgsArray">
<FormalSpec>pParams,*args</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  Set args = ..Arg.Count()
  For i=1:1:..Arg.Count() {
    Set args(i) = ..Module.%Evaluate(..Arg.GetAt(i), .pParams)
    If (args(i)=$Char(0)) { Set args(i) = "" }
  }
]]></Implementation>
</Method>

<Method name="OnBeforePhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  If (pPhase '= ..Phase) || ("Before" '= ..When) {
	  Quit $$$OK
  }

	Quit ..doInvoke(.pParams)
]]></Implementation>
</Method>

<Method name="OnAfterPhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  If (pPhase '= ..Phase) || ("After" '= ..When) {
	  Quit $$$OK
  }

	Quit ..doInvoke(.pParams)
]]></Implementation>
</Method>

<Method name="doInvoke">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  Set tSC = $$$OK
  Do ..GetArgsArray(.pParams, .args)

  Try {
    If ..CheckStatus {
      Set tSC = $ClassMethod(..Class, ..Method, args...)
    } Else {
      Do $ClassMethod(..Class, ..Method, args...)
    }
  } Catch ex {
    Set tSC = ex.AsStatus()
  }

  Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>{%%PARENT}("Invokes")</DataLocation>
<DefaultData>InvokeReferenceDefaultData</DefaultData>
<IdLocation>^%ZPM.PackageManager360D.ModuleC("Invokes")</IdLocation>
<IndexLocation>^%ZPM.Packa360D.InvokeRefer378FI</IndexLocation>
<StreamLocation>^%ZPM.Packa360D.InvokeRefer378FS</StreamLocation>
<Data name="InvokeReferenceDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Class</Value>
</Value>
<Value name="3">
<Value>Method</Value>
</Value>
<Value name="4">
<Value>Arg</Value>
</Value>
<Value name="5">
<Value>Phase</Value>
</Value>
<Value name="6">
<Value>CheckStatus</Value>
</Value>
<Value name="7">
<Value>When</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Developer.Lifecycle.Abstract">
<Description>
@PublicAPI</Description>
<Abstract>1</Abstract>
<IncludeCode>%syGluedef,%ZPM.PackageManager.Common</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>65797,80972.172051</TimeCreated>

<Parameter name="PHASES">
<Description><![CDATA[
$ListBuild list of phases in this lifecycle. <br />
For each phase name, an instance method named "%<phase name>" must be defined in the class with a return type of %Status.]]></Description>
</Parameter>

<Property name="Module">
<Type>%ZPM.PackageManager.Developer.Module</Type>
<Private>1</Private>
</Property>

<Property name="PhaseList">
<Type>%List</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>pModule:%ZPM.PackageManager.Developer.Module</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set ..Module = pModule
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnBeforePhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnAfterPhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetCompletePhases">
<Description>
This method defines what a complete phase means for a given list of phases</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pOnePhase:%List</FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[	quit pOnePhase
]]></Implementation>
</Method>

<Method name="%DispatchMethod">
<FormalSpec><![CDATA[pMethod:%String,&pParams,Args...]]></FormalSpec>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	if $listfind(..#PHASES,pMethod)=0 do $zu(96,3,$$$ERNOMETHOD,1,"","method "_pMethod_" of class "_$classname())
	quit ..Module.ExecutePhases(..Module.Name,$lb(pMethod),1,.pParams)
]]></Implementation>
</Method>

<Method name="GetDefaultParameters">
<Description>
Merges default parameters into pParams
For now, just looks at ^SYS("PackageManager","DefaultParameters")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pParams,pPhases:%List]]></FormalSpec>
<Implementation><![CDATA[	Merge pParams = ^SYS("PackageManager","DefaultParameters")
]]></Implementation>
</Method>

<Method name="GetDefaultResourceProcessor">
<Description>
Returns the default resource processor class to use for a given resource name.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pResourceName:%String</FormalSpec>
<ReturnType>%Dictionary.CacheClassname</ReturnType>
<Implementation><![CDATA[
	If ($Extract(pResourceName) = "/") {
		Quit ""
	}
	Set tExtension = $Piece(pResourceName,".",*)
	Set tShortName = $Case(tExtension,
		"PKG":"Package",
		"CLS":"Class",
		"INC":"Include",
		"MAC":"Routine",
		"LOC":"LocalizedErrorMessages",
		"GBL":"Global",
		"DFI":"DeepSeeItem",
		"LUT":"Interoperability",
		"X12":"Interoperability",
		"ESD":"Interoperability",
		"DTL":"Class",
		"BPL":"Class",
		:"Document")
	If (tShortName = "") {
		Quit ""
	}
	Quit $$$DefaultProcessorPackageDot_"Default."_tShortName
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Lifecycle.Application">
<Super>%ZPM.PackageManager.Developer.Lifecycle.Base</Super>
<TimeCreated>65797,80972.197963</TimeCreated>

<Parameter name="EXPORTDEPENDENCIES">
<Type>BOOLEAN</Type>
<Default>1</Default>
</Parameter>

<Parameter name="DEPLOYABLE">
<Type>BOOLEAN</Type>
<Default>1</Default>
</Parameter>

<Parameter name="PACKAGING">
<Type>STRING</Type>
<Final>1</Final>
<Default>application</Default>
</Parameter>

<Property name="Payload">
<Type>%Stream.TmpBinary</Type>
<Private>1</Private>
</Property>

<Method name="%Verify">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// TODO: Install application (from ..Payload) in a new namespace
		
		// TODO: Run tests in new application namespace
		
		// Inherited implementation:
		If $$$comClassDefined("HS.Test.Manager") {
			#dim tResource As %ZPM.PackageManager.Developer.ResourceReference
			For i=1:1:..Module.Resources.Count() {
				Set tResource = ..Module.Resources.GetAt(i)
				Continue:(tResource.Scope'="verify")
				
				Set tPrefix = $Piece(tResource.Name,".",1,*-1)
				Set tExt = $Piece(tResource.Name,".",*)
				If (tExt = "CLS") || (tExt = "PKG") {
					Set tOneRunSC = ##class(HS.Test.Manager).Run(tPrefix)
					Set tSC = $$$ADDSC(tSC,tOneRunSC)
				}
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Package">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#define FileTempDir ##class(%SYS.System).TempDirectory()_"/"_##class(%PopulateUtils).StringMin(8,8)

	Set tSC = $$$OK
	Try {
		Set tVerbose = $Get(pParams("Verbose"))
		
		// Export module contents
		Set tSC = ..%Export(.pParams, .tExportDirectory, .tDependencyGraph)
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Initialize and switch to build namespace
		Set tInitNS = $Namespace
		New $Namespace
		Set tSC = ##class(%ZPM.PackageManager.Developer.Build).InitializeBuildNamespace()
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Ensure all resources that are part of the module are swizzled.
		Set tKey = ""
		For {
			Set tResource = ..Module.Resources.GetNext(.tKey)
			Quit:(tKey="")
		}
		
		// Actually switch to build namespace
		Set tSC = ##class(%ZPM.PackageManager.Developer.Build).SwitchToBuildNamespace()
		If $$$ISERR(tSC) {
			Quit
		}
		
		Write:tVerbose !,"Building in namespace: ",$Namespace
		
		// In the build namespace, create a filesystem repository pointing to the export directory.
		// First, remove all filesystem repository.
		Write:tVerbose !,"Clearing FileSystems registry..."
		Set tSC = ##class(%ZPM.PackageManager.Client.FilesystemServerDefinition).%DeleteExtent()
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tFSDef = ##class(%ZPM.PackageManager.Client.FilesystemServerDefinition).%New()
		Set tFSDef.Name = "Build Directory"
		Set tFSDef.Enabled = 1
		Set tFSDef.Snapshots = 1
		Set tFSDef.Prereleases = 1
		Set tFSDef.Root = tExportDirectory_".modules/"
		Set tFSDef.Depth = 1
		Set tSC = tFSDef.%Save()
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Load the export directory for this module
		// LoadNewModule will execute up through the Activate step. (Reload, Validate, Compile, Activate.)
		Kill tParams
		Set tParams("DeveloperMode") = 0
		Set tParams("Verbose") = tVerbose
		Set tSC = ##class(%ZPM.PackageManager.Developer.Utils).LoadNewModule(tExportDirectory,.tParams)
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Retrieve built code database
		Set tWorkingDirectory = ##class(%File).NormalizeDirectory($$$FileTempDir)
		Set tWorkingFile = ##class(%File).NormalizeFilename(..Module.Name_".tgz", tWorkingDirectory)
		If '##class(%File).DirectoryExists(tWorkingDirectory),'##class(%File).CreateDirectory(tWorkingDirectory,.tReturn) {
			Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Could not create directory %1: %2",tWorkingDirectory,tReturn))
			Quit
		}
		
		Set tStream = ##class(%Stream.FileBinary).%New()
		Set tDBDirectory = ##class(%File).NormalizeDirectory("db", tWorkingDirectory)
		If '##class(%File).CreateDirectory(tDBDirectory,.tReturn) {
			Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Could not create directory %1: %2", tDBDirectory, tReturn))
			Quit
		}
		Set tSC = tStream.LinkToFile(##class(%File).NormalizeFilename(tDBDirectory_"CODE.DAT"))
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tSC = ..OnBeforeCaptureDatabase(.pParams)
		
		Set tSC = ##class(%ZPM.PackageManager.Developer.Build).RetrieveBuiltDatabase(.tTempStream)
		If $$$ISERR(tSC) {
			Quit
		}
		Set tSC = tStream.CopyFromAndSave(tTempStream)
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Export module manifest
		Set tSC = $System.OBJ.Export(..Module.Name_".ZPM",tWorkingDirectory_"module.xml", "/diffexport")
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tSC = ..OnBeforeArtifact(tExportDirectory,tWorkingDirectory,.pParams)
		If $$$ISERR(tSC) {
			Quit
		}
		 
		// Package as .tgz
		Set tSC = ##class(%ZPM.PackageManager.Developer.Archive).Create(tWorkingDirectory,tWorkingFile,.tOutput)
		For i=1:1:tOutput {
			Write:tVerbose !,tOutput(i)
		}
		
		Write !,"Application package generated:",!,$C(9),tWorkingFile
		
		Set tSrcFileStream = ##class(%Stream.FileBinary).%New()
		Set tSC = tSrcFileStream.LinkToFile(tWorkingFile)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tSC = ..Payload.CopyFrom(tSrcFileStream)
		If $$$ISERR(tSC) {
			Quit
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Configure">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// First, configure all dependencies in reverse order. (Only applications do this; modules do so at other lifecycle phases.)
		Set tSC = ..Module.BuildDependencyGraph(.tDependencyGraph)
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Sort dependencies by depth.
		Set tKey = ""
		For {
			Set tKey = $Order(tDependencyGraph(tKey),1,tData)
			Quit:tKey=""
			
			Set $ListBuild(tDepth,tServerName,tVersion) = tData
			Set tDepthList(tDepth,$Increment(tDepthList(tDepth))) = tKey
		}
		
		// Actually configure dependencies in reverse order by depth.
		Set tDepth = ""
		For {
			Set tDepth = $Order(tDepthList(tDepth),-1,tCount)
			Quit:tDepth=""
			For i=1:1:tCount {
				Set tModName = tDepthList(tDepth,i)
				Set tModule = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(tModName,,.tSC)
				If $$$ISERR(tSC) {
					Quit
				}
				Kill tParams
				Merge tParams = pParams
				// TODO: Propagate parameters the child module is expecting?
				Set tSC = tModule.Lifecycle.Configure(.tParams)
				If $$$ISERR(tSC) {
					Quit
				}
			}
			If $$$ISERR(tSC) {
				Quit
			}
		}
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Default behavior - invoke this application's installer (to avoid code duplication building installer variable array)
		Set tSC = ##super(.pParams)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnBeforeCaptureDatabase">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tVerbose = $Get(pParams("Verbose"))
		
		// Default implementation: see which resources are expicitly flagged with Deploy = true.
		// Build an array of those, then mark them as deployed.
		Set tSC = ..Module.GetResolvedReferences(.tResourceArray,..#EXPORTDEPENDENCIES,..PhaseList,1,.pDependencyGraph)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tResourceKey = ""
		For {
			Set tResourceKey = $Order(tResourceArray(tResourceKey))
			Quit:(tResourceKey="")
			
			// Skip file resources - these are handled separately;
			// "deployment" is the responsibility of resource processor classes.
			If ($Extract(tResourceKey) = "/") {
				Continue
			}
			
			Kill tResourceInfo
			Merge tResourceInfo = tResourceArray(tResourceKey)
			Set tSC = ..OnBeforeCaptureResource(.tResourceInfo,.tDeploy)
			$$$ThrowOnError(tSC)
			
			If tDeploy {
				Set tName = $Piece(tResourceKey,".",1,*-1)
				Set tExt = $Piece(tResourceKey,".",*)
				If (tExt = "CLS") {
					Set tDeployClassArray($Piece(tResourceKey,".",1,*-1)) = ""
				} ElseIf (tExt = "MAC") || (tExt = "INT") {
					Set tDeployRtnArray(tResourceKey) = ""
				} Else {
					// TODO: Handle making other types deployed?
				}
			}
		}
		
		If $Data(tDeployClassArray) {
			If (tVerbose) {
				Set tClass = ""
				Write !,"Marking classes as deployed:"
				For {
					Set tClass = $Order(tDeployClassArray(tClass))
					Quit:tClass=""
					Write !,$c(9),tClass
				}
			}
			$$$ThrowOnError($System.OBJ.MakeClassDeployed(.tDeployClassArray))
		} ElseIf tVerbose {
			Write !,"No classes to mark as deployed."
		}
		If $Data(tDeployRtnArray) {
			Set tRtn = ""
			For {
				Set tRtn = $Order(tDeployRtnArray(tRtn))
				Quit:tRtn=""
				Write:tVerbose !,"Deploying routine: ",tRtn
				$$$ThrowOnError(##class(%Routine).Delete(tRtn,2))
			}
		} ElseIf tVerbose {
			Write !,"No routines to deploy."
		}
		
		// Ensure that no code is left over in the code database.
		Set tCodeDeployed = $Data(tDeployClassArray) || $Data(tDeployRtnArray)
		If (tCodeDeployed) {
			Set tCodeDatabase = $Piece(##class(%SYS.Namespace).GetRoutineDest(),"^",2)
			Set tCopyDatabase = ##class(%File).NormalizeDirectory(tCodeDatabase_"/comp/")
			
			New $Namespace
			Set $Namespace = "%SYS"
			/*
			Flags - Bit string specifying the following options (Default = 0):
			...
			Bit 2 - If the destination database already exists, do not generate an error.
			...
			Bit 4 - Replace the source database with the destination database after the copy completes. If the source database is cluster mounted or mirrored, this option is not allowed.
			WARNING: If you are replacing the source database with the destination database, you MUST make a backup of your source database before running this method.
			Bit 5 - Set switch 10 (freeze reads and write on the system) for the duration of the copy. Setting this bit will allow the source database to be copied and replaced by the destination database while avoiding having any processes trying to write to the database error with a protect error.
			*/
			Set tFlags = (2**2) + (2**4) + (2**5)
			Set tSC = ##class(SYS.Database).Copy(tCodeDatabase,tCopyDatabase,,.tCopyMsg,tFlags)
			If tVerbose {
				For i=1:1:tCopyMsg {
					Write !,tCopyMsg(i)
				}
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnBeforeCaptureResource">
<FormalSpec><![CDATA[&pResourceInfo,*pDeploy:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// Only deploy things expicitly flagged for deployment.
		Set pDeploy = $Case($Get(pResourceInfo("Deploy")),1:1,:0)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Namespace">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Lifecycle.Base">
<Abstract>1</Abstract>
<Super>%ZPM.PackageManager.Developer.Lifecycle.Abstract</Super>
<TimeCreated>65797,80972.261878</TimeCreated>

<Parameter name="PHASES">
<Expression>$ListBuild("Clean","Reload","*","Validate","ExportData","Compile","Activate","Test","Package","Verify","Register","Publish","Configure","Unconfigure")</Expression>
</Parameter>

<Property name="Payload">
<Type>%Stream.Object</Type>
<Private>1</Private>
</Property>

<Property name="Installer">
<Type>%Stream.TmpCharacter</Type>
<Private>1</Private>
</Property>

<Parameter name="EXPORTDEPENDENCIES">
<Type>BOOLEAN</Type>
<Default>0</Default>
</Parameter>

<Parameter name="DEPOLYABLE">
<Type>BOOLEAN</Type>
<Default>0</Default>
</Parameter>

<Parameter name="PACKAGING">
<Abstract>1</Abstract>
</Parameter>

<Method name="GetCompletePhases">
<Description>
This method defines what a complete phase means for a given list of phases</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPhases:%List</FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	for i=1:1:$ll(pPhases) {
		set tPhasesList = ..GetCompletePhasesForOne($li(pPhases,i))
		for j=1:1:$ll(tPhasesList) set one = $li(tPhasesList,j) if one'="" set tPhasesArray(one) = ""
	}
	set tResultingPhases = ""
	for i=1:1:$ll(..#PHASES) {
		set one = $li(..#PHASES,i) if $d(tPhasesArray(one)) set tResultingPhases = tResultingPhases_$lb(one)
	}
	quit tResultingPhases
]]></Implementation>
</Method>

<Method name="GetCompletePhasesForOne">
<Description>
This method defines what a complete phase means for a given phase</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pOnePhase:%String</FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	quit $case(pOnePhase,
		"Clean":		$lb("Clean"),
		"Reload":		$lb("Reload","*"),
		"Validate":		$lb("Reload","*","Validate"),
		"ExportData":	$lb("ExportData"),
		"Compile":		$lb("Reload","*","Validate","Compile"),
		"Activate":		$lb("Reload","*","Validate","Compile","Activate"),
		"Test":			$lb("Reload","*","Validate","Compile","Activate","Test"),
		"Package":		$lb("Reload","*","Validate","Compile","Activate","Package"),
		"Verify":		$lb("Reload","*","Validate","Compile","Activate","Package","Verify"),
		"Register":		$lb("Reload","*","Validate","Compile","Activate","Package","Register"),
		"Publish":		$lb("Reload","*","Validate","Compile","Activate","Package","Register","Publish"),
		"Configure":	$lb("Configure"),
		"Unconfigure":	$lb("Unconfigure"),
		:				""
	)
]]></Implementation>
</Method>

<Method name="OnBeforeArtifact">
<FormalSpec><![CDATA[pExportDirectory:%String,pWorkingDirectory:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// Notify resource processors
		Set tKey = ""
		For {
			#dim tResource As %ZPM.PackageManager.Developer.ResourceReference
			Set tResource = ..Module.Resources.GetNext(.tKey)
			Quit:(tKey="")
			
			If $IsObject(tResource.Processor) {
				Set tSC = $Method(tResource.Processor,"OnBeforeArtifact",pExportDirectory,pWorkingDirectory,.pParams)
				If $$$ISERR(tSC) {
					Quit
				}
			}
		}
		If $$$ISERR(tSC) {
			Quit
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="CheckBeforeClean">
<FormalSpec><![CDATA[&pParams,*pSkip:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tVerbose = $Get(pParams("Verbose"))
		Set tLevel = $Get(pParams("Clean","Level"),0)
		Set tRecurse = $Get(pParams("Clean","Recurse"),1)
		
		If '$Get(pParams("Clean","Force")) {
			// Check to see if anything depends on this module and return an error status if it does.
			Set tSC = ##class(%ZPM.PackageManager.Developer.Utils).GetDependentsList(.tList,,..Module.Name)
			If $$$ISERR(tSC) {
				Quit
			}
			
			Set tModList = ""
			For i=1:1:tList.Count() {
				Set tName = tList.GetAt(i).Name
				If '$Data(pParams("Clean","Cycle",tName)) {
					Set tModList = tModList_$ListBuild(tName)
				}
			}
			
			If ($ListLength(tModList) > 0) {
				If (tLevel > 0) && tVerbose {
					Write !,"[",..Module.Name,"]",$c(9),"Clean SKIP - required by ",$ListLength(tModList),
						" other module",$Case($ListLength(tModList),1:"",:"s"),". (",$ListToString(tModList,"; "),")"
					Set pSkip = 1
					Set pParams("Clean","Skip",..Module.Name) = ""
					Quit
				}
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Clean">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pParams("Clean","Cycle",..Module.Name) = ""
		
		Set tVerbose = $Get(pParams("Verbose"))
		Set tPurge = $Get(pParams("Purge"))
		Set tLevel = $Get(pParams("Clean","Level"),0)
		Set tRecurse = $Get(pParams("Clean","Recurse"),1)
		
		Set tSC = ..CheckBeforeClean(.pParams,.tSkip)
		If (tSkip) {
			Quit
		}
		
		If (tLevel > 0) {
			Set tKey = ""
			For {
				#dim tResource As %ZPM.PackageManager.Developer.ResourceReference
				Set tResource = ..Module.Resources.GetNext(.tKey)
				Quit:tKey=""

        If $IsObject(tResource.Processor) {
          Do tResource.Processor.OnPhase("Clean",.pParams,.tHandled)
          If (tHandled) {
            Continue
          }
        }
				
				Kill tResourceChildren
				Do tResource.ResolveChildren(.tResourceChildren)
				Set tChildKey = ""
				For {
					Set tChildKey = $Order(tResourceChildren(tChildKey))
					Quit:tChildKey=""
				
					If ($Extract(tChildKey) = "/") || (tChildKey '[ ".") {
						Continue
					}
					
					Set tName = $Piece(tChildKey,".",1,*-1)
					Set tExt = $Piece(tChildKey,".",*)
					Set tDeleteArray(tExt,tName) = ""
				}
			}
			
			If $Data(tDeleteArray("CLS")) {
				Merge tClassArray = tDeleteArray("CLS")
				
				Set tClassKey = ""
				For {
					Set tClassKey = $Order(tClassArray(tClassKey))
					Quit:tClassKey=""
					
					If ##class(%Library.RoutineMgr).IsMapped(tClassKey_".CLS") {
						Continue
					}
					
					If $$$comClassDefined(tClassKey) || $$$defClassDefined(tClassKey) {
						If (tPurge)&&($CLASSMETHOD(tClassKey, "%Extends", "%Persistent")) {
							Set tPurgeSC = $CLASSMETHOD(tClassKey, "%KillExtent")
							If $$$ISERR(tPurgeSC) {
								Write !,"WARN: "_$System.Status.GetErrorText(tPurgeSC)
							}
						}
						Set tDelSC = $System.OBJ.UnCompile(tClassKey)
						Set tDelSC = $System.OBJ.Delete(tClassKey,$Select(tVerbose:"d",1:"-d"))
						If $$$ISERR(tDelSC) {
							Write !,"WARN: "_$System.Status.GetErrorText(tDelSC)
						}
					}
				}
				Kill tDeleteArray("CLS")
			}
			
			Kill tDeleteArray("PKG") // Handled above due to ResolveChildren
			
			// Clean up other items individually.
			If $Data(tDeleteArray) {
				Set tType = ""
				For {
					Set tType = $Order(tDeleteArray(tType))
					Quit:tType=""
					
					Set tItem = ""
					For {
						Set tItem = $Order(tDeleteArray(tType,tItem))
						Quit:tItem=""
						
						Set tFullName = tItem_"."_tType
						
						If ##class(%Library.RoutineMgr).IsMapped(tFullName) {
							Continue
						}
						
						Set tDelSC = ##class(%Library.RoutineMgr).Delete(tFullName)
						If $$$ISERR(tDelSC) {
							Write !,"WARN: "_$System.Status.GetErrorText(tDelSC)
						}
					}
				}
			}
		}
		
		If tRecurse {
			For i=1:1:..Module.Dependencies.Count() {
				Set tModName = ..Module.Dependencies.GetAt(i).Name
				If $Data(pParams("Clean","Cycle",tModName)) {
					Continue
				}
				ZKill pParams("Clean","Skip",tModName)
				If ##class(%ZPM.PackageManager.Developer.Module).NameExists(tModName) {
					Set tModObj = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(tModName,,.tModSC)
					If $$$ISERR(tModSC) {
						Write !,"WARN: "_$System.Status.GetErrorText(tModSC)
						Continue
					}
					Kill tParams
					Merge tParams = pParams
					ZKill:'tRecurse tParams("Clean","Force")
					Set tParams("Clean","Level") = tLevel + 1
					Set tParams("Clean","Nested") = 1
					Set tSC = tModObj.Lifecycle.Clean(.tParams)
					If $$$ISERR(tSC) {
						Quit
					}
					If '$Data(tParams("Clean","Skip",tModName)) {
						Set tSC = ##class(%ZPM.PackageManager.Developer.Module).NameDelete(tModName)
						If $$$ISERR(tSC) {
							Quit
						}
						Write:tVerbose !,"Deleted ",tModName
					}
				}
			}
			If $$$ISERR(tSC) {
				Quit
			}
		}
		
		If (tLevel > 0) && '$Get(pParams("Clean","Nested"),0) {
			Set tSC = ##class(%ZPM.PackageManager.Developer.Module).NameDelete(..Module.Name)
			If $$$ISERR(tSC) {
				Quit
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%ExportData">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%Configure">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tVerbose = $Get(pParams("Verbose"),0)

		// getting custom parameters from command line or <Default> element
		Do ##class(%ZPM.PackageManager.Developer.ModuleSetting.Default).GetCustomParameters(.customParams,..Module, .pParams)

		If (..Module.InstallerClass '= "") {
			
			Set tDeveloperMode = $Get(pParams("DeveloperMode"),0)
			Set tDatabaseName = $Get(pParams("Configure","DatabaseName"))
			Set tIsUpgrade = $Get(pParams("Configure","IsUpgrade"),0)
			Merge tVars = pParams
			Merge tVars = pParams("Configure","Parameters")
			Kill tVars("Configure","Parameters")
			Set tVars("PackageManager","Lifecycle") = $This
			Set tVars("InstallDir") = ..Module.Root
			
			// Call OnInstallComponent
			Set tSC = $ClassMethod(..Module.InstallerClass,"OnInstallComponent",tDatabaseName,tVerbose,tDeveloperMode,tIsUpgrade)
			If $$$ISERR(tSC) {
				Quit
			}
			
			// Call OnConfigureComponent
			Set tSC = $ClassMethod(..Module.InstallerClass,"OnConfigureComponent",$Namespace,tVerbose,.tVars)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Unconfigure">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (..Module.InstallerClass '= "") {
			Set tVerbose = $Get(pParams("Verbose"),0)
			Set tDeveloperMode = $Get(pParams("DeveloperMode"),0)
			Set tDatabaseName = $Get(pParams("Configure","DatabaseName"))
			Set tIsUpgrade = $Get(pParams("Configure","IsUpgrade"),0)
			Set tPurge = $Get(pParams("Configure","Purge"),0)
			Merge tVars = pParams
			Merge tVars = pParams("Configure","Parameters")
			Kill tVars("Configure","Parameters")
			Set tVars("PackageManager","Lifecycle") = $This
			
			// Call OnUnconfigureComponent
			Set tSC = $ClassMethod(..Module.InstallerClass,"OnUnconfigureComponent",$Namespace,tVerbose,tPurge,.tVars)
			If $$$ISERR(tSC) {
				Quit
			}
			
			// Call OnUnInstallComponent
			Set tSC = $ClassMethod(..Module.InstallerClass,"OnUnInstallComponent",tDatabaseName,tVerbose)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Reload">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tModuleName = ..Module.Name
		Set tDefaultDevMode = $g(^%SYS("ModuleRoot",$namespace,tModuleName,"DeveloperMode"))||$g(^%SYS("ModuleRoot","*",tModuleName,"DeveloperMode"))
		Set tDeveloperMode = +$Get(pParams("DeveloperMode"),tDefaultDevMode)
		Set tSkipScoped = 'tDeveloperMode
		Set tVerbose = $Get(pParams("Verbose"))
		Set tRoot = $g(pParams("RootDirectory"))
		If (tRoot = "") && tDeveloperMode {
			Set tRoot = $g(^%SYS("ModuleRoot",$namespace,tModuleName),$g(^%SYS("ModuleRoot","*",tModuleName)))
		}
		
		// For now, no-op if no root is configured.
		Quit:tRoot=""
		
		Set tRoot = ##class(%File).NormalizeDirectory("",tRoot)
		Set tSC = $system.OBJ.Load(tRoot_"module.xml","/nodisplay",.error,.tLoadedList) quit:$$$ISERR(tSC)
		
		// Validate loaded module
		Set first = $Order(tLoadedList(""))
		If (first = "") {
			Set tSC = $$$ERROR($$$GeneralError,"No module definition found.")
			Quit
		}
		If ($Order(tLoadedList(first)) '= "") {
			Set tSC = $$$ERROR($$$GeneralError,"module.xml is malformed.")
			Quit
		}
		set first = $$$lcase(first)
		If ($Piece(first,".",*) '= "zpm") {
			Set tSC = $$$ERROR($$$GeneralError,"No module definition found.")
			Quit
		}
		If (tModuleName '= $Piece(first,".",1,*-1)) {
			Set tSC = $$$ERROR($$$GeneralError,"Module name mismatch.") Quit
		}
		
		// Set up mappings
		Set tKey = ""
		For {
			Set tMapping = ..Module.Mappings.GetNext(.tKey)
			Quit:tKey=""
			
			Set tName = $Piece(tMapping.Name,".",1,*-1)
			Set tExtension = $Piece(tMapping.Name,".",*)
			Set tSource = tMapping.Source
			
			Set tSC = $Case(tExtension,
				"GBL":##class(%ZPM.PackageManager.Developer.Utils).AddGlobalMapping($namespace,tName,tSource),
				"INC":##class(%ZPM.PackageManager.Developer.Utils).AddRoutineMapping($namespace,tName,"INC",tSource),
				"MAC":##class(%ZPM.PackageManager.Developer.Utils).AddRoutineMapping($namespace,tName,"MAC",tSource),
				"PKG":##class(%ZPM.PackageManager.Developer.Utils).AddPackageMapping($namespace,tName,tSource),
				"":##class(%ZPM.PackageManager.Developer.Utils).AddRoutineMapping($namespace,tName,"ALL",tSource))
			If $$$ISERR(tSC) {
				Quit
			}
		}
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tPreloadRoot = tRoot_"preload"
		If ##class(%File).DirectoryExists(tPreloadRoot) {
			Set tSC = $system.OBJ.LoadDir(tPreloadRoot,$Select(tVerbose:"d",1:"-d")_"/compile",,1)
			If $$$ISERR(tSC) {
				Quit
			}
		} ElseIf tVerbose {
			Write !,"Skipping preload - directory does not exist."
		}
		
		// Reload the module definition
		Set tSC = ..Module.%Reload()
		If $$$ISERR(tSC) {
			Quit
		}
		
		If tDeveloperMode {
			If ..Module.GlobalScope {
				Set ^%SYS("ModuleRoot","*",tModuleName) = tRoot
				// clean up in case GlobalScope is changed in the new version of module.xml
				Kill ^%SYS("ModuleRoot",$namespace,tModuleName)
			} Else {
				Set ^%SYS("ModuleRoot",$namespace,tModuleName) = tRoot
				// clean up in case GlobalScope is changed in the new version of module.xml
				Kill ^%SYS("ModuleRoot","*",tModuleName)
			}
		}
		
		Set ..Module.Root = tRoot
		Set tSC = ..Module.%Save() quit:$$$ISERR(tSC)
		
		Set tGlobalScope = ..Module.GlobalScope && '$Get(pParams("Reload","ForceLocalScope"),0)
		
		// Standard resource processing
		Set tKey = ""
		For {
			Set tResource = ..Module.Resources.GetNext(.tKey)
			Quit:tKey=""
			
			If $IsObject(tResource.Processor) {
				Set tSC = tResource.Processor.OnPhase("Reload",.pParams)
			}
      If $$$ISERR(tSC) {
        Quit
      }
		}
		
	} Catch e {
		Set tSC = e.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="%Validate">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tInitTLevel = $TLevel
	Try {
		TSTART
		Set tSC = ..Module.UpdateAPIDocumentation()
		If $$$ISERR(tSC) {
			Quit
		}

		Set tSC = ..Module.%Save()
		If $$$ISERR(tSC) {
			Quit
		}
		TCOMMIT
	} Catch e {
		Set tSC = e.AsStatus()
	}
	While ($TLevel > tInitTLevel) { TROLLBACK 1 }
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Compile">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tVerbose = $Get(pParams("Verbose"))
		
		// Load dependencies correctly for the requested phases. (This will be a no-op in most cases.)
		Set tSC = ..Module.LoadDependencies(..PhaseList,.pParams)
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Compile items within the module that are compilable using OnPhase
		Set tKey = ""
		For {
			#dim tResource As %ZPM.PackageManager.Developer.ResourceReference
			Set tResource = ..Module.Resources.GetNext(.tKey)
			Quit:tKey=""
			
			Set tHandled = 0
			If $IsObject(tResource.Processor) {
				Do tResource.Processor.OnPhase("Compile",.pParams,.tHandled)
				If (tHandled) {
					Set tHandledMap(tResource.Name) = ""
					Continue
				}
			}
		}
		
		// Build maps of other compilable things
		Set tKey = ""
		For {
			Set tResource = ..Module.Resources.GetNext(.tKey)
			Quit:tKey=""
			
			If '$Data(tHandledMap(tResource.Name)) && $IsObject(tResource.Processor) {
				If tResource.Processor.%IsA("%ZPM.PackageManager.Developer.Processor.AbstractCompilable") {
					Kill tOneResourceList
					Set tOneResourceList(tResource.Name) = ""
					Set tSC = tResource.ResolveChildren(.tOneResourceList)
					If $$$ISERR(tSC) {
						Quit
					}
					
					Set tCompilableMap(tResource.Name) = ""
					
					// Prerequisites
					// Builds two maps:
					// tDependencyMap("<thing to compile first>","<thing dependent on it>") = ""
					// tDependentMap("<dependent thing>","<thing to compile first>") = ""
					Set tCompileAfterList = $ListFromString(tResource.Processor.CompileAfter)
					If (tCompileAfterList '= "") {
						Set tPointer = 0
						While $ListNext(tCompileAfterList,tPointer,tDependency) {
							If '$Data(tHandledMap(tDependency)) {
								Set tDependencyMap(tDependency,tResource.Name) = ""
								Set tDependentMap(tResource.Name,tDependency) = ""
							}
						}
					}
					
					// Compile Flags (second grouping)
					Set tFlags = tResource.Processor.Flags
					Set tFlags = $Case(tFlags,"":"<none>",:tFlags)
					
					Merge tCompileFlagMap(tFlags,tResource.Name) = tOneResourceList
				}
			}
		}
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Ensure there are no CompileAfter dependencies on resources absent from the module.
		Set tKey = ""
		For {
			Set tKey = $Order(tDependencyMap(tKey))
			Quit:tKey=""
			
			If '$Data(tCompilableMap(tKey)) {
				Set tCulprit = $Order(tDependencyMap(tKey,""))
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Resource '%1' cannot compile after nonexistent/non-compilable resource '%2'",tCulprit,tKey))
				Quit
			}
		}
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Compile in multiple passes, grouped by compile flags.
		Set tCompiledSomething = 0
		For {
			If '$Data(tCompilableMap) {
				Quit
			}
			
			Set tCompiledSomething = 0
			Set tFlags = ""
			For {
				Set tFlags = $Order(tCompileFlagMap(tFlags))
				Quit:tFlags=""
				
				// Build array of classes to compile with a given set of compile flags
				Kill tFlagSet
				Merge tFlagSet = tCompileFlagMap(tFlags)
				Set tResourceKey = ""
				Kill tCompileArray
				Set tCompileList = ""
				For {
					Set tResourceKey = $Order(tFlagSet(tResourceKey))
					Quit:tResourceKey=""
					
					If '$Data(tDependentMap(tResourceKey)) {
						Merge tCompileArray = tFlagSet(tResourceKey)
						Set tCompileList = tCompileList_$ListBuild(tResourceKey)
						Kill tCompileFlagMap(tFlags,tResourceKey)
						Kill tCompilableMap(tResourceKey)
					}
				}
				If $$$ISERR(tSC) {
					Quit
				}
				
				// Actually do the compile
				If $Data(tCompileArray) {
					Set tCompiledSomething = 1
					Set tStruct = $Select(tVerbose:"d",1:"-d")_tFlags
					Set tSC = $System.OBJ.CompileList(.tCompileArray,.tStruct)
					If $$$ISERR(tSC) {
						Quit
					}
				}
				
				// Update dependency tracking to reflect that things were compiled.
				// Reminder:
				// tDependencyMap("<thing to compile first>","<thing dependent on it>") = ""
				// tDependentMap("<dependent thing>","<thing to compile first>") = ""
				Set tPointer = 0
				While $ListNext(tCompileList,tPointer,tCompiledResource) {
					Set tDependent = ""
					For {
						Set tDependent = $Order(tDependencyMap(tCompiledResource,tDependent))
						Quit:tDependent=""
						
						Kill tDependentMap(tDependent,tCompiledResource)
					}
					Kill tDependencyMap(tCompiledResource)
				}
			}
			If $$$ISERR(tSC) {
				Quit
			}
			
			// Cycle detection
			If 'tCompiledSomething {
				Set tFailedResources = ""
				Set tResource = ""
				For {
					Set tResource = $Order(tCompilableMap(tResource))
					Quit:tResource=""
					Set tFailedResources = tFailedResources_$ListBuild(tResource)
				}
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Failed to resolve compile order of module resources: %1",$ListToString(tFailedResources,", ")))
				Quit
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Activate">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%Test">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		For i=1:1:..Module.Resources.Count() {
			Set tResource = ..Module.Resources.GetAt(i)
			If $IsObject(tResource.Processor) {
				Set tSC = $$$ADDSC(tSC,tResource.Processor.OnPhase("Test",.pParams))
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Export">
<Description><![CDATA[
Note: This is a utility method, and not a full lifecycle phase at this point.
This method exports the module's resources, based on the mappings defined in ^Sources (by %Reload), to the specified directory.
If no directory is provided, a new temp directory is created (returned by reference).
If dependencies are to be exported, <var>pDependencyGraph</var> is augmented with a "Location" subscript
with the relative path within <var>pTargetDirectory</var> in which the module's contents have been exported.]]></Description>
<FormalSpec><![CDATA[&pParams,&pTargetDirectory:%String,*pDependencyGraph]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#define FileTempDir ##class(%SYS.System).TempDirectory()_"/"_##class(%PopulateUtils).StringMin(8,8)

	Set tSC = $$$OK
	Try {
		Set tVerbose = $Get(pParams("Verbose"))
    Merge tParams = pParams
    		
		Kill pDependencyGraph
		If ($Get(pTargetDirectory) = "") {
			Set pTargetDirectory = $$$lcase(..Module.Name_"-"_..Module.VersionString)
			Set pTargetDirectory = ##class(%File).NormalizeDirectory(pTargetDirectory, $$$FileTempDir)
		}
		
		If '##class(%File).DirectoryExists(pTargetDirectory) {
			Kill %objlasterror
			Set tCreated = ##class(%File).CreateDirectoryChain(pTargetDirectory,.tReturnValue)
			If 'tCreated {
				Set tLastErr = $Get(%objlasterror)
				Set tSC = $$$EMBEDSC($$$ERROR($$$GeneralError,$$$FormatText("Error creating directory %1: %2",pTargetDirectory,tReturnValue)),tLastErr)
				Quit
			}
		}
    Set tParams("ModuleExportPath") = pTargetDirectory
		
		Set tSC = ..Module.GetResolvedReferences(.tResourceArray,..#EXPORTDEPENDENCIES,..PhaseList,1,.pDependencyGraph)
		If $$$ISERR(tSC) {
			Quit
		}
		
		// First pass: if we're exporting dependencies, build an array of modules from which we are deriving things.
		If ..#EXPORTDEPENDENCIES {
			Set tFullResourceName = ""
			For {
				Set tFullResourceName = $Order(tResourceArray(tFullResourceName))
				Quit:(tFullResourceName="")
				
				Set tExt = $Piece(tFullResourceName,".",*)
				Set tName = $Piece(tFullResourceName,".",1,*-1)
				If ($$$ucase(tExt) = "ZPM") {
					If (tName '= ..Module.Name) {
						Set pDependencyGraph(tName,"Location") = ".modules/"_tName_"/"
					}
				}
			}
		}
		
		Set tFullResourceName = ""
		For {
			Set tFullResourceName = $Order(tResourceArray(tFullResourceName),1,tSrcModule)
			If (tFullResourceName = "") {
				Quit
			}
			
			If $Get(tResourceArray(tFullResourceName,"Generated")) Continue
			
			Set tName = $Piece(tFullResourceName,".",1,*-1)
			Set tExt = $Piece(tFullResourceName,".",*)
			
			If '$Data(tResourceArray(tFullResourceName,"RelativePath"),tRelativePath) {
				Set tRelativePath = ..GetResourceRelativePath(tName,tExt)
			}

			If $Get(tResourceArray(tFullResourceName,"Preload")) {
				Set tRelativePath = "preload/"_tRelativePath
			}
			
			If (tExt = "ZPM") && (tName '= ..Module.Name) {
				Set tRelativePath = pDependencyGraph(tName,"Location")_tRelativePath
			} ElseIf (tSrcModule '= "") && (tSrcModule '= ..Module.Name) {
				Set tRelativePath = pDependencyGraph(tSrcModule,"Location")_tRelativePath
			}
			
			Set tFullPath = ##class(%File).NormalizeFilenameWithSpaces(pTargetDirectory_tRelativePath)
			
			#dim tProcessor As %ZPM.PackageManager.Developer.Processor.Abstract
			If $Data(tResourceArray(tFullResourceName,"Processor"),tProcessor) && $IsObject(tProcessor) {
				Kill tItemParams
				Merge tItemParams = tResourceArray(tFullResourceName)
				Set tItemHandled = 0
				Set tSC = tProcessor.OnExportItem(tFullPath,tFullResourceName,.tItemParams,.tParams,.tItemHandled)
				If $$$ISERR(tSC) {
					Quit
				}
				If tItemHandled {
					Continue
				}
			}
			
			If ($Extract(tFullResourceName) = "/") {
				// Resources with paths are relative to the module root and are simply copied to the export directory.
				Set tModule = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(tSrcModule,,.tSC)
				If $$$ISERR(tSC) {
					Quit
				}
				
				If (tModule.Root = "") {
					Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("No module root configured for '%1'",tSrcModule))
					Quit
				}
				
				If '##class(%File).DirectoryExists(tModule.Root) {
					Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Directory %2, listed as root for module '%1', does not exist.",tSrcModule,tModule.Root))
					Quit
				}
				
				Set tSourcePath = ##class(%File).NormalizeFilenameWithSpaces(tModule.Root_tFullResourceName)
				Set tExportPath = ##class(%File).NormalizeFilenameWithSpaces(tFullPath_tFullResourceName)
				Set tSC = $$$OK
				Set tDirectory = ##class(%File).GetDirectory(tExportPath,1)
				If '##class(%File).DirectoryExists(tDirectory) {
					Set tGood = ##class(%File).CreateDirectoryChain(tDirectory,.tReturn)
					If 'tGood {
						Set tLastErr = $Get(%objlasterror)
						Set tSC = $$$EMBEDSC($$$ERROR($$$GeneralError,$$$FormatText("Error creating directory '%1': %2",tDirectory,tReturn)),tLastErr)
						Quit
					}
					Write:tVerbose !,"Created ",tDirectory
				}
				If ##class(%File).DirectoryExists(tSourcePath) {
					// NOTE: Does not overlay directories.
					Set tSourcePath = ##class(%File).NormalizeDirectory(tSourcePath)
					Set tExportPath = ##class(%File).NormalizeDirectory(tExportPath)
					Set tSC = ##class(%ZPM.PackageManager.Developer.File).CopyDir(tSourcePath,tExportPath)
					If $$$ISERR(tSC) {
						Quit
					}
					Write:tVerbose !,tSourcePath," -> ",tExportPath
				} ElseIf ##class(%File).Exists(tSourcePath) {
					Set tGood = ##class(%File).CopyFile(tSourcePath,tExportPath,1,.tReturn)
					If 'tGood {
						Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Error copying file '%1' to '%2': %3",tSourcePath,tExportPath,tReturn))
						Quit
					}
					Write:tVerbose !,tSourcePath," -> ",tExportPath
				}
			} ElseIf (tExt = "CLS") || (tExt = "DFI") ||(tExt = "PRJ") || ($ZConvert($Extract(tFullPath,$length(tFullPath)-2,*),"l")="xml") || (##class(%RoutineMgr).UserType(tFullResourceName)) {
				If '$$$FileExists(tFullPath) {
					Do ##class(%File).CreateDirectoryChain(##class(%File).GetDirectory(tFullPath))
				}
				Write:tVerbose !,"Exported ",tFullResourceName," to ",tFullPath
				Set tSC = $$Export^%occXMLExport(tFullPath,"-d",tFullResourceName)
			} Else {
				Write:tVerbose !,"Exported '",tFullResourceName,"' to ",tFullPath
				Set tSC = $$Export^%apiRTN(tFullResourceName,tFullPath)
			}
			If $$$ISERR(tSC) {
				Quit
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Package">
<Abstract>1</Abstract>
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// TODO: Implement
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Register">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {

		Set tVerbose = $Get(pParams("Verbose"))
		// "Register" just means "Publish to the local repository"
		Set tServer = ##class(%ZPM.PackageManager.Client.LocalServerDefinition).SingletonOpen(1)
    #; Don't care, no local cache, do not register there
    Quit:'$IsObject(tServer)

		Set tIsApplication = ..%IsA("%ZPM.PackageManager.Developer.Lifecycle.Application")
		
		Set tPublishClient = tServer.GetPublishService()
		Set tModule = $Select(tIsApplication:##class(%ZPM.PackageManager.Core.Application).%New(),1:##class(%ZPM.PackageManager.Core.Module).%New())
		Set tModule.Name = ..Module.Name
		If (0 && '..Module.IsLocked()) {
			Set tSC = ..Module.Lock()
			$$$ThrowOnError(tSC)
		}
		Set tModule.VersionString = ..Module.VersionString
		Set tSC = ..Module.XMLExportToStream(tModule.Manifest)
		$$$ThrowOnError(tSC)
		Set tSC = tModule.Payload.CopyFromAndSave(..Payload)
		If $$$ISERR(tSC) {
			Quit
		}
		
		If tIsApplication {
			Do tPublishClient.PublishApplication(tModule)
		} Else {
			Do tPublishClient.PublishModule(tModule)
		}
		
		If $$$ISOK(tSC) {
			Write:tVerbose !,..Module.Name," ",..Module.VersionString," registered to local cache."
		}
	} Catch e {
		If (e.Name["ZSOAP") {
			Set tSC = $Get(%objlasterror,e.AsStatus())
		} Else {
			Set tSC = e.AsStatus()
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Verify">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		New $Namespace
		Set tInitNS = $Namespace
		Set tVerbose = $Get(pParams("Verbose"))
		
		// Create namespace in which to run tests and switch to it.
		$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.Build).InitializeNamespace("VERIFY",tVerbose,.tNewNamespace))
		
		// Map ^UnitTest* from its home in the original namespace to the VERIFY namespace.
		$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.Build).MapGlobalEquivalently("UnitTest*",tInitNS,tNewNamespace))
		
    If (..Payload.Size) {
      // Install this module artifact in the VERIFY namespace.
      Write:tVerbose !,"Installing ",..Module.Name," ",..Module.VersionString," in namespace ",tNewNamespace
      Set $Namespace = tNewNamespace
      Set tTmpStream = ##class(%Stream.FileBinary).%New()
      Do tTmpStream.CopyFromAndSave(..Payload)
      Merge tParams = pParams
      Set tParams("Reload","ForceLocalScope") = 1
      $$$ThrowOnError(##class(%ZPM.PackageManager.Developer.Utils).LoadModuleFromArchive(..Module.Name,..Module.VersionString,tTmpStream,.tParams))
    }
		
		#dim tResource As %ZPM.PackageManager.Developer.ResourceReference
		For i=1:1:..Module.Resources.Count() {
			Set tResource = ..Module.Resources.GetAt(i)
			
			Set tHandled = 0
			If $IsObject(tResource.Processor) {
				Set tSC = $$$ADDSC(tSC,tResource.Processor.OnPhase("Verify",.pParams,.tHandled))
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Publish">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tRelease = $Get(pParams("Release",0))
		Set tServer = ##class(%ZPM.PackageManager.Client.RemoteServerDefinition).DeploymentServerOpen(1,,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tIsApplication = ..%IsA("%ZPM.PackageManager.Developer.Lifecycle.Application")
		
		Set tPublishClient = tServer.GetPublishService()
		Set tModule = $Select(tIsApplication:##class(%ZPM.PackageManager.Core.Application).%New(),1:##class(%ZPM.PackageManager.Core.Module).%New())
		Set tModule.Name = ..Module.Name
		If tRelease && ('..Module.IsLocked()) {
			Set tSC = ..Module.Lock()
			If $$$ISERR(tSC) {
				Quit
			}
		}
		Set tSC = ..%Installer(.pParams)
		If $$$ISERR(tSC) {
			Quit
		}
		Set tModule.VersionString = ..Module.VersionString
		Set tSC = ..Module.XMLExportToStream(tModule.Manifest)
		If $$$ISERR(tSC) {
			Quit
		}
		Set tSC = tModule.Payload.CopyFrom(..Payload)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tSC = tModule.Installer.CopyFrom(..Installer)
		If $$$ISERR(tSC) {
			Quit
		}
		
		If tIsApplication {
			Do tPublishClient.PublishApplication(tModule)
		} Else {
			Do tPublishClient.PublishModule(tModule)
		}
	} Catch e {
		If (e.Name["ZSOAP") {
			Set tSC = $Get(%objlasterror,e.AsStatus())
		} Else {
			Set tSC = e.AsStatus()
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Installer">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If ..Module.Name = "zpm" {
			Write !,"Build Installer for ", ..Module.Name
			Set tSC = ##class(%ZPM.Installer).Make(..Payload, ..Installer)
			If $$$ISERR(tSC) {
				Quit
			}
		}		
	} Catch e {
		Set tSC = e.AsStatus()
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="GetResourceRelativePath">
<Description><![CDATA[
Helper method to get the relative path to the *file* corresponding to a resource (used in %Reload/%Export).
If <var>pExtension</var> is empty, then <var>pResource</var> is interpreted as having an extension.
If <var>pExtension</var> is specified, then <var>pResource</var> is intrepreted as not having an extension.
Note: does not support .PKG
Note: does not yet support CSP/static files resources]]></Description>
<FormalSpec>pResource:%String,pExtension:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If ($Get(pExtension) = "") {
		Set tName = $Piece(pResource,".",1,*-1)
		Set tExtension = $Piece(pResource,".",*)
	} Else {
		Set tName = pResource
		Set tExtension = pExtension
	}
	
	// For static/CSP resources, this is handled separately.
	If ($Extract(pResource_pExtension) = "/") {
		Quit ""
	}

	// Intentionally does not support PKG - classes must be exported individually.
	Set tDirectory = $Case(tExtension,
		"ZPM":"",
		"LOC":"localize/",
		"INC":"inc/",
		"MAC":"mac/",
		"CLS":"cls/",
		"GBL":"gbl/",
		"X12":"i14y/",
		"LUT":"i14y/",
		"ESD":"i14y/",
		"DTL":"cls/",
		"BPL":"cls/",
		: $$$lcase(tExtension)_"/"
		)
		
	Set tFile = $Case(tExtension,
		"ZPM":"module.xml",
		"LOC":$tr(tName,".%","/")_".xml",
		"INC":$tr(tName,".%","/_")_".inc",
		"MAC":$tr(tName,".%","/_")_".mac",
		"CLS":$tr(tName,".%","/")_".cls",
		"DTL":$tr(tName,".%","/")_".cls",
		"BPL":$tr(tName,".%","/")_".cls",
		"GBL":$tr(tName,"%,("")","___")_".xml",
		"DFI":$tr(tName,"-","/")_".dfi",
		: tName _ "." _$$$lcase(tExtension)
		)
	
	Quit tDirectory_tFile
]]></Implementation>
</Method>

<Method name="GetBaseClassForPackaging">
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPackaging:%String,*pBaseClass:%Dictionary.CacheClassname</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pBaseClass = ""
	Try {
		Set tRes = ##class(%SQL.Statement).%ExecDirect(,
			"select BaseClass from %ZPM_PackageManager_Developer_Lifecycle.Base_Packaging(?)",
			pPackaging)
		If (tRes.%SQLCODE < 0) {
			$$$ThrowStatus($$$ERROR($$$SQLCode,tRes.%SQLCODE,tRes.%Message))
		}
		
		If tRes.%Next(.tSC) {
			Set pBaseClass = tRes.%Get("BaseClass")
		}
		$$$ThrowOnError(tSC)
		
		// TODO: Error if no results?
	} Catch e {
		Set pBaseClass = ""
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Query name="Packaging">
<Type>%SQLQuery</Type>
<Final>1</Final>
<FormalSpec>pPackaging:%String=""</FormalSpec>
<SqlProc>1</SqlProc>
<SqlQuery>	select cp._default as Packaging, cd.Name as BaseClass
	from %Dictionary.CompiledClass cd
	join %Dictionary.CompiledParameter cp
	on cp.Parent = cd.Name
		and cp.Name = 'PACKAGING'
	where cd.Name %STARTSWITH '%ZPM.PackageManager.Developer.Lifecycle' -- This is a critical assumption for performance reasons. Full ^oddCOM scans are expensive!
		and cd.PrimarySuper [ '~%ZPM.PackageManager.Developer.Lifecycle.Abstract~'
		and cp.Final = 1
		and cp.Origin = cd.Name
		and (:pPackaging is null or cp._default = :pPackaging)</SqlQuery>
</Query>
</Class>


<Class name="%ZPM.PackageManager.Developer.Lifecycle.DeployedApplication">
<Description>
Application lifecycle that deploys resources in all dependencies by default (unless Deploy="false" is expcitly stated in the dependency)</Description>
<Super>%ZPM.PackageManager.Developer.Lifecycle.Application</Super>
<TimeCreated>65797,80972.204737</TimeCreated>

<Method name="OnBeforeCaptureResource">
<FormalSpec><![CDATA[&pResourceInfo,*pDeploy:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// Override: deploy unless explicitly told not to.
		Set pDeploy = $Case($Get(pResourceInfo("Deploy")),0:0,:1)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Lifecycle.Module">
<Super>%ZPM.PackageManager.Developer.Lifecycle.Base</Super>
<TimeCreated>65797,80972.229726</TimeCreated>

<Property name="Payload">
<Type>%Stream.TmpBinary</Type>
<Private>1</Private>
</Property>

<Parameter name="PACKAGING">
<Type>STRING</Type>
<Final>1</Final>
<Default>module</Default>
</Parameter>

<Method name="%Clean">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tSC = ..CheckBeforeClean(.pParams,.tSkip)
		If (tSkip) {
			Quit
		}
		
		Set tSC = ..Unconfigure(.pParams)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tSC = ##super(.pParams)
		If $$$ISERR(tSC) {
			Quit
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Activate">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tSC = ##super(.pParams)
		If $$$ISERR(tSC) {
			Quit
		}
		Set tSC = ..Configure(.pParams)
		If $$$ISERR(tSC) {
			Quit
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%Package">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tVerbose = $Get(pParams("Verbose"))
		Set tExportDirectory = $Get(pParams("zpm", "Path"))
		If (tExportDirectory'="") && ('##class(%File).DirectoryExists(tExportDirectory)) {
      Set tExportDirectory = ##class(%File).NormalizeDirectory(tExportDirectory)
			If '##class(%File).CreateDirectoryChain(tExportDirectory,.tReturn) {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Error creating directory chain %1: %2",tExportDirectory,tReturn))
				Quit
			}
		}

		Set tSC = ..%Export(.pParams,.tExportDirectory)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tSC = ..OnBeforeArtifact(tExportDirectory,tExportDirectory,.pParams)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Write !,"Module exported to:",!,$Char(9),tExportDirectory,!
		
		Set tTgzFile = $Extract(tExportDirectory,1,*-1)_".tgz"
		Set tSC = ##class(%ZPM.PackageManager.Developer.Archive).Create(tExportDirectory,tTgzFile,.tOutput)
		If $$$ISERR(tSC) {
			Quit
		}
		
		For i=1:1:$Get(tOutput) {
			Write:tVerbose !,tOutput(i)
		}
		
		// Always show this message
		Write !,"Module package generated:",!,$Char(9),tTgzFile
		
		Set tSrcFileStream = ##class(%Stream.FileBinary).%New()
		Set tSC = tSrcFileStream.LinkToFile(tTgzFile)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tSC = ..Payload.CopyFrom(tSrcFileStream)
		If $$$ISERR(tSC) {
			Quit
		}
		Set pParams("PackageFile") = tTgzFile
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.MappingReference">
<Super>%Persistent,%ZPM.PackageManager.Core.MappingReference</Super>
<TimeCreated>65797,80971.920587</TimeCreated>

<Index name="ResourceName">
<Description>
Name index is unique per namespace.</Description>
<Properties>Name,Source</Properties>
</Index>

<Property name="Module">
<Type>%ZPM.PackageManager.Developer.Module</Type>
<Cardinality>parent</Cardinality>
<Inverse>Mappings</Inverse>
<Relationship>1</Relationship>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="Source">
<Description>
Namespace from which it is mapped or copied</Description>
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Deploy">
<Description>
If set to true, this source code is not shipped in application packaging.
(Of course, it must be included in module packaging.)</Description>
<Type>%Boolean</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>{%%PARENT}("Mappings")</DataLocation>
<DefaultData>MappingReferenceDefaultData</DefaultData>
<IdLocation>^ZPM.Dev.ModuleC("Mappings")</IdLocation>
<IndexLocation>^ZPM.Dev.MappingI</IndexLocation>
<StreamLocation>^ZPM.Dev.MappingS</StreamLocation>
<Data name="MappingReferenceDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>Source</Value>
</Value>
<Value name="4">
<Value>Deploy</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Developer.Module">
<IncludeCode>%occErrors,%ZPM.PackageManager.Common</IncludeCode>
<StorageStrategy/>
<Super>%Persistent,%ZPM.PackageManager.Core.ModuleInfo</Super>
<TimeCreated>65797,80971.998477</TimeCreated>

<Parameter name="DOMAIN">
<Default>ZPM</Default>
</Parameter>

<Index name="Name">
<Properties>Name</Properties>
<Unique>1</Unique>
</Index>

<Property name="GlobalScope">
<Type>%Boolean</Type>
</Property>

<Property name="VersionString">
<Type>%String</Type>
<InitialExpression>"0.0.1+snapshot"</InitialExpression>
<Required>1</Required>
<Parameter name="MAXLEN" value="100"/>
<Parameter name="XMLNAME" value="Version"/>
</Property>

<Property name="ExternalName">
<Type>%String</Type>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="Description">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Keywords">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Author">
<Type>%ZPM.PackageManager.Developer.ModuleAuthorInfo</Type>
</Property>

<Property name="Packaging">
<Description>
Typically "module" or "application", but intentionally not enforced with VALUELIST.</Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="Dependencies">
<Type>%ZPM.PackageManager.Core.ModuleReference</Type>
<Collection>list</Collection>
<Parameter name="STORAGEDEFAULT" value="array"/>
</Property>

<Property name="Resources">
<Type>%ZPM.PackageManager.Developer.ResourceReference</Type>
<Cardinality>children</Cardinality>
<Inverse>Module</Inverse>
<Relationship>1</Relationship>
<Parameter name="XMLITEMNAME" value="Resource"/>
<Parameter name="XMLPROJECTION" value="WRAPPED"/>
<Parameter name="XMLREFERENCE" value="COMPLETE"/>
</Property>

<Property name="Mappings">
<Type>%ZPM.PackageManager.Developer.MappingReference</Type>
<Cardinality>children</Cardinality>
<Inverse>Module</Inverse>
<Relationship>1</Relationship>
<Parameter name="XMLITEMNAME" value="Mapping"/>
<Parameter name="XMLPROJECTION" value="WRAPPED"/>
<Parameter name="XMLREFERENCE" value="COMPLETE"/>
</Property>

<Property name="Invokes">
<Type>%ZPM.PackageManager.Developer.InvokeReference</Type>
<Cardinality>children</Cardinality>
<Inverse>Module</Inverse>
<Relationship>1</Relationship>
<Parameter name="XMLITEMNAME" value="Invoke"/>
<Parameter name="XMLPROJECTION" value="WRAPPED"/>
<Parameter name="XMLREFERENCE" value="COMPLETE"/>
</Property>

<Property name="LifecycleClass">
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="InstallerClass">
<Type>%Dictionary.CacheClassname</Type>
</Property>

<Property name="Lifecycle">
<Type>%ZPM.PackageManager.Developer.Lifecycle.Abstract</Type>
<Transient>1</Transient>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="Hash">
<Type>%Binary</Type>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="LastModifiedTimestamp">
<Type>%TimeStamp</Type>
<InitialExpression>$ZDateTime($Horolog,3)</InitialExpression>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="API">
<Type>%ZPM.PackageManager.Developer.APIDocumentation</Type>
<Collection>list</Collection>
<Parameter name="STORAGEDEFAULT" value="array"/>
<Parameter name="XMLITEMNAME" value="Item"/>
</Property>

<Property name="Root">
<Description>
Root directory on the filesystem from which this module was loaded.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="SourcesRoot">
<Description>
Sources root, where placed any source code</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="20"/>
</Property>

<Property name="SystemRequirements">
<Type>%ZPM.PackageManager.Developer.SystemRequirements</Type>
</Property>

<Property name="Defaults">
<Description>
Default settings - there may be serveral types of these (subclasses of ModuleSetting).</Description>
<Type>%ZPM.PackageManager.Developer.ModuleSetting</Type>
<Collection>list</Collection>
<Parameter name="CLASSNAME" value="1"/>
<Parameter name="STORAGEDEFAULT" value="array"/>
<Parameter name="XMLNAME" value="Defaults"/>
<Parameter name="XMLPROJECTION" value="WRAPPED"/>
<Parameter name="XMLREFERENCE" value="COMPLETE"/>
<Parameter name="XMLTYPECONSTRAINT" value="SUBSTITUTIONGROUP"/>
</Property>

<Method name="NameSet">
<FormalSpec>val:%ZPM.cache.RawString</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%Name = $$$lcase(val)
	Return $$$OK
]]></Implementation>
</Method>

<Method name="CheckSystemRequirements">
<ClassMethod>1</ClassMethod>
<FormalSpec>pModuleName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pModuleName = $$$lcase(pModuleName)
		Set tModule = ..NameOpen(pModuleName,,.tSC)
		If '$isobject(tModule) {
			$$$ThrowStatus($$$ERROR($$$GeneralError, "Module '"_pModuleName_"' not found."))
		}
		$$$ThrowOnError(tSC)

		If ($IsObject(tModule.SystemRequirements)) {
			$$$ThrowOnError(tModule.SystemRequirements.CheckRequirements())
		}
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	Return tSC
]]></Implementation>
</Method>

<Method name="ExecutePhases">
<Description>
Execute multiple lifecycle phases in sequence. Execution is terminated if one fails.
Example: $ListBuild("Clean","Test") or $ListBuild("Test","Install")
@PublicAPI</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pModuleName:%String,pPhases:%List,pIsComplete:%Boolean=0,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		set pModuleName = $$$lcase(pModuleName)
		set tModule = ..NameOpen(pModuleName,,.tSC)
		If '$isobject(tModule) {
			$$$ThrowStatus($$$ERROR($$$GeneralError, "Module '"_pModuleName_"' not found."))
		}
		$$$ThrowOnError(tSC)
		
		set tLifecycle = tModule.Lifecycle
		if (tLifecycle = "") {
			if (tModule.Packaging = "application") {
				set tLifecycle = "%ZPM.PackageManager.Developer.Lifecycle.Application"				
			} else {
				set tLifecycle = "%ZPM.PackageManager.Developer.Lifecycle.Module"
			}
		} 
		;
		if pIsComplete {
			set tPhases = tLifecycle.GetCompletePhases(pPhases)
		} else {
			set tPhases = pPhases
		}

		// Subscript by namespace to handle application build and integration testing processes, which may
		// load a module in a different namespace (and call ExecutePhases there) at a lower stack level than the
		// initial call to ExecutePhases
		if '$Data($$$ZPMHandledModules($Namespace)) {
			new $$$ZPMHandledModules
		} else {
			set $$$ZPMHandledModules($Namespace,pModuleName) = $Get($$$ZPMHandledModules($Namespace,pModuleName))_tPhases
		}
		
		do tLifecycle.GetDefaultParameters(.tParams,tPhases)
		Merge tParams = pParams // Overwrite with actual specified parameters
		Kill pParams Merge pParams = tParams // Move back to pParams
		set tLifecycle.PhaseList = tPhases
		;
		; execute resolved phases in sequence
		set tPointer = 0
		while $listnext(tPhases,tPointer,tOnePhase) {
			;
			if tOnePhase="*" {
				kill tModule,tLifecycle
				set tModule = ..NameOpen(pModuleName,,.tSC) quit:$$$ISERR(tSC)
				set tLifecycle = tModule.Lifecycle
				set tLifecycle.PhaseList = tPhases
				write !,"["_pModuleName_"]",$c(9),"Module object refreshed."
				continue
			}
			;
			do {
				;
				write !,"["_pModuleName_"]",$c(9),tOnePhase," START"
				;
				; notify resource processors
				set tKey="" for {
					#dim tResource As %ZPM.PackageManager.Developer.ResourceReference
					set tResource = tModule.Resources.GetNext(.tKey) quit:(tKey="")

					if $IsObject(tResource.Processor) {
						Do tResource.Processor.SetParams(.pParams)
						set tSC = $method(tResource.Processor,"OnBeforePhase",tOnePhase,.pParams) quit:$$$ISERR(tSC)
					}
				}
				Quit:$$$ISERR(tSC)

        #; Call Invoke Methods		
        Set tKey = ""
        For {
          Set tInvoke = tModule.Invokes.GetNext(.tKey)
          Quit:(tKey = "")
          Set tSC = tInvoke.OnBeforePhase(tOnePhase,.pParams)
          Quit:$$$ISERR(tSC)
        }
        Quit:$$$ISERR(tSC)

				; call OnBeforePhase for this class
				set tSC = tLifecycle.OnBeforePhase(tOnePhase,.pParams) quit:$$$ISERR(tSC)
				;
				set tSC = $method(tLifecycle,"%"_tOnePhase,.pParams) quit:$$$ISERR(tSC)
				;
				; call OnAfterPhase for this class

        #; Call Invoke Methods After Phase	
        Set tKey = ""
        For {
          Set tInvoke = tModule.Invokes.GetNext(.tKey)
          Quit:(tKey = "")
          Set tSC = tInvoke.OnAfterPhase(tOnePhase,.pParams)
          Quit:$$$ISERR(tSC)
        }
        Quit:$$$ISERR(tSC)

				; notify resource processors
				set tKey="" for {
					set tResource = tModule.Resources.GetNext(.tKey) quit:(tKey="")			
					if $IsObject(tResource.Processor) {
						Do tResource.Processor.SetParams(.pParams)
						Set tSC = $method(tResource.Processor,"OnAfterPhase",tOnePhase,.pParams) quit:$$$ISERR(tSC)
					}
				}
				quit:$$$ISERR(tSC)
			} while (0)
			
			if $$$ISERR(tSC) {
        write !,"["_pModuleName_"]",$c(9),tOnePhase," FAILURE - ",$SYSTEM.Status.GetErrorText(tSC)
				quit
			} else {
				write !,"["_pModuleName_"]",$c(9),tOnePhase," SUCCESS"
			}
		}
		;
	} catch e {
		set tSC = e.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="Uninstall">
<Description><![CDATA[
Uninstalls a named module (<var>pModuleName</var>).
May optionally force installation (uninstalling even if required by other modules) if <var>pForce</var> is 1.
May optionally recurse to also uninstall dependencies that are not required by other modules if <var>pRecurse</var> is 1.
If both <var>pForce</var> and <var>pRecurse</var> are 1, then dependencies will also be uninstalled forcibly.
@PublicAPI]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pModuleName:%String,pForce:%Boolean=0,pRecurse:%Boolean=0,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Merge tParams = pParams
		Set tParams("Clean","Level") = 1 // Simulate clean of module as dependency.
		Set tParams("Clean","Force") = pForce
		Set tParams("Clean","Recurse") = pRecurse
		Set tSC = ##class(%ZPM.PackageManager.Developer.Module).ExecutePhases(pModuleName,$ListBuild("Clean"),,.tParams)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="HasScope">
<ClassMethod>1</ClassMethod>
<FormalSpec>pPhases:%List,pScope:%String</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	If (pScope = "") {
		Quit 1
	}
	Set tPhases = $zcvt(pPhases,"L")
	Quit $ListFind(tPhases,pScope)
]]></Implementation>
</Method>

<Method name="LoadDependencies">
<FormalSpec><![CDATA[pPhaseList:%List,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tVerbose = $Get(pParams("Verbose"))
		
		If '$Data(pParams("qstruct")) {
			Set qstruct = "ck"_$Select(tVerbose:"d",1:"-d")
		} Else {
			Merge qstruct = pParams("qstruct")
		}
		
		// Resolve and validate dependencies
		Set tReloadSnapshots = +$Get(pParams("UpdateSnapshots"))
		Set tSC = ..BuildDependencyGraph(.tDependencyGraph,,tReloadSnapshots,.qstruct,pPhaseList)
		If $$$ISERR(tSC) {
			Quit
		}
		
		If $Data(tDependencyGraph) {
			Set tOptimizeInstalled = 'tReloadSnapshots
			Write:tVerbose !,"Dependencies:"
			Set tModuleLoop = ""
			For {
				Set tModuleLoop = $Order(tDependencyGraph(tModuleLoop),1,tValue)
				Quit:tModuleLoop=""
				
				If (tOptimizeInstalled) && '$Data($$$ZPMHandledModules($Namespace,tModuleLoop)) {
					// Optimize for exact version matches that are already installed.
					If ##class(%ZPM.PackageManager.Developer.Module).NameExists(tModuleLoop) {
						Set tMod = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(tModuleLoop,,.tSC)
						$$$ThrowOnError(tSC)
						If (tMod.VersionString = $ListGet(tValue,3)) {
							Set $List(tValue,2) = ""
							Set $List(tDependencyGraph(tModuleLoop),2) = ""
						}
					}
				}
				
				Set tServer = $Case($ListGet(tValue,2),"":" (installed)",:" @ "_$ListGet(tValue,2))
				Write:tVerbose !,tModuleLoop," ",$ListGet(tValue,3),tServer
			}
		
			// Download dependencies.
			Kill tParams
			Merge tParams("qstruct") = qstruct
			Merge tParams = pParams
			Set tSC = ##class(%ZPM.PackageManager.Developer.Utils).LoadDependencies(.tDependencyGraph,.tParams)
			If $$$ISERR(tSC) { Quit }
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="BuildDependencyGraph">
<FormalSpec><![CDATA[&pDependencyGraph,pDepth:%Integer=1,pForceSnapshotReload:%Boolean=0,&qstruct,pPhases:%String="",&pSubModules,pPass:%Integer=1,pModulePath:%List=$ListBuild(..Name),pIgnoreInstalledModules:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#define EXACT 1
	#define FUZZY 2
	
	Set tSC = $$$OK
	Try {
		Kill tSubModules
		For i=1:1:..Dependencies.Count() {
			#dim tDep As %ZPM.PackageManager.Core.ModuleReference
			Set tDep = ..Dependencies.GetAt(i)
			
			If '..HasScope(pPhases,tDep.Scope) {
				Continue
			}
			
			// Ensure this dependency is not an ancestor in the chain of dependencies getting to this point
			If $ListFind(pModulePath,tDep.Name) {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Cyclic dependency detected in module '%1': %2",..Name,$ListToString(pModulePath_$ListBuild(tDep.Name)," -> ")))
				Quit
			}
			
			// Test whether dependency version is a valid semantic version. These are handled in the first pass only.
			// Other cases are handled in the second pass only.
			Set tIsExactVersion = +##class(%ZPM.PackageManager.Core.SemanticVersion).IsValid(tDep.VersionString)
			If ((pPass = $$$EXACT) && 'tIsExactVersion) || ((pPass = $$$FUZZY) && tIsExactVersion) {
				Continue
			}
			
			// Build cumulative version requirement string
			#dim tSearchExpr As %ZPM.PackageManager.Core.SemanticVersionExpression
			Set tSearchExpr = tDep.Version.%ConstructClone(1)
			Set tSourcePath = ""
			For {
				Set tSourcePath = $Order(pDependencyGraph(tDep.Name,tSourcePath),1,tOtherReq)
				Quit:tSourcePath=""
				
				Set tSC = ##class(%ZPM.PackageManager.Core.SemanticVersionExpression).FromString(tOtherReq,.tExpr)
				If $$$ISERR(tSC) {
					Quit
				}
				Set tSearchExpr = tSearchExpr.And(tExpr)
			}
			If $$$ISERR(tSC) {
				Quit
			}
			
			Set tOtherDeps = ""
			Set tExistingDepKey = ""
			For {
				Set tExistingDepKey = $Order(pDependencyGraph(tExistingDepKey))
				If (tExistingDepKey = "") {
					Quit
				}
				Set tOtherDeps = tOtherDeps_$ListBuild(tExistingDepKey)
			}
			
			// Also apply requirements presented by other installed modules that are not already in the dependency graph.
			Set tSC = ##class(%ZPM.PackageManager.Developer.Utils).GetRequiredVersionExpression(tDep.Name,tOtherDeps,.tInstalledReqExpr)
			If $$$ISERR(tSC) {
				Quit
			}
			Set tSearchExpr = tSearchExpr.And(tInstalledReqExpr)
			
			// See if we already have a version that satisfies the dependency:
			Set tDepFound = $Data(pDependencyGraph(tDep.Name),tDepInfo)
			Set tPreviousDepth = 0
			Set tServerName = ""
			Set tVersion = ""
			If tDepFound {
				Set $ListBuild(tPreviousDepth,tServerName,tVersion) = tDepInfo
			}
			
			// See if a satisfactory version already exists in the current namespace.
			// If it does, always use it
			// Particularly relevant for compilation of dependencies
			// The "clean" phase can be used to bypass this (by removing modules from the current namespace)
			// Forcing an update from disk can also override this, although we ensure that the same module is
			// not loaded multiple times in a given operation.
			Set tForceSnapshotReload = pForceSnapshotReload
			If tForceSnapshotReload && $Data($$$ZPMHandledModules($Namespace,tDep.Name),tHandled) {
				If $ListFind(tHandled,"Activate") {
					// If we have already activated the given module, don't do so again.
					Set tForceSnapshotReload = 0
				}
			}
			If ('pIgnoreInstalledModules) && ..NameExists(tDep.Name) {
				Set tLocalObj = ..NameOpen(tDep.Name,,.tSC)
				If $$$ISERR(tSC) {
					Quit
				}
				
				Set tInstalledVersionValid = tLocalObj.Version.Satisfies(tSearchExpr) && ((tVersion = "") || (tVersion = tLocalObj.VersionString))
				If tInstalledVersionValid && '(tLocalObj.Version.IsSnapshot() && tForceSnapshotReload) {
					Set tLocalMod = 1
					Set tDepth = $Select(tPreviousDepth=0:pDepth,tPreviousDepth>pDepth:tPreviousDepth,1:pDepth)
					Set pDependencyGraph(tDep.Name) = $ListBuild(pDepth,"",tLocalObj.VersionString)
					Set pDependencyGraph(tDep.Name,..Name_" "_..VersionString) = tDep.VersionString
					Set pSubModules(tDepth,tDep.Name) = tLocalObj
					Continue
				}
			}
			
			Set tSearchCriteria = ##class(%ZPM.PackageManager.Core.SearchCriteria).%New()
			Set tSearchCriteria.Name = tDep.Name
			Set tSearchCriteria.VersionExpression = tSearchExpr.ToString()
			Set tSC = ##class(%ZPM.PackageManager.Client.Utils).SearchRepositoriesForModule(tSearchCriteria,.tQualifiedReferences,pForceSnapshotReload)
			If $$$ISERR(tSC) {
				Quit
			}
			If (tQualifiedReferences.Count() = 0) {
				Set tMsg = $$$FormatText("Could not find satisfactory module version in any repositories: '%1' version '%2', required by %3",tDep.Name,tSearchCriteria.VersionExpression,..Name)
				Set tSC = $$$ERROR($$$GeneralError,tMsg)
				Quit
			} Else {
				Set tResultFound = 0
				For j=1:1:tQualifiedReferences.Count() {
					Kill tDependencyGraph,tSubModules
					Merge tDependencyGraph = pDependencyGraph
					Merge tSubModules = pSubModules
					Set tQualifiedReference = tQualifiedReferences.GetAt(j)
					Set tSC = ##class(%ZPM.PackageManager.Client.Utils).RetrieveModuleManifest(tQualifiedReference,.tManifest)
					If $$$ISERR(tSC) {
						Quit
					}
					
					// Recursively process dependencies.
					#dim tModule As %ZPM.PackageManager.Developer.Module
					Set tReader = ##class(%XML.Reader).%New()
					Set tSC = tReader.OpenStream(tManifest)
					If $$$ISERR(tSC) {
						Quit
					}
					Do tReader.Correlate("Module","%ZPM.PackageManager.Developer.Module")
					Do tReader.Next(.tModule,.tSC)
					If $$$ISERR(tSC) {
						Quit
					}
					
					Set tDepth = $Select(tPreviousDepth=0:pDepth,tPreviousDepth>pDepth:tPreviousDepth,1:pDepth)
			
					If (pPass = $$$EXACT) {	
						Set pDependencyGraph(tDep.Name) = $ListBuild(pDepth,tQualifiedReference.ServerName,tModule.VersionString)
						Set pDependencyGraph(tDep.Name,..Name_" "_..VersionString) = tDep.VersionString
						Set pSubModules(tDepth,tDep.Name) = tModule
				
						// If we have an exact match, attempt to resolve exact dependencies recursively.
						Set tSC = tModule.BuildDependencyGraph(.pDependencyGraph,pDepth+1,pForceSnapshotReload,.qstruct,,.pSubModules,,pModulePath_$ListBuild(tDep.Name),pIgnoreInstalledModules)
						
						// Failure to resolve any of these dependencies is an immediate failure, and can be descriptive.
						If $$$ISERR(tSC) {
							Quit
						}
						
						Set tResultFound = 1
						Quit
					}
					
					If (pPass = $$$FUZZY) {	
						Set tDependencyGraph(tDep.Name) = $ListBuild(tDepth,tQualifiedReference.ServerName,tModule.VersionString)
						Set tDependencyGraph(tDep.Name,..Name_" "_..VersionString) = tDep.VersionString
				
						Set tSubModules(tDepth,tDep.Name) = tModule
					
						// For fuzzy version matching, preview the next graph step; move to the next version if it would lead to failure.
						// If not, update.
						Set tPossibleSC = tModule.BuildDependencyGraph(.tDependencyGraph,pDepth+1,pForceSnapshotReload,.qstruct,,.tSubModules,,pModulePath_$ListBuild(tDep.Name),pIgnoreInstalledModules)
						If $$$ISOK(tPossibleSC) {
							// We have a match - let's go with it. Actually dependency resolution will be done later, breadth-first.
							// TODO: Caching of results to avoid duplicate web service calls.
							Set tResultFound = 1
							Quit
						}
					}
				}
				If $$$ISERR(tSC) {
					Quit
				}
				
				If (pPass = $$$FUZZY) {
					// We don't actually care if a valid result was found.
					// There will always be something in here, it just might lead to a descriptive error later on in the case of fuzzy matching with no valid option.
					Set pDependencyGraph(tDep.Name) = $ListBuild(pDepth,tQualifiedReference.ServerName,tModule.VersionString)
					Set pDependencyGraph(tDep.Name,..Name_" "_..VersionString) = tDep.VersionString
					Set pSubModules(tDepth,tDep.Name) = tModule
				}
			}
		}
		If $$$ISERR(tSC) {
			Quit
		}
		
		If (pPass = $$$EXACT) {	
			// Call for second pass (fuzzy version matching)
			Set tSC = ..BuildDependencyGraph(.pDependencyGraph,pDepth,pForceSnapshotReload,.qstruct,pPhases,.pSubModules,$$$FUZZY,pModulePath,pIgnoreInstalledModules)
			If $$$ISERR(tSC) {
				Quit
			}
		}
		
		// Breadth-first dependency resolution for depth 1, pass 1.
		// Things to resolve have been accumulated in previous passes and/or will continue to be accumulated.
		If (pDepth = 1) && (pPass = $$$EXACT) {
			 While $Data(pSubModules(pDepth)) {	
				Set tModName = ""
				For {
					Set tModName = $Order(pSubModules(pDepth,tModName),1,tModule)
					Quit:tModName=""
					Set tSC = tModule.BuildDependencyGraph(.pDependencyGraph,pDepth+1,pForceSnapshotReload,.qstruct,,.pSubModules,,pModulePath_$ListBuild(tModName),pIgnoreInstalledModules)
					If $$$ISERR(tSC) {
						Quit
					}
				}
				If $$$ISERR(tSC) {
					Quit
				}
				Set pDepth = pDepth + 1
			}
			If $$$ISERR(tSC) {
				Quit
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetResolvedReferences">
<FormalSpec><![CDATA[*pReferenceArray,pLockedDependencies:%Boolean=0,pPhases:%List="",pSkipDependencies:%Boolean=0,&pDependencyGraph]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If '$Data(pDependencyGraph) {
			Set tSC = ..BuildDependencyGraph(.pDependencyGraph,,,,pPhases)
			If $$$ISERR(tSC) {
				Quit
			}
		}
		
		If 'pSkipDependencies {
			Kill tParams
			Set tParams("Verbose") = 0
			Set tParams("qstruct") = "k"
			Set tSC = ##class(%ZPM.PackageManager.Developer.Utils).LoadDependencies(.pDependencyGraph,.tParams)
			If $$$ISERR(tSC) {
				Quit
			}
		}
		
		Set pReferenceArray(..Name_".ZPM") = ""
		
		Set tKey = ""
		For {
			#dim tResource As %ZPM.PackageManager.Developer.ResourceReference
			Set tResource = ..Resources.GetNext(.tKey)
			Quit:tKey=""
			If '..HasScope(pPhases,tResource.Scope) {
				Continue
			}
			
			Set tSC = tResource.ResolveChildren(.pReferenceArray)
			If $$$ISERR(tSC) {
				Quit
			}
		}
		If $$$ISERR(tSC) {
			Quit
		}
		
		If pLockedDependencies {
			Set tModName = ""
			For {
				Set tModName = $Order(pDependencyGraph(tModName))
				Quit:tModName=""
				
				Set tModule = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(tModName,,.tSC)
				If $$$ISERR(tSC) {
					Quit
				}
				
				// Don't pass along the phase
				Set pReferenceArray(tModName_".ZPM") = ..Name
				Set tSC = tModule.GetResolvedReferences(.pReferenceArray, pLockedDependencies, ,pSkipDependencies)
				If $$$ISERR(tSC) {
					Quit
				}
			}
			If $$$ISERR(tSC) {
				Quit
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="UpdateAPIDocumentation">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// Extract annotations from classes in the module.
		Set tAnnotationList = ##class(%Library.ListOfObjects).%New()
		Set tKey = ""
		For {
			Set tResource =  ..Resources.GetNext(.tKey)
			Quit:tKey=""
			
			Kill tChildArray
			Set tSC = tResource.ResolveChildren(.tChildArray)
			If $$$ISERR(tSC) {
				Quit
			}
			Set tChild = ""
			For {
				Set tChild = $Order(tChildArray(tChild))
				Quit:tChild=""
				
				If ($Piece(tChild,".",*) = "CLS") {
					Set tSC = ##class(%ZPM.PackageManager.Developer.Annotation.Utils).ExtractAnnotations($Piece(tChild,".",1,*-1),tAnnotationList)
					If $$$ISERR(tSC) {
						Quit
					}
				}
			}
			If $$$ISERR(tSC) {
				Quit
			}
		}
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Currently, automatic annotations are only supported for classes and class members.
		// Build an array of members with @API annotations:
		For i=1:1:tAnnotationList.Count() {
			#dim tAnnotation As %ZPM.PackageManager.Developer.Annotation
			Set tAnnotation = tAnnotationList.GetAt(i)
			If (tAnnotation.Tag = "PublicAPI") || (tAnnotation.Tag = "PrivateAPI") {
				Set tSubType = tAnnotation.MemberType
				Set tName = tAnnotation.Classname_$Case(tAnnotation.MemberName,"":"",:":"_tAnnotation.MemberName)
				Set tAPIArray($ListBuild(tSubType,tName)) = (tAnnotation.Tag = "PublicAPI")
			}
		}
		
		// Remove missing annotations from the module's API documentation:
		Set tAPIChanged = 0
		For i=..API.Count():-1:1 {
			#dim tItem As %ZPM.PackageManager.Developer.APIDocumentation
			Set tItem = ..API.GetAt(i)
			If (tItem.Type = "class") {
				Set tKey = $ListBuild(tItem.SubType,tItem.Name)
				If $Data(tAPIArray(tKey),tPublic) {
					// Update "Public" flag
					If (tPublic '= tItem.Public) {
						Set tItem.Public = tPublic
						Set tAPIChanged = 1
					}
					// This is still API. No need to re-add it later.
					Kill tAPIArray(tKey)
				} Else {
					// No longer API. Remove it.
					Do ..API.RemoveAt(i)
					Set tAPIChanged = 1
				}
			}
		}
		
		// Insert new annotations at the end of the module's API documentation:
		Set tKey = ""
		For {
			Set tKey = $Order(tAPIArray(tKey),1,tPublic)
			Quit:tKey=""
			
			Set tAPIDoc = ##class(%ZPM.PackageManager.Developer.APIDocumentation).%New()
			Set tAPIDoc.Type = "class"
			Set tAPIDoc.SubType = $List(tKey,1)
			Set tAPIDoc.Name = $List(tKey,2)
			Set tAPIDoc.Public = tPublic
			Do ..API.Insert(tAPIDoc)
			Set tAPIChanged = 1
		}
		
		// Save changes to the module.
		If (tAPIChanged = 1) {
			// Force timestamp change if there have actually been any changes to the API.
			// %OnAddToSaveSet is not called if there have only been modifications to subordinate objects.
			Set ..Hash = ""
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="LifecycleGet">
<ReturnType>%ZPM.PackageManager.Developer.Lifecycle.Abstract</ReturnType>
<Implementation><![CDATA[
	if $isObject(r%Lifecycle) quit r%Lifecycle
	set tLifecycleClass = ..LifecycleClass
	if (tLifecycleClass '= "") && ($Length(tLifecycleClass,".") = 1) {
		set tLifecycleClass = $$$DefaultLifecyclePackageDot_tLifecycleClass
	}
	if (tLifecycleClass = "") || '$$$comClassDefined(tLifecycleClass) {
		if (..Packaging = "application") {
			set ..LifecycleClass = "Application"
		} else {
			set ..LifecycleClass = "Module"
		}
		set tLifecycleClass = $$$DefaultLifecyclePackageDot_..LifecycleClass
	}
	set r%Lifecycle = $ClassMethod(tLifecycleClass,"%New",$this)
	quit r%Lifecycle
]]></Implementation>
</Method>

<Method name="%OnNew">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%New</METHOD> method to 
provide notification that a new instance of an object is being created.

<P>If this method returns an error then the object will not be created.
<p>It is passed the arguments provided in the %New call.
When customizing this method, override the arguments with whatever variables and types you expect to receive from %New().
For example, if you're going to call %New, passing 2 arguments, %OnNew's signature could be:
<p>Method %OnNew(dob as %Date = "", name as %Name = "") as %Status
If instead of returning a %Status code this returns an oref and this oref is a subclass of the current
class then this oref will be the one returned to the caller of %New method.]]></Description>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set ..Version = ##class(%ZPM.PackageManager.Core.SemanticVersion).FromString(i%VersionString)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnOpen">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%Open</METHOD> method to 
provide notification that the object specified by <VAR>oid</VAR> is being opened.

<P>If this method returns an error then the object will not be opened.]]></Description>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// In Studio, use the existing %SourceControl object.
		// From other contexts, create a new one.
		If '$IsObject($Get(%SourceControl)) {
			New %SourceControl
			Do ##class(%Studio.SourceControl.Interface).SourceControlCreate()
		}
		Set tExternalName = ##class(%Studio.SourceControl.Interface).ExternalName(..Name_".ZPM")
		If (tExternalName '= "") {
			Set ..Root = ##class(%File).GetDirectory(tExternalName,1)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%ValidateObject</METHOD> method to 
provide notification that the current object is being validated.

<P>If this method returns an error then <METHOD>%ValidateObject</METHOD> will fail.]]></Description>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// Ensure packaging property is set to the correct value.
		// This validation only runs if the lifecycle class exists.
		If (..LifecycleClass '= "") && $$$comClassDefined(..LifecycleClass) {
			Set tBaseClass = "%ZPM.PackageManager.Developer.Lifecycle.Base"
			If '$ClassMethod(..LifecycleClass,"%Extends",tBaseClass) {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Invalid lifecycle class '%1' - must extend %2",..LifecycleClass,tBaseClass))
				Quit
			}
			Set tPackaging = $Parameter(..LifecycleClass,"PACKAGING")
			If (..Packaging = "") {
				Set ..Packaging = tPackaging
			} ElseIf (..Packaging '= tPackaging) {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Module's packaging is set to '%1', but lifecycle class '%2' has packaging '%3'.",..Packaging,..LifecycleClass,tPackaging))
				Quit
			}
		} ElseIf (..Packaging = "") {
			// Default to "module"
			Set ..Packaging = "module"
		}
		
		If (..InstallerClass '= "") && $$$comClassDefined(..InstallerClass) {
			Set tBaseClass = "%ZPM.AbstractInstaller"
			If '$ClassMethod(..InstallerClass,"%Extends",tBaseClass) {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Invalid installer class '%1' - must extend %2",..InstallerClass,tBaseClass))
				Quit
			}
		}
		
		// Pre-check for uniqueness among resources (make sure there are no collisions and report descriptive errors if there are).
		// This is simpler than trying to interpret a unique index violation later, and will work in all cases where we're updating modules.
		Set tSC = $$$OK
		Set tKey = ""
		For {
			Set tResource = ..Resources.GetNext(.tKey)
			Quit:(tKey="")
			
			// If it hasn't been saved yet (to account for module renames)...
			If (tResource.%Id() = "") && (tResource.UniqueName '= "") {
				// ... see if some other resource exists with the same name.
				If ##class(%ZPM.PackageManager.Developer.ResourceReference).ResourceNameExists(tResource.UniqueName) {
					Set tOtherResource = ##class(%ZPM.PackageManager.Developer.ResourceReference).ResourceNameOpen(tResource.UniqueName,,.tSC)
					If $$$ISERR(tSC) {
						Quit
					}
					If (tResource.Name = tResource.UniqueName) {
						// Common case: classes, packages, include files, etc.
						Set tMsg = $$$FormatText("Resource '%1' is already defined as part of module '%2'; cannot also be listed in module '%3'",tResource.Name,tOtherResource.Module.Name,..Name)
					} Else {
						// Handle the case where resources with different names are uniquely identified the same way.
						Set tResourceName = tResource.Name_" ("_tResource.UniqueName_")"
						Set tMsg = $$$FormatText("Resource '%1' is already defined as part of module '%2' as '%4'; cannot also be listed in module '%3'",tResourceName,tOtherResource.Module.Name,..Name,tOtherResource.Name)
					}
					Set tSC = $$$ERROR($$$GeneralError,tMsg)
					Quit
				}
			}
			If $$$ISERR(tSC) {
				Quit
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%OnAddToSaveSet">
<Description><![CDATA[
This callback method is invoked when the current object is added to the SaveSet,
either because %Save() was invoked on this object or on an object that references this object.
%OnAddToSaveSet can modify the current object. It can also add other objects to the current
SaveSet by invoking %AddToSaveSet or remove objects by calling %RemoveFromSaveSet.

<P>If this method returns an error status then %Save() will fail and the transaction
will be rolled back.]]></Description>
<FormalSpec>depth:%Integer=3,insert:%Integer=0,callcount:%Integer=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// Ensure Version serial object is up to date.
		If (..VersionString '= ..Version.ToString()) {
			Set ..Version = ##class(%ZPM.PackageManager.Core.SemanticVersion).FromString(..VersionString)
		}
		Set tSC = ..XMLExportToStream(.tStream)
		If $$$ISERR(tSC) {
			Quit
		}
		
		// See if the module definition has actually changed
		Set tHash = $System.Encryption.SHA1HashStream(tStream,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		If (..Hash '= tHash) {
			Set ..Hash = tHash
			Set ..LastModifiedTimestamp = $zdt($h,3)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="XMLNew">
<Description><![CDATA[
Get an instance of an XML enabled class.<br><br>

You may override this method to do custom processing (such as initializing
the object instance) before returning an instance of this class.
However, this method should not be called directly from user code.<br>
Arguments:<br>
    document is the document with %XML.Node or macros in %xmlDOM.inc.<br>
    nodeId is a node id of the node which defines this object.
        An %XML.Node object may be obtained for this node using document.GetNode(nodeId)<br>
    containerOref is the containing object instance when called from XMLImport and
        is "" when called from %XML.Reader for Correlate'd objects.<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>document:%XML.Document,node:%Integer,containerOref:%RegisteredObject=""</FormalSpec>
<ReturnType>%RegisteredObject</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	// Coupled with %ZPM.PackageManager.Developer.Document.Module to allow editing of the current module rather than matching an existing one.
	Quit $Get($$$ZPMStudioDocumentModule,..%New())
]]></Implementation>
</Method>

<Method name="%Compile">
<FormalSpec><![CDATA[&qstruct:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..Lifecycle.Compile(.qstruct)
]]></Implementation>
</Method>

<Method name="IsLocked">
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit ($ZConvert(..Version.Build,"L") '= "snapshot")
]]></Implementation>
</Method>

<Method name="Lock">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If '..IsLocked() {
		Set ..Version.Build = ""
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="VersionRequirements">
<Type>%SQLQuery</Type>
<FormalSpec>pOfModuleName:%String,pExcludeModuleNames:%List=""</FormalSpec>
<SqlProc>1</SqlProc>
<SqlQuery><![CDATA[	select distinct %exact Dependencies_VersionString "Version"
	from %ZPM_PackageManager_Developer.Module_Dependencies
	where Dependencies_Name = :pOfModuleName and
		(:pExcludeModuleNames is null or "Module"->Name not %INLIST :pExcludeModuleNames)]]></SqlQuery>
</Query>

<Method name="%RegExReplace">
<ClassMethod>1</ClassMethod>
<FormalSpec>pString,pName,pValue</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set tString = pString
  Set tRegEx = "(?i)\{\$" _ pName _ "\}"
	Set tString =  ##class(%Regex.Matcher).%New(tRegEx, tString).ReplaceAll($Replace(pValue,"\","\\"))
  Set tRegEx = "(?i)\$\{" _ pName _ "\}"
	Set tString =  ##class(%Regex.Matcher).%New(tRegEx, tString).ReplaceAll($Replace(pValue,"\","\\"))
  Quit tString
]]></Implementation>
</Method>

<Method name="%Evaluate">
<Description>
Evaluates an expression in an attribute
Current valid expressions:
{$namespace} - the current namespace
{$mgrdir} - the instance's mgr directory
{$cspdir} - the instance's root CSP directory
{$root} - the resource's module's root directory
These special expressions are case-insensitive.</Description>
<Internal>1</Internal>
<FormalSpec><![CDATA[pAttrValue,&pParams]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tAttrValue = pAttrValue
	Set tRoot = $Case(..Root,"":"",:##class(%File).NormalizeDirectory(..Root))
  Set tInstallDir = $System.Util.InstallDirectory()
	Set tMgrDir = $System.Util.ManagerDirectory()
  Set tBinDir = $System.Util.BinaryDirectory()
	Set tCSPDir = ##class(%File).NormalizeDirectory("csp", tInstallDir)
  Set tLibDir = ##class(%File).NormalizeDirectory("lib", tInstallDir)
  Set tVerbose = +$Get(pParams("Verbose"))

	Set tAttrValue = ..%RegExReplace(tAttrValue, "namespace", $Namespace)
	Set tAttrValue = ..%RegExReplace(tAttrValue, "ns",        $Namespace)
	Set tAttrValue = ..%RegExReplace(tAttrValue, "mgrdir",    tMgrDir)
	Set tAttrValue = ..%RegExReplace(tAttrValue, "cspdir",    tCSPDir)
	Set tAttrValue = ..%RegExReplace(tAttrValue, "root",      tRoot)
	Set tAttrValue = ..%RegExReplace(tAttrValue, "bindir",    tBinDir)
	Set tAttrValue = ..%RegExReplace(tAttrValue, "libdir",    tLibDir)
	Set tAttrValue = ..%RegExReplace(tAttrValue, "verbose",   tVerbose)

  Set regex = ##class(%Regex.Matcher).%New("#\{([^}]+)\}", tAttrValue)
  While regex.Locate() {
    Set expr = regex.Group(1)
    Set value = ..%EvalueateExpression(expr)
    Set $Extract(tAttrValue, regex.Start, regex.End - 1) = value
    Set regex.Text = tAttrValue
  }
  
	Quit tAttrValue
]]></Implementation>
</Method>

<Method name="%EvalueateExpression">
<Internal>1</Internal>
<FormalSpec>pExpr</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  Try {
    return @pExpr
  } Catch ex {
  }
  Return ""
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^ZPM.Dev.ModuleD</DataLocation>
<DefaultData>ModuleDefaultData</DefaultData>
<IdLocation>^ZPM.Dev.ModuleD</IdLocation>
<IndexLocation>^ZPM.Dev.ModuleI</IndexLocation>
<StreamLocation>^ZPM.Dev.ModuleS</StreamLocation>
<Data name="API">
<Attribute>API</Attribute>
<Structure>subnode</Structure>
<Subscript>"API"</Subscript>
</Data>
<Data name="Defaults">
<Attribute>Defaults</Attribute>
<Structure>subnode</Structure>
<Subscript>"Defaults"</Subscript>
</Data>
<Data name="Dependencies">
<Attribute>Dependencies</Attribute>
<Structure>subnode</Structure>
<Subscript>"Dependencies"</Subscript>
</Data>
<Data name="ModuleDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>Namespace</Value>
</Value>
<Value name="4">
<Value>VersionString</Value>
</Value>
<Value name="5">
<Value>Version</Value>
</Value>
<Value name="6">
<Value>LastModifiedTimestamp</Value>
</Value>
<Value name="7">
<Value>LifecycleClass</Value>
</Value>
<Value name="8">
<Value>Hash</Value>
</Value>
<Value name="9">
<Value>Description</Value>
</Value>
<Value name="10">
<Value>ExternalName</Value>
</Value>
<Value name="11">
<Value>Author</Value>
</Value>
<Value name="12">
<Value>InstallerClass</Value>
</Value>
<Value name="13">
<Value>GlobalScope</Value>
</Value>
<Value name="14">
<Value>Root</Value>
</Value>
<Value name="15">
<Value>Packaging</Value>
</Value>
<Value name="16">
<Value>Keywords</Value>
</Value>
<Value name="17">
<Value>SourcesRoot</Value>
</Value>
<Value name="18">
<Value>Repo</Value>
</Value>
<Value name="19">
<Value>SystemRequirements</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Developer.ModuleAuthorInfo">
<Super>%SerialObject,%XML.Adaptor</Super>
<TimeCreated>65797,80971.959487</TimeCreated>

<Parameter name="NAMESPACE">
<Type>STRING</Type>
<Default>http://www.intersystems.com/PackageManager</Default>
</Parameter>

<Parameter name="XMLIGNOREINVALIDTAG">
<Default>1</Default>
</Parameter>

<Parameter name="XMLIGNOREINVALIDATTRIBUTE">
<Default>1</Default>
</Parameter>

<Property name="Person">
<Type>%String</Type>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="Organization">
<Type>%String</Type>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="CopyrightDate">
<Type>%String</Type>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="License">
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Property name="Notes">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>ModuleAuthorInfoState</State>
<StreamLocation>^ZPM.PackageManager.ModuleAutho4EB8S</StreamLocation>
<Data name="ModuleAuthorInfoState">
<Value name="1">
<Value>Person</Value>
</Value>
<Value name="2">
<Value>Organization</Value>
</Value>
<Value name="3">
<Value>CopyrightDate</Value>
</Value>
<Value name="4">
<Value>License</Value>
</Value>
<Value name="5">
<Value>Notes</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Developer.ModuleSetting.Default">
<Description><![CDATA[
Custom defaults for module
Each <Default Name="" Value="" /> element defines one parameter, that can be specified
during module installation]]></Description>
<Super>%ZPM.PackageManager.Developer.ModuleSetting</Super>
<TimeCreated>65798,36937.715669</TimeCreated>

<Property name="Name">
<Type>%String</Type>
<Parameter name="MAXLEN" value="255"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Value">
<Type>%String</Type>
<Parameter name="MAXLEN" value="1000"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="GetCustomParameters">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[*customParams,module:%ZPM.PackageManager.Developer.Module,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Kill customParams
    Set customParams = ""
    Set key = ""
    For {
        Set default = module.Defaults.GetNext(.key)
        Quit:(key="")
        If (default.%ClassName(1)="%ZPM.PackageManager.Developer.ModuleSetting.Default") {
            Set customParams(default.Name) = default.Value
            If ($Data(pParams("zpm",default.Name))) {
                Set customParams(default.Name) = $Get(pParams("zpm",default.Name))
            }
        }
    }
    return $$$OK
]]></Implementation>
</Method>

<Method name="EvaluateArgs">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&args,&customParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set key = ""
    For {
        Set key = $Order(args(key))
        Quit:(key="")
        Set args(key) = ..EvaluateAttribute(args(key),.customParams)
    }
    return $$$OK
]]></Implementation>
</Method>

<Method name="EvaluateAttribute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[attribute:%String,&customParams]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set name=""
    For {
        Set name = $Order(customParams(name))
        Quit:(name="")
        Set regex=##class(%Regex.Matcher).%New("\$\{"_name_"\}", attribute)
        Set attribute = regex.ReplaceAll(customParams(name))
    }
    return attribute
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>DefaultState</State>
<Data name="DefaultState">
<Subscript>"Default"</Subscript>
<Value name="1">
<Value>Name</Value>
</Value>
<Value name="2">
<Value>Value</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Developer.ModuleSetting.ProcessorDefault.Condition">
<Description><![CDATA[
Tested in the SatisfiesCondition method of <class>%ZPM.PackageManager.Developer.Processor.Abstract</class>]]></Description>
<Super>%SerialObject,%XML.Adaptor</Super>
<TimeCreated>65797,80972.254981</TimeCreated>

<Parameter name="NAMESPACE">
<Type>STRING</Type>
<Default>http://www.intersystems.com/PackageManager</Default>
</Parameter>

<Property name="Attribute">
<Description>
Name of other attribute to test</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="100"/>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="Operator">
<Description>
Comparison operator; if empty, "eq" is assumed (although not the InitialExpression for sake of XML re-export).</Description>
<Type>%String</Type>
<Parameter name="VALUELIST" value=",eq,neq,gt,lt,gte,lte"/>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="Value">
<Description>
Value to compare to - may be empty.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>ConditionState</State>
<StreamLocation>^ZPM.Dev.ModuleSetting.ConditionS</StreamLocation>
<Data name="ConditionState">
<Value name="1">
<Value>Attribute</Value>
</Value>
<Value name="2">
<Value>Operator</Value>
</Value>
<Value name="3">
<Value>Value</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Developer.ModuleSetting.ProcessorDefault">
<Super>%ZPM.PackageManager.Developer.ModuleSetting</Super>
<TimeCreated>65797,80972.22917</TimeCreated>

<Property name="Class">
<Description>
Resource processor class to which this default setting applies</Description>
<Type>%Dictionary.CacheClassname</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Attributes">
<Description>
Default attributes to apply to the resources with the specified ProcessorClass</Description>
<Type>%String</Type>
<Collection>array</Collection>
<Parameter name="MAXLEN"/>
<Parameter name="XMLKEYNAME" value="Name"/>
<Parameter name="XMLNAME" value="Attribute"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="Conditions">
<Description>
Conditions under which the default settings apply</Description>
<Type>%ZPM.PackageManager.Developer.ModuleSetting.ProcessorDefault.Condition</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Condition"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<State>ProcessorDefaultState</State>
<Data name="ProcessorDefaultState">
<Subscript>"ProcessorDefault"</Subscript>
<Value name="1">
<Value>Class</Value>
</Value>
<Value name="2">
<Value>Attributes</Value>
</Value>
<Value name="3">
<Value>Conditions</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Developer.ModuleSetting">
<Description>
Abstract class representing a setting applied at the the module level.</Description>
<Abstract>1</Abstract>
<Super>%SerialObject,%XML.Adaptor</Super>
<TimeCreated>65797,80971.9824</TimeCreated>

<Parameter name="NAMESPACE">
<Type>STRING</Type>
<Default>http://www.intersystems.com/PackageManager</Default>
</Parameter>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<StreamLocation>^ZPM.Dev.ModuleSettingS</StreamLocation>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Developer.ModuleTemplate">
<Super>%ZPM.PackageManager.Developer.Module</Super>
<TimeCreated>65797,80971.991463</TimeCreated>

<Property name="TemplateResources">
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="ModuleFolder">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Method name="ExportResources">
<Description>
Export Resources 
Example: ExportList="00000,apptools.,apptools.M^00000,apptools.,apptools.M"</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Path:%String="",ExportList:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set st=$$$OK
		For i=1:1:$Length(ExportList,"^") { Set item=$Piece(ExportList,"^",i)
			Continue:item=""
			Do ..ExportOneResource(Path,$Piece(item,",",1),$Piece(item,",",2),$Piece(item,",",3))	
		}
	Quit st
]]></Implementation>
</Method>

<Method name="ExportOneResource">
<Description><![CDATA[
Export different types of modules in different subfolders in UDL (plain) format
test.dfi -> /dfi/test.dfi
testpkg.test.cls -> /cls/testpkg/test.cls
Fork from https://github.com/intersystems-ru/cache-udl
d ##class(%ZPM.PackageManager.Developer.ModuleTemplate).ExportOneResource("d:\_proj\app","00000","apptools.","apptools.M")
byte=1 isGenerated
byte=2 isSystem
byte=3 isPercented
byte=4 isMapped
byte=5 isDFI]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>workdir="",flags,mask="",ignoremask=""</FormalSpec>
<Implementation><![CDATA[
	///zu(12) namespace directory by default
	If workdir="" Set workdir=zu(12,"")
	#define export(%code, %file) Try {Set sc = $system.OBJ.ExportUDL(%code, %file,"/diffexport")} catch e {s sc=$$$ERROR($$$GeneralError,"Old version")} ##continue
								 Write:sc "Ok" Do:'sc $system.OBJ.DisplayError(sc)

	#define isGenerated(%code) ##class(%RoutineMgr).IsGenerated( %code )
	#define isPercented(%code) ("%" = $Extract(%code))
	#define isMapped(%code) ##class(%RoutineMgr).IsMapped( %code )
	#define log Write !, code, " -> ", $Piece(filename,workdir,2), " "
	
	#define mkdir(%filename) ##continue
			Set path = ##class(%File).GetDirectory( %filename ) ##continue
			If '##class(%File).DirectoryExists( path ) { ##continue
				Set sc = ##class(%File).CreateDirectoryChain( path ) ##continue
				Write !, "mkdir ", path, " ", sc ##continue
			}
						
	w "#; Exporting to ", workdir,!
	#; classes
	Set rs = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:Summary")
	If rs.Execute() {

		While rs.%Next(){

			Set code = rs.Name _ ".cls", isSystem = rs.System
			If ( '$Extract(flags,2) && isSystem ) Continue
			If ( '$Extract(flags,1) && $$$isGenerated( code ) ) Continue
			If ( '$Extract(flags,3) && $$$isPercented( code ) ) Continue
			If ( '$Extract(flags,4) && $$$isMapped( code ) ) Continue
			If mask'="",(("@"_code)'[("@"_mask )) Continue
			If ignoremask'="",(("@"_code)[("@"_ignoremask )) Continue
			
			Set filename = ..Expfilename( code,workdir )
			$$$mkdir( filename )
			$$$log
			$$$export( code, filename )
			Set item(code)=""
		} Set rs=""
	}

	#; routines
	Set rs = ##class(%ResultSet).%New("%Routine:RoutineList")
	If rs.Execute() {
    	While rs.%Next() {
	 		Set code = rs.Name
	 		If ( '$e(flags,1) && $$$isGenerated( code ) ) Continue
	 		If ( '$e(flags,3) && $$$isPercented( code ) ) Continue
			If ( '$e(flags,4) && $$$isMapped( code ) ) Continue
			If ( '$find( code, mask ) ) Continue
			
			Set filename = ..Expfilename( code,workdir )
			$$$mkdir( filename )
			$$$log
			$$$export( code, filename )
			Set item(code)=""
	    } Set rs=""
	}
	#; dfi
	#define export(%code,%file) s sc = ##class(%DeepSee.UserLibrary.Utils).%Export( %code, %file, 0 ) 
	If '$Extract(flags,5) {
		Set sql = "Select fullName as Name From %DeepSee_UserLibrary.FolderItem"
	    Set rs = ##class(%SQL.Statement).%ExecDirect( .stm, sql )
	    While rs.%Next() {
			Set code = rs.Name, filename = ..Expfilename( code_".dfi",workdir )
			If ( '$Find( code, mask ) ) Continue
			If ($Length(code,"$TRASH")>1) Continue
			$$$mkdir( filename )
			$$$log
			$$$export(code,filename)
			Set item(code)=""
		} Set rs=""
	}
	Write !!, "#; Exported to ", workdir
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Expfilename">
<Description><![CDATA[
test.dfi -> /dfi/test.dfi
test.cls -> /cls/test.cls
testpkg.test.cls -> /cls/testpkg/test.cls]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>code,wd</FormalSpec>
<Implementation><![CDATA[
	#define log(%dir,%sc) Write !, "mkdir ", %dir, " ", sc

	If '##class(%File).DirectoryExists( wd ) {
		Set sc = ##class(%File).CreateDirectoryChain( wd )
		$$$log(wd,sc)
	}

	Set ext = $Piece( code, ".", * ), ext = $Zconvert( ext, "l" )
	#; for each type - different directory

	Set:ext'="" wd = ##class(%File).NormalizeDirectory( ext, wd )

	#; directory must exist before any call (%File).NormalizeFilename( , wd)
	If '##class(%File).DirectoryExists( wd ) {
		Set sc = ##class(%File).CreateDirectoryChain( wd )
		$$$log(wd,sc)
	}

	Set filename = ##class(%File).NormalizeFilename( code, wd )
	#; lowercase file extension
	Set $Piece(filename,".",*)=ext
	//B:code="DPRep.Rest.JSON.cls" "L"
	#; for *.cls Package.Subpackage.ClassName.cls -> Folder/Subfolder/ClassName.cls
	If ext ="cls" {
		Set dirs = $Piece( code, ".",1, *-2 ), dirs = $Translate( dirs, ".", "/" )
		Set relpath = dirs _ "/" _ $Piece( code, ".", *-1, * ) ;
		Set filename = ##class(%File).NormalizeFilename( relpath, wd )
	}
	Quit filename
]]></Implementation>
</Method>

<Method name="GetCSPApplications">
<Description>
returns list of non-system csp applications in the current namespace</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pApplications:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set pApplications = ""
    Set currentNamespace = $Namespace
    New $Namespace
    Set $Namespace = "%SYS"
    Set statement = ##class(%SQL.Statement).%New()
    Set tSC = statement.%PrepareClassQuery("Security.Applications", "List")
    Return:$$$ISERR(tSC) tSC
    Set row = statement.%Execute("*")
    While row.%Next(.sc) {
        Return:$$$ISERR(sc) sc
        If ( (row.%Get("Namespace")=currentNamespace) && (row.%Get("IsSystemApp") = 0) && (row.%Get("Type") = "CSP") ) {
            Set pApplications = pApplications_$LB(row.%Get("Name"))
        }
    }
    return $$$OK
]]></Implementation>
</Method>

<Method name="AddWebApps">
<Description>
adds a web application to the temporary array of module resources</Description>
<FormalSpec>pApps:%String,*cspapps:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set tAppList = ""
    Set pApps = $ZSTRIP(pApps,"<>W")
    If ( pApps = "*" ) {
	    Do ..GetCSPApplications(.tAppList)
    } Else { 
        Set tAppList = $Listfromstring(pApps,",")
    }
    Set cspapps = ""
    New $Namespace
    Set $Namespace = "%SYS"
    For i=1:1:$Listlength(tAppList) {
        Set app = ##class(Security.Applications).Get($Listget(tAppList,i),.props)
        Set tAppName = props("Name")
        Set ..TemplateResources(tAppName) = tAppName
        Set ..TemplateResources(tAppName, "Url") = tAppName
 
        If (props("DispatchClass")'="") {
            Set ..TemplateResources(tAppName,"DispatchClass") = props("DispatchClass") 
        } Else {
            Set tCSPDir = ##class(%File).NormalizeDirectory(##class(%File).ParentDirectoryName(##class(%File).ManagerDirectory())_"/csp")
            Set ..TemplateResources(tAppName,"Directory") = $Replace(props("Path"),tCSPDir,"${cspdir}")
            Set cspapps = cspapps_$Listbuild(tAppName)
            
        }
        If ( props("AutheEnabled") = 32 ) {
            Set ..TemplateResources(tAppName,"UnauthenticatedEnabled") = 0
            Set ..TemplateResources(tAppName,"PasswordAuthEnabled") = 1
        } ElseIf ( props("AutheEnabled") = 64 ) {
            Set ..TemplateResources(tAppName,"UnauthenticatedEnabled") = 0
            Set ..TemplateResources(tAppName,"PasswordAuthEnabled") = 1            
        } ElseIf ( props("AutheEnabled") = 96 ) {
            Set ..TemplateResources(tAppName,"UnauthenticatedEnabled") = 1
            Set ..TemplateResources(tAppName,"PasswordAuthEnabled") = 1            
        } Else {
            Set ..TemplateResources(tAppName,"AuthenticationMethods") = props("AutheEnabled")
        }

        // Map subscript of application properties to %Installer.CSPApplication properties 
        Set tMap("AutoCompile") = "AutoCompile"
        Set tMap("AutoCompile","default") = 1
        Set tMap("Enabled") = "Enabled"
        Set tMap("Enabled","default") = 1        
        Set tMap("ChangePasswordPage") = "ChangePasswordPage" 
        Set tMap("ErrorPage") = "CustomErrorPage" 
        Set tMap("SuperClass") = "DefaultSuperclass" 
        Set tMap("Timeout") = "DefaultTimeout" 
        Set tMap("Description") = "Description" 
        Set tMap("EventClass") = "EventClass" 
        Set tMap("MatchRoles") = "MatchRoles" 
        Set tMap("GroupById") = "GroupById" 
        Set tMap("InbndWebServicesEnabled") = "InboundWebServicesEnabled" 
        Set tMap("InbndWebServicesEnabled","default") = 1
        Set tMap("IsNamespaceDefault") = "IsNamespaceDefault" 
        Set tMap("IsNamespaceDefault","default") = 0
        Set tMap("LockCSPName") = "LockCSPName" 
        Set tMap("LockCSPName","default") = 1
        Set tMap("LoginPage") = "LoginClass" 
        Set tMap("Package") = "PackageName" 
        Set tMap("CookiePath") = "CookiePath" 
        Set tMap("UseCookies") = "UseSessionCookie" 
        Set tMap("PermittedClasses") = "PermittedClasses" 
        Set tMap("Recurse") = "Recurse" 
        Set tMap("Recurse","default") = 0
        Set tMap("Resource") = "Resource" 
        Set tMap("ServeFiles") = "ServeFiles" 
        Set tMap("ServeFilesTimeout") = "ServeFilesTimeout" 
        Set tMap("TwoFactorEnabled") = "TwoFactorEnabled" 
        Set tMap("TwoFactorEnabled","default") = 0

        Set tAttr = ""
        For {
            Set tAttr = $Order(tMap(tAttr))
            Quit:(tAttr="")
            Continue:('$Data(props(tAttr)))
            If (props(tAttr)'=$Get(tMap(tAttr,"default"))) {
                Set ..TemplateResources(tAppName,$Get(tMap(tAttr)))=props(tAttr)
            }
        }
    }
    Return $$$OK
]]></Implementation>
</Method>

<Method name="SetSourcePathForCSPApp">
<FormalSpec>pCSPApp,pPath</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Set ..TemplateResources(pCSPApp,"Path") = pPath
]]></Implementation>
</Method>

<Method name="GetGlobalsList">
<ClassMethod>1</ClassMethod>
<FormalSpec>*globals:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set globals=""
    Set statement = ##class(%SQL.Statement).%New()
    Set tSC = statement.%PrepareClassQuery("%SYS.GlobalQuery", "NameSpaceList")
    Return:$$$ISERR(tSC) tSC
    Set row = statement.%Execute($Namespace, "*", 0, , ,1,0)
    While row.%Next(.sc) {
        Return:$$$ISERR(sc) sc
        Set globals = globals_$Listbuild(row.%Get("Name"))
    }
    Return $$$OK
]]></Implementation>
</Method>

<Method name="ReadGlobals">
<Description>
pSearchString - a mask, or comma-separated list of masks, to select globals</Description>
<FormalSpec>pSearchString:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    If (pSearchString="") { Return $$$OK }
    Set statement = ##class(%SQL.Statement).%New()
    Set tSC = statement.%PrepareClassQuery("%SYS.GlobalQuery", "NameSpaceList")
    Return:$$$ISERR(tSC) tSC
    Set row = statement.%Execute($Namespace, pSearchString, 0, , ,1,0)
    While row.%Next(.sc) {
        Return:$$$ISERR(sc) sc
        Set ..TemplateResources("gbl"_row.%Get("Name")) = row.%Get("Name")
        Set ..TemplateResources("gbl"_row.%Get("Name"),"Directory") = "gbl"
    }
    Return $$$OK
]]></Implementation>
</Method>

<Method name="AddDependant">
<Description>
add dependancy</Description>
<FormalSpec>pDependant:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set tName = $Piece(pDependant,":",1)
    Set tVersion = $Piece(pDependant,":",2)
    If (tName="")||(tVersion="") { Return $$$OK }
    Set tModule = ##class(%ZPM.PackageManager.Core.ModuleReference).%New()
    Set tModule.Name = tName
    Do tModule.VersionStringSet(tVersion)
    Return ..Dependencies.Insert(tModule)
]]></Implementation>
</Method>

<Method name="GenerateTemplate">
<Description>
creates a module.xml file with fictional data</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPath:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Return:(pPath="") $$$OK 
    Set tTemplate = ..%New()
    Do tTemplate.SetTemplateProps()
    Return tTemplate.SaveFile(pPath)
]]></Implementation>
</Method>

<Method name="SetAuthorProps">
<FormalSpec>pPerson:%String="",pOrg:%String="",pCopy:%String="",pLicense:%String="",pNotes:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set tAuthor = ##class(%ZPM.PackageManager.Developer.ModuleAuthorInfo).%New()
    Set tAuthor.Person = pPerson
    Set tAuthor.Organization = pOrg
    Set tAuthor.CopyrightDate = pCopy
    Set tAuthor.License = pLicense
    Set tAuthor.Notes = pNotes
    Set ..Author = tAuthor
    Return $$$OK
]]></Implementation>
</Method>

<Method name="NewTemplate">
<ClassMethod>1</ClassMethod>
<FormalSpec>pPath,pName,pVersion,pDescription="",pKeywords=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set tTemplate = ..%New()
    Set tTemplate.ModuleFolder = ##class(%File).NormalizeDirectory(pPath)
    Set tTemplate.Name = pName
    Set tTemplate.VersionString = pVersion
    Set tTemplate.Description = pDescription
    Set tTemplate.Keywords = pKeywords
    Set tTemplate.Packaging = "module"
    Return tTemplate
]]></Implementation>
</Method>

<Method name="ReadResorces">
<FormalSpec>pFolder</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set exts = $Listbuild("cls","mac","inc","int")
    If (($Extract(pFolder,1)="/") || ($Extract(pFolder,1)="\")) {
        Set pFolder = $Extract(pFolder,2,*)
    }
    Set ..SourcesRoot = pFolder
    Set tSC = ..ReadFolder(..ModuleFolder_pFolder, .files)
    Return:$$$ISERR(tSC) tSC
    Set tFile = ""
    For {
        Set tFile = $Order(files(tFile))
        Quit:(tFile="")
        Set tFileExt = $zcvt($p( tFile, ".", * ),"l")
        If ('$Listfind(exts,tFileExt)) {
            Continue
        }
        Set tSC = $System.OBJ.Load(tFile,"-d",,.tLoadedList,1)
        If $$$ISERR(tSC) {
            // Wasn't a valid file. We'll just continue.
            Continue
        }
        
        Set pDir = ""
        for i=##class(%File).GetDirectoryLength(..ModuleFolder_pFolder)+1:1:##class(%File).GetDirectoryLength(##class(%File).GetDirectory(tFile))-$Length(tLoadedList,".")+2 {
            Set pDir = pDir_"/"_##class(%File).GetDirectoryPiece(##class(%File).GetDirectory(tFile),i)
        }
        If (($Extract(pDir,1)="/") || ($Extract(pDir,1)="\")) {
            Set pDir = $Extract(pDir,2,*)
        }
        Set ..TemplateResources(tFile) = tLoadedList
        If (pDir'="") {
            Set ..TemplateResources(tFile,"Directory") = pDir
        }          
    }

    // instead of classes individually use packages (.PKG)
    Set key = ""
    Kill resource
    For {
        Set key = $Order(..TemplateResources(key))
        Quit:(key="")
        If ( "cls" = $zcvt($p( ..TemplateResources(key), ".", * ),"l") ) {
            Set pPath = ##class(%File).NormalizeDirectory(..ModuleFolder_pFolder) 
            Set pPKGName = $p( ..TemplateResources(key), ".", 1 ) 
            If ( $Data(resource(pPath_pPKGName)) && $Get(resource(pPath_pPKGName, "Directory"))=$Get(..TemplateResources(key,"Directory")) ) {
                Merge resource(key) = ..TemplateResources(key)
            } Else {
                Set resource(pPath_pPKGName) = pPKGName_".PKG"
                If ($Data(..TemplateResources(key,"Directory"))) {
                    Set resource(pPath_pPKGName, "Directory") = ..TemplateResources(key,"Directory")
                }
            }
        } Else {
            Merge resource(key) = ..TemplateResources(key)
        }
        
    }
    kill ..TemplateResources
    Merge ..TemplateResources = resource
    Return $$$OK
]]></Implementation>
</Method>

<Method name="ProcessResources">
<Implementation><![CDATA[
    merge resources = ..TemplateResources
    Set key = ""
	For {
		Set key = $Order(resources(key))
		Quit:(key="")
		Set resource = ##class(%ZPM.PackageManager.Developer.ResourceReference).%New()
		Set resource.Name = $Get(resources(key),"resourceName")
		Set att = ""
		For {
			Set att = $Order(resources(key,att))
			Quit:(att="")
			Do resource.Attributes.SetAt($Get(resources(key,att),"value"),att)
		}
		Set resource.Module = $this
	}
]]></Implementation>
</Method>

<Method name="ReadFolder">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pPath,&files]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set pPath =  ##class(%File).NormalizeDirectory(pPath)   
    If '##class(%File).DirectoryExists(pPath) { Return $$$ERROR(5001, "Directory "_pPath_" doesn't exist") }
    
    Set statement = ##class(%SQL.Statement).%New()
    Set tSC = statement.%PrepareClassQuery("%File", "FileSet")
    Return:$$$ISERR(tSC) tSC
    Set row = statement.%Execute(pPath)
    While row.%Next(.sc) {
        Return:$$$ISERR(sc) sc
        If ( row.%Get("Type") = "D" ) {
            Do ..ReadFolder(row.%Get("Name"), .files)
        } ElseIf ( row.%Get("Type") = "F" ) {
            Set files(row.%Get("Name"))=""
        }
    }
    Return $$$OK
]]></Implementation>
</Method>

<Method name="SetTemplateProps">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set ..Name = "template"
    Set ..VersionString = "1.0.0"
    Set ..Description = "description"
    Set ..Keywords = "keywords"
	Set ..Author = ##class(%ZPM.PackageManager.Developer.ModuleAuthorInfo).%New()
	Set ..Author.Person = "your name"
	Set ..Author.Organization = "your organization"
	Set ..Author.CopyrightDate = $Piece($ZDate($Now(),3),"-")
	Set ..Author.License = "MIT"
	Set ..Author.Notes = "notes"

    Set tModule = ##class(%ZPM.PackageManager.Core.ModuleReference).%New()
    Set tModule.Name = "module"
    Do tModule.VersionStringSet("1.*")
    Do ..Dependencies.Insert(tModule)

    Set ..Packaging = "module"
    Set ..SourcesRoot = "src"

	Set ..TemplateResources("inc") = "MyPackage.First.INC"
	Set ..TemplateResources("inc","Directory")="inc"

	Set ..TemplateResources("mac") = "MyPackage.FirstRoutine.MAC"
	Set ..TemplateResources("mac","Directory") = "mac"

	Set ..TemplateResources("cls") = "MyPackage.Demo.CLS"
	Set ..TemplateResources("cls","Directory") = "cls"	

	Set ..TemplateResources("pkg") = "Sample.PKG"
	Set ..TemplateResources("pkg","Directory") = "cls"

    Set ..TemplateResources("gbl") = "MyApp.Settings.GBL"
    Set ..TemplateResources("gbl","Directory") = "gbl"

	Set ..TemplateResources("test") = "/tests/unit_tests/"
	Set ..TemplateResources("test","Package") = "Test.Unit"
	Set ..TemplateResources("test","Phase") = "test"

	// REST APP
	Set ..TemplateResources("rest") = "/crud"
	Set ..TemplateResources("rest","Url") = "/crud"
	Set ..TemplateResources("rest","CookiePath") = "/crud"
	Set ..TemplateResources("rest","UseCookies") = 2
	Set ..TemplateResources("rest","DispatchClass") = "Sample.REST"
	Set ..TemplateResources("rest","PasswordAuthEnabled") = 1
	Set ..TemplateResources("rest","UnauthenticatedEnabled") = 0
	Set ..TemplateResources("rest","Recurse") = 1

	// WEB APP
	Set ..TemplateResources("web") = "/web"
	Set ..TemplateResources("web","Url") = "/web"
	Set ..TemplateResources("web","CookiePath") = "/web"
	Set ..TemplateResources("web","UseCookies") = 2
	Set ..TemplateResources("web","PasswordAuthEnabled") = 1
	Set ..TemplateResources("web","UnauthenticatedEnabled") = 0
	Set ..TemplateResources("web","Recurse") = 1
	Set ..TemplateResources("web","ServeFiles") = 1
	Set ..TemplateResources("web","Directory") = "{$cspdir}myapp"
	Set ..TemplateResources("web","Path") = "/web"

    Do ..ProcessResources()

    Return $$$OK
]]></Implementation>
</Method>

<Method name="SaveFile">
<FormalSpec>pPath:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Return:(pPath="") $$$OK
    // If pPath doesn't exists - create one 
    If ('##class(%File).DirectoryExists(pPath)) {
        If ('##class(%File).CreateDirectoryChain(pPath)) {
            $$$ThrowStatus($$$ERROR(5001,"Error creating directory: "_pPath))
        }
    }

    Set tFileName = pPath_"module.xml"
    // If module.xml already exists - rename old one
	If (##class(%File).Exists(tFileName)) {
		If ('##class(%File).Rename(tFileName,pPath_"module_"_##class(%PosixTime).CurrentUTCTimeStamp(6)_".xml")){
			$$$ThrowStatus($$$ERROR(5001,"error renaming existing file:"_tFileName))
		}
	}

    // save 
    Try {
        $$$ThrowOnError(..XMLExportToStream(.tStream))
        Set tXSL=##class(%Dictionary.CompiledXData).%OpenId("%ZPM.PackageManager.Developer.Document.Module||ExternalXSL").Data
        $$$ThrowOnError(##class(%XML.XSLT.Transformer).TransformStream(tStream, tXSL, .tOutput))

        Set tXSL = ##class(%Dictionary.CompiledXData).%OpenId(..%ClassName(1)_"||XSLT").Data
        $$$ThrowOnError(##class(%XML.XSLT.Transformer).TransformStream(tOutput, tXSL, .tXMLStream))

        Set tSC = ##class(%XML.Document).GetDocumentFromStream(tXMLStream, .tDoc)

	    Set tXML = ##class(%XML.Writer).%New()
        Set tXML.NoXMLDeclaration = 0
	    Set tXML.Indent = 2
        $$$ThrowOnError(tXML.OutputToFile(tFileName))
        $$$ThrowOnError(tXML.Document(tDoc))
        $$$ThrowOnError(tXML.EndDocument())
    } Catch ex {
        $$$ThrowStatus($$$ERROR(5001,"Unable to save: "_tFileName))
    }
	Quit $$$OK
]]></Implementation>
</Method>

<XData name="XSLT">
<Data><![CDATA[
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:output omit-xml-declaration="yes" method="xml" encoding="utf-8" indent="yes" />
  <xsl:strip-space elements="*" />

  <xsl:template match="/ModuleTemplate">
    <Export generator="Cache" version="25"> 
        <Document>
            <xsl:attribute name="name"><xsl:value-of select="Name" />.ZPM</xsl:attribute>
            <Module>
                <xsl:apply-templates select="*" />
            </Module>
        </Document>
    </Export>
  </xsl:template>
  <xsl:template match="Resource[@Url]">
    <CSPApplication>
        <xsl:apply-templates select="@*[local-name() != 'Name']" />
    </CSPApplication>
  </xsl:template>
  <xsl:template match="node()">
    <xsl:copy>
      <xsl:apply-templates select="@*|node()" />
    </xsl:copy>
  </xsl:template>
  <xsl:template match="@*">
    <xsl:choose>
		<xsl:when test="(name()='Directory') and (.!='') and ../@Url"><xsl:attribute name="DeployPath"><xsl:value-of select="." /></xsl:attribute></xsl:when>   
        <xsl:when test="(name()='Directory') and (.='')"></xsl:when>   
 		<xsl:when test="name()='Path'"><xsl:attribute name="SourcePath"><xsl:value-of select="." /></xsl:attribute></xsl:when>
        <xsl:otherwise><xsl:copy></xsl:copy></xsl:otherwise>
    </xsl:choose>
  </xsl:template>
</xsl:stylesheet>
]]></Data>
</XData>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>ModuleTemplateDefaultData</DefaultData>
<Data name="ModuleTemplateDefaultData">
<Subscript>"ModuleTemplate"</Subscript>
<Value name="1">
<Value>ModuleFolder</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.Abstract">
<Description>
Superclass for all classes used to process lifecycle events for resources</Description>
<Abstract>1</Abstract>
<IncludeCode>%ZPM.PackageManager.Common</IncludeCode>
<PropertyClass>%ZPM.PackageManager.Developer.Processor.PropertyParameters</PropertyClass>
<Super>%RegisteredObject</Super>
<TimeCreated>65797,80972.303598</TimeCreated>

<Parameter name="NAME">
<Expression>$Piece(%classname, ".", *)</Expression>
</Parameter>

<Parameter name="DESCRIPTION">
<Description>
Description of resource processor class (shown in UI)</Description>
<Type>STRING</Type>
</Parameter>

<Parameter name="ATTRIBUTES">
<Description>
Comma-separated list of resource attribute names that this processor uses</Description>
<Type>STRING</Type>
</Parameter>

<Property name="ResourceReference">
<Type>%ZPM.PackageManager.Developer.ResourceReference</Type>
<Private>1</Private>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="Params">
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="%OnNew">
<FormalSpec>pResourceReference:%ZPM.PackageManager.Developer.ResourceReference</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set ..ResourceReference = pResourceReference
	Do ..CopyAttributes()
	Do ..ApplyDefaults()
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SetParams">
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ($Data(pParams)) {
		Merge ..Params = pParams
		Do ..CopyAttributes()
		Do ..ApplyDefaults()
	}
	Return $$$OK
]]></Implementation>
</Method>

<Method name="CopyAttributes">
<CodeMode>objectgenerator</CodeMode>
<Private>1</Private>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tAttributes = $ListFromString(%parameter("ATTRIBUTES"))
		Set tPtr = 0
		While $ListNext(tAttributes,tPtr,tAttribute) {
			If $$$comMemberDefined(%compiledclass.Name,$$$cCLASSproperty,tAttribute) {
				If '$ZName(tAttribute,6) {
					Set tMsg = $$$FormatText("Invalid property in ATTRIBUTES list: '%1'",tAttribute)
					$$$ThrowStatus($$$ERROR($$$GeneralError,tMsg))
				}
        Set tProps = $ListFromString($$$defMemberKeyGet(%compiledclass.Name,$$$cCLASSproperty,tAttribute,$$$cPROPaliases))
        Set tProps = tProps _ $lb(tAttribute)
        set tPtr1 = 0
        while $ListNext(tProps, tPtr1, tAttribute) {
          Do %code.WriteLine(" Set tIsDefined = ..ResourceReference.Attributes.IsDefined("""_tAttribute_""")")
          Do %code.WriteLine(" If tIsDefined {")
          Do %code.Write("  Set .."_tAttribute_" = ")
          Set tDataType = $$$comMemberKeyGet(%compiledclass.Name,$$$cCLASSproperty,tAttribute,$$$cPROPruntimetype)
          Set tAttrValue = "..%Evaluate(..ResourceReference.Attributes.GetAt("""_tAttribute_"""))"
          Do %code.WriteLine("$Select($$$comMemberDefined($classname(),$$$cCLASSmethod,"""_tAttribute_"XSDToLogical""):$classmethod($classname(),"""_tAttribute_"XSDToLogical"","_tAttrValue_"),1:"_tAttrValue_")")
          Do %code.WriteLine(" }")
        }
			}
		}
		
		// Always generate something, to avoid <METHOD DOES NOT EXIST>
		Do %code.WriteLine(" Quit")
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ApplyDefaults">
<Implementation><![CDATA[
	Set tDefaults = ..ResourceReference.Module.Defaults
	For tDefaultIndex = 1:1:tDefaults.Count() {
		Set tDefault = tDefaults.GetAt(tDefaultIndex)
		If tDefault.%IsA("%ZPM.PackageManager.Developer.ModuleSetting.ProcessorDefault") {
			#dim tDefault As %ZPM.PackageManager.Developer.ModuleSetting.ProcessorDefault
			Set tThisClass = $ClassName()
			Set tFullClass = $$$DefaultProcessorPackageDot_tDefault.Class
			If (tThisClass = tDefault.Class) || (tThisClass = tFullClass) {
				Set tSatisfiesConditions = 1
				For tIndex = 1:1:tDefault.Conditions.Count() {
					Set tSatisfiesConditions = tSatisfiesConditions && ..SatisfiesCondition(tDefault.Conditions.GetAt(tIndex))
					If 'tSatisfiesConditions {
						Quit
					}
				}
				If tSatisfiesConditions {
					Do ..CopyDefaultAttributes(tDefault)
				}
			}
		}
	}
]]></Implementation>
</Method>

<Method name="CopyDefaultAttributes">
<Description><![CDATA[
Generated similarly to <method>CopyAttributes</method>]]></Description>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>pSource:%ZPM.PackageManager.Developer.ModuleSetting.ProcessorDefault</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tAttributes = $ListFromString(%parameter("ATTRIBUTES"))
		Set tPtr = 0
		While $ListNext(tAttributes,tPtr,tAttribute) {
			If $$$comMemberDefined(%compiledclass.Name,$$$cCLASSproperty,tAttribute) {
				If '$ZName(tAttribute,6) {
					Set tMsg = $$$FormatText("Invalid property in ATTRIBUTES list: '%1'",tAttribute)
					$$$ThrowStatus($$$ERROR($$$GeneralError,tMsg))
				}
				Do %code.WriteLine(" Set tIsDefined = pSource.Attributes.IsDefined("""_tAttribute_""") && '..ResourceReference.Attributes.IsDefined("""_tAttribute_""")")
				Do %code.WriteLine(" If tIsDefined {")
				Do %code.Write("  Set .."_tAttribute_" = ")
				Set tDataType = $$$comMemberKeyGet(%compiledclass.Name,$$$cCLASSproperty,tAttribute,$$$cPROPruntimetype)
				Set tAttrValue = "..%Evaluate(pSource.Attributes.GetAt("""_tAttribute_"""))"
				Do %code.WriteLine("$Select($$$comMemberDefined($classname(),$$$cCLASSmethod,"""_tAttribute_"XSDToLogical""):$classmethod($classname(),"""_tAttribute_"XSDToLogical"","_tAttrValue_"),1:"_tAttrValue_")")
				Do %code.WriteLine(" }")
			}
		}
		
		// Always generate something, to avoid <METHOD DOES NOT EXIST>
		Do %code.WriteLine(" Quit")
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="SatisfiesCondition">
<FormalSpec>pCondition:%ZPM.PackageManager.Developer.ModuleSetting.ProcessorDefault.Condition</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tValue = $Property($This, pCondition.Attribute)
	Quit $Case(pCondition.Operator,
		"eq":(tValue = pCondition.Value),
		"neq":(tValue '= pCondition.Value),
		"gt":(tValue > pCondition.Value),
		"lt":(tValue < pCondition.Value),
		"gte":(tValue >= pCondition.Value),
		"lte":(tValue <= pCondition.Value),
		:(tValue = pCondition.Value))
]]></Implementation>
</Method>

<Method name="GetAttributeMetadata">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>*pMetaArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tAttributes = $ListFromString(%parameter("ATTRIBUTES"))
	Set tPtr = 0
	While $ListNext(tAttributes,tPtr,tAttribute) {
		If $$$comMemberDefined(%compiledclass.Name,$$$cCLASSproperty,tAttribute) {
			Set tType = $$$QUOTE($$$comMemberArrayGet(%compiledclass.Name,$$$cCLASSproperty,tAttribute,$$$cPROPparameter,"XSDTYPE"))
			// Different version of $$$QUOTE to convert newlines into $c(10) (for example) - this is what zwrite calls.
			Set tDesc = $$Quote^%qcr($$$comMemberKeyGet(%compiledclass.Name,$$$cCLASSproperty,tAttribute,$$$cPROPdescription))
			Set tDefault = $$$comMemberKeyGet(%compiledclass.Name,$$$cCLASSproperty,tAttribute,$$$cPROPinitialexpression)
			Set tAttributeRequired = $$$comMemberArrayGet(%compiledclass.Name,$$$cCLASSproperty,tAttribute,$$$cPROPparameter,"ATTRIBUTEREQUIRED")
			Set tRequired = $Case(tAttributeRequired,
				"":$$$comMemberKeyGet(%compiledclass.Name,$$$cCLASSproperty,tAttribute,$$$cPROPrequired),
				:tAttributeRequired)
			Set tValueList = $$$QUOTE($$$comMemberArrayGet(%compiledclass.Name,$$$cCLASSproperty,tAttribute,$$$cPROPparameter,"VALUELIST"))
			Set tDisplayList = $$$QUOTE($$$comMemberArrayGet(%compiledclass.Name,$$$cCLASSproperty,tAttribute,$$$cPROPparameter,"DISPLAYLIST"))
			Set tMINLEN = $$$QUOTE($$$comMemberArrayGet(%compiledclass.Name,$$$cCLASSproperty,tAttribute,$$$cPROPparameter,"MINLEN"))
			Set tMAXLEN = $$$QUOTE($$$comMemberArrayGet(%compiledclass.Name,$$$cCLASSproperty,tAttribute,$$$cPROPparameter,"MAXLEN"))
			Set tMINVAL = $$$QUOTE($$$comMemberArrayGet(%compiledclass.Name,$$$cCLASSproperty,tAttribute,$$$cPROPparameter,"MINVAL"))
			Set tMAXVAL = $$$QUOTE($$$comMemberArrayGet(%compiledclass.Name,$$$cCLASSproperty,tAttribute,$$$cPROPparameter,"MAXVAL"))
			Do %code.WriteLine(" Set pMetaArray($i(pMetaArray)) = $ListBuild("_$$$QUOTE(tAttribute)_","_tType_","_tDesc_","_tDefault_","_tRequired_","_tValueList_","_tDisplayList_","_tMINLEN_","_tMAXLEN_","_tMINVAL_","_tMAXVAL_")")
		}
	}
	Do %code.WriteLine(" Quit $$$OK")
]]></Implementation>
</Method>

<Method name="OnBeforePhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Default implementation: call %ValidateObject to validate attributes
	Set tSC = $$$OK
	Try {
		If (pPhase = "Validate") {
			Set tSC = ..%ValidateObject(1)
			If $$$ISERR(tSC) {
				Set tSC = $System.Status.EmbedStatus($$$ERROR($$$GeneralError,$$$FormatText("Error validating resource '%1'",..ResourceReference.Name)),tSC)
				Quit
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnPhase">
<Description><![CDATA[
Called as phase <var>pPhase</var> is executed for the resource. If <var>pResourceHandled</var> is set to true,
then the default behavior for that resource will be bypassed in the current phase.
Currently, this is only used in the Verify phase, because of different handling of intermediate error statuses.
TODO: Implement for standard database resources (.INC, .CLS, etc.)]]></Description>
<FormalSpec><![CDATA[pPhase:%String,&pParams,*pResourceHandled:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnAfterPhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnExportItem">
<FormalSpec><![CDATA[pFullExportPath:%String,pItemName:%String,&pItemParams,&pParams,*pItemHandled:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnBeforeArtifact">
<FormalSpec><![CDATA[pExportDirectory:%String,pWorkingDirectory:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnResolveChildren">
<FormalSpec><![CDATA[&pResourceArray]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnGetUniqueName">
<Description><![CDATA[
Returns a unique name for this resource.
Default implementation, leaving <var>pUniqueName</var> undefined, reverts to default behavior.
An empty string indicates guaranteed uniqueness (useful for folders relative to module root)]]></Description>
<FormalSpec>*pUniqueName</FormalSpec>
</Method>

<Method name="%Evaluate">
<Description>
Evaluates an expression in an attribute
Current valid expressions:
{$namespace} - the current namespace
{$mgrdir} - the instance's mgr directory
{$cspdir} - the instance's root CSP directory
{$root} - the resource's module's root directory
These special expressions are case-insensitive.</Description>
<Internal>1</Internal>
<FormalSpec>pAttrValue</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tAttrValue = pAttrValue
	If $Data(..Params) {
		Merge tParams = ..Params
		Do ##class(%ZPM.PackageManager.Developer.ModuleSetting.Default).GetCustomParameters(.customParams,..ResourceReference.Module, .tParams)
		Set tAttrValue = ##class(%ZPM.PackageManager.Developer.ModuleSetting.Default).EvaluateAttribute(tAttrValue,.customParams)
	}

  Quit ..ResourceReference.Module.%Evaluate(tAttrValue)
]]></Implementation>
</Method>

<Method name="GetDescription">
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[	Quit $Parameter(pClassName,"DESCRIPTION")
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.AbstractCompilable">
<Abstract>1</Abstract>
<Super>%ZPM.PackageManager.Developer.Processor.Abstract</Super>
<TimeCreated>65797,80972.279297</TimeCreated>

<Parameter name="DESCRIPTION">
<Description>
Description of resource processor class (shown in UI)</Description>
<Type>STRING</Type>
</Parameter>

<Parameter name="ATTRIBUTES">
<Description>
Comma-separated list of resource attribute names that this processor uses</Description>
<Type>STRING</Type>
<Default>CompileAfter,Flags</Default>
</Parameter>

<Property name="CompileAfter">
<Description>
Comma-separated list of resource names after which this resource should be compiled.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Flags">
<Description>
Flags/qualifiers to compile with (overriding any more general defaults); "verbose" added per lifecycle command.</Description>
<Type>%String</Type>
<InitialExpression>"ck"</InitialExpression>
<Parameter name="MAXLEN"/>
</Property>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.CSPApplication">
<IncludeCode>%sySecurity,%occErrors</IncludeCode>
<Super>%ZPM.PackageManager.Developer.Processor.Abstract,%XML.Adaptor,%Installer.CSPApplication</Super>
<TimeCreated>65797,80972.320171</TimeCreated>

<Parameter name="DESCRIPTION">
<Description>
Description of resource processor class (shown in UI)</Description>
<Type>STRING</Type>
<Default>Facilitates CSP application definition/configuration during module installation process.</Default>
</Parameter>

<Parameter name="ATTRIBUTES">
<Expression>""_
	// Not in any version of %Installer.CSPApplication (and probably shouldn't be)
	"PasswordAuthEnabled,UnauthenticatedEnabled,DelegatedAuthEnabled,KerberosAuthEnabled,"_
	
	// Not in any version of %Installer.CSPApplication (but maybe should be)
	"Enabled,DeepSeeEnabled,iKnowEnabled,"_
	
	// Not in all reasonably modern versions of %Installer.CSPApplication
	"DispatchClass,MatchRoles,"_ 
	
	// The rest of these are in all reasonably modern versions of %Installer.CSPApplication
	// From: Write ##class(%ZPM.PackageManager.Developer.Processor.CSPApplication).GetInheritedProperties()
	// "Grant" removed (since it's replaced by "MatchRoles")
	##class(%ZPM.PackageManager.Developer.Utils).GetInstallerProperties("CSPApplication", "Grant")</Expression>
</Parameter>

<Parameter name="XMLNAME">
<Description>
Overridden to avoid issues in %Installer generation</Description>
<Default>ZPMCSPApplication</Default>
</Parameter>

<Parameter name="XMLTYPE">
<Description>
Overridden to avoid issues in %Installer generation</Description>
<Default>ZPMCSPApplication</Default>
</Parameter>

<Property name="Enabled">
<Description>
Enabled</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="DeepSeeEnabled">
<Description>
DeepSee Enabled</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="iKnowEnabled">
<Description>
iKnow Enabled</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="PasswordAuthEnabled">
<Description>
Password authentication enabled</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="UnauthenticatedEnabled">
<Description>
Unauthenticated access enabled</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="DelegatedAuthEnabled">
<Description>
Delegated authentication enabled</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="KerberosAuthEnabled">
<Description>
Kerberos authentication enabled</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="DispatchClass">
<Description>
If defined, this will dispatch all requests in this CSP application to this one class</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="256"/>
</Property>

<Property name="MatchRoles">
<Description>
Mapping of Match Roles to added Target Role</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="32767"/>
</Property>

<Property name="CookiePath">
<Description>
Cookie Path</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="256"/>
</Property>

<Property name="Keep">
<Description>
Do not delete during uninstall</Description>
<Type>%Boolean</Type>
<Internal>1</Internal>
</Property>

<Property name="Directory">
<Description>
Physical path for CSP files</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="ATTRIBUTEREQUIRED" value="0"/>
<Parameter name="MAXLEN" value="1024"/>
</Property>

<Method name="%OnNew">
<FormalSpec>pResourceReference:%ZPM.PackageManager.Developer.ResourceReference</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
  Set tSC = ##super(pResourceReference)
  Set ..Url = $ZConvert(..Url,"L")
  new $namespace
  If ..Url = "" {
    Set ..Keep = 1
    Set ..Url = $system.CSP.GetDefaultApp($NAMESPACE)
    Set $namespace = "%SYS"
    Set tSC = ##class(Security.Applications).Get(..Url,.tProperties)
    Set ..Directory = ##class(%File).NormalizeDirectory(..Directory, $Get(tProperties("Path")))
  }
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnAfterPhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tSC = ##super(pPhase,.pParams)
		If $$$ISERR(tSC) {
			Quit
		}
		Set tSC = ..OnPhaseInternal("After",pPhase,.pParams)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnBeforePhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tResourceDir = ##class(%File).NormalizeDirectory(..ResourceReference.Module.Root_..ResourceReference.Name)
		If (..Directory = "") && (..DispatchClass = "") {
			Set ..Directory = tResourceDir
		} ElseIf (..Directory '= "") {
			Set ..Directory = ##class(%File).NormalizeDirectory(..Directory)
		} ElseIf (..DispatchClass '= "") {
			// To make validation pass
			Set ..Directory = "<irrelevant>"
		}
		
		Set tSC = ##super(pPhase,.pParams)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tSC = ..OnPhaseInternal("Before",pPhase,.pParams)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnPhaseInternal">
<FormalSpec><![CDATA[pTime:%String,pPhase:%String,&pParams]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tCopyFiles = 1
		Set tRoot = $Get(pParams("RootDirectory"),..ResourceReference.Module.Root)
		Set tResourceDir = ##class(%File).NormalizeDirectory(tRoot_..ResourceReference.Name)
		If (..Directory = tResourceDir) || (..Directory = "<irrelevant>") || (..Directory = "") {
			Set tCopyFiles = 0
		}
		
		Set ..CookiePath = $ZConvert(..CookiePath,"L")

		If ..Directory = "<irrelevant>" {
			Set ..Directory = ""
		}
		
		Set tVerbose = $Get(pParams("Verbose"))
		Set tIsApplication = ..ResourceReference.Module.Lifecycle.%IsA(##class(%ZPM.PackageManager.Developer.Lifecycle.Application).%ClassName(1))
		
		// TODO: Make mirror-safe?
		// Would require moving mirror-safe APIs to the package manager - at which point, why not just have the package manager manage the whole federation?
		If (pTime = "Before") && ((pPhase = "Configure") || ((pPhase = "Activate") && tIsApplication)) {
			// Create CSP application
			Set tSC = ..CreateOrUpdateCSPApp(tVerbose)
			If $$$ISERR(tSC) {
				Quit
			}
		} ElseIf (pTime = "Before") && ((pPhase = "Unconfigure") || ((pPhase = "Clean") && tIsApplication)) {
			// Remove CSP application; don't copy files!
			Set tSC = ..DeleteCSPApp(tVerbose)
			Set tCopyFiles = 0
		} ElseIf (pTime = "After") && (pPhase = "Reload") {
			// Copy files to physical directory if it already exists
			// TODO: Content Manager?
			Set tCopyFiles = tCopyFiles && (..Directory '= "") && ##class(%File).DirectoryExists(..Directory) 
		} Else {
			Set tCopyFiles = 0
		}
		
		// If Directory was specified, move resources from module root to that directory
		If (tCopyFiles) {
			// Make directory writeable first (so read-only files can be overwritten)
			If ##class(%File).DirectoryExists(..Directory) {
				$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.File).MakeDirectoryWriteable(..Directory,.tCmd,.tOutputLog,.tErrLog))
			
				If (tVerbose) {
					Write !,tCmd
					For i=1:1:$Get(tOutputLog) {
						If (tOutputLog(i) '= "") {
							Write !,tOutputLog(i)
						}
					}
				}
				For i=1:1:$Get(tErrLog) {
					If (tErrLog(i) '= "") {
						Write !,tErrLog(i)
					}
				}
			}
			
			// Actually copy the directory
			$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.File).CopyDir(tResourceDir,..Directory,, tVerbose))
			
			// And also make directory writeable afterward (because read-only files were copied in)
			$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.File).MakeDirectoryWriteable(..Directory,.tCmd,.tOutputLog,.tErrLog))
			If (tVerbose) {
				Write !,tCmd
				For i=1:1:$Get(tOutputLog) {
					If (tOutputLog(i) '= "") {
						Write !,tOutputLog(i)
					}
				}
			}
			For i=1:1:$Get(tErrLog) {
				If (tErrLog(i) '= "") {
					Write !,tErrLog(i)
				}
			}
			
			// Clear CSPGateway cache of these files.
			Set tClearFiles = ..Url_$Case($Extract(..Url,*),"/":"",:"/")_"*"
			If (tVerbose) {
				Write !,"Clearing CSPGateway cache of ",tClearFiles
			}
			Set tRegistry = $System.CSP.GetGatewayRegistry()
			Set tSC = tRegistry.RemoveFilesFromCaches($ListBuild(tClearFiles))
			$$$ThrowOnError(tSC)
			
			// TODO: Content Manager?
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ReplaceMatchRoles">
<FormalSpec>matchRoles:%String,dbDir:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set templates = $Listbuild("{$dbrole}", "${dbrole}")
	For i=1:1:$Listlength(templates) {
		Set template = $Listget(templates, i)
		If matchRoles[template {
			Set dbRole = "%DB_DEFAULT"
			Set db = ##class(SYS.Database).%OpenId(dbDir)
			If $Isobject(db) {
				Set dbRole = db.ResourceName
			}
			Set matchRoles = $Replace(matchRoles, template, dbRole)
		}
	}
	Return matchRoles
]]></Implementation>
</Method>

<Method name="CreateOrUpdateCSPApp">
<Internal>1</Internal>
<FormalSpec>pVerbose:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// TODO: Make mirror-safe.
	
  Set tSC = $$$OK
  If (..Keep) {
    Return $$$OK
  }
	Try {
		Set tOrigNS = $Namespace
		Set dbDir = $$$defdir
		New $namespace
		Set $namespace="%SYS"
		
		// Map properties of this object (inherited from %Installer.CSPApplication) to subscripts of tProperties
		// In other cases, the default mapping is accepted.
		Set tMap("CustomErrorPage") = "ErrorPage"
		Set tMap("DefaultTimeout") = "Timeout"
		Set tMap("DefaultSuperclass") = "SuperClass"
		Set tMap("Directory") = "Path"
		Set tMap("InboundWebServicesEnabled") = "InbndWebServicesEnabled"
		Set tMap("IsNamespaceDefault") = "IsNameSpaceDefault"
		Set tMap("LoginClass") = "LoginPage"
		Set tMap("PackageName") = "Package"
		Set tMap("UseSessionCookie") = "UseCookies"
		
		// Hard-coded - this is always a Web Application
		Set tProperties("Type") = 2
		Set tProperties("NameSpace") = tOrigNS
		Set tProperties("HyperEvent") = 0
		
		Set tSpecial("PasswordAuthEnabled") = ""
		Set tSpecial("UnauthenticatedEnabled") = ""
		Set tSpecial("DelegatedAuthEnabled") = ""
		Set tSpecial("KerberosAuthEnabled") = ""
		Set tSpecial("Url") = ""
		
		Set tProperties("AutheEnabled") = (..PasswordAuthEnabled * $$$AutheCache) +
			(..UnauthenticatedEnabled * $$$AutheUnauthenticated) +
			(..DelegatedAuthEnabled * $$$AutheDelegated) +
			(..KerberosAuthEnabled * $$$AutheK5API)
		
		If tProperties("AutheEnabled") = 0 {
			kill tProperties("AutheEnabled")
		}

		Set tPropList = $ListFromString(..#ATTRIBUTES)
		Set tPtr = 0
		While $ListNext(tPropList,tPtr,tPropName) {
			Continue:$Data(tSpecial(tPropName))
			Set tPropSub = $Get(tMap(tPropName),tPropName)
			Set tProperties(tPropSub) = $Property($This,tPropName)
		}
		
		Set matchRoles = ..MatchRoles
		Set matchRolesR = matchRoles
		Set matchRoles = ..ReplaceMatchRoles(matchRoles, dbDir)
    Set pos = 0
    For {
      Set pos = $Find(matchRoles, ":", pos)
      Quit:pos=0
      Set role = $Extract(matchRoles, pos, *)
      CONTINUE:role=""
      Set role = $PIECE($PIECE(role, ":"), ",")
      If '##class(Security.Roles).Exists(role) {
        Set $EXTRACT(matchRoles, pos, pos + $LENGTH(role)) = ""
        Set pos = pos - 1
      }
		}
		If matchRoles=":" $$$ThrowOnError($$$ERROR($$$GeneralError,"Missing role "_matchRolesR))
		Set tProperties("MatchRoles") = matchRoles

		// If we have a "Serve Files Timeout" and Serve Files is set to "Always", change to "Always and Cached."
		// Unfortunately (or perhaps by design?) ServeFiles is a boolean in %Installer.CSPApplication.
		If $Get(tProperties("ServeFiles")) {
			Set tProperties("ServeFiles") = tProperties("ServeFiles") + ($Get(tProperties("ServeFilesTimeout")) '= "")
		}
		If ..CookiePath'="/" && ($Get(tProperties("UseCookies")) = "") {
			Set tProperties("UseCookies") = 1
		}

		If ##class(Security.Applications).Exists(..Url) {
			Write:pVerbose !,"Updating Web Application ",..Url
			Set tSC = ##class(Security.Applications).Get(..Url,.tOldProperties)
			$$$ThrowOnError(tSC)
			
			Kill tChanges
			Set tKey = ""
			For {
				Set tOldNext = $Order(tOldProperties(tKey),1,tOldVal)
				Set tNewNext = $Order(tProperties(tKey),1,tNewVal)
				If (tOldNext = tNewNext) {
					If (tOldVal '= tNewVal) {
						Set tChanges($i(tChanges)) = tOldNext_": "_tOldVal_" -> "_tNewVal 
					} // Else no-op
				} ElseIf (tNewNext]]tOldNext) {
					Set tChanges($i(tChanges)) = tOldNext_": "_tOldVal_" -> [missing]"
				} Else {
					//tOldNext]]tNewNext
					Set tChanges($i(tChanges)) = tNewNext_": [missing] -> "_tNewVal
				}
				Set tKey = $Select(tNewNext]]tOldNext:tOldNext,1:tNewNext)
				Quit:(tKey="")
			}
			
			If $Data(tChanges) {
				If (pVerbose) {
					For i=1:1:$Get(tChanges) {
						Write !,tChanges(i)
					}
				}
				Set tSC = ##class(Security.Applications).Modify(..Url,.tProperties)
				$$$ThrowOnError(tSC)
				Write:pVerbose !,"Done."
			} Else {
				Write:pVerbose !,"No changes detected or made."
			}
		} Else {
			Write:pVerbose !,"Creating Web Application ",..Url
			Set tSC = ##class(Security.Applications).Create(..Url,.tProperties)
			If (pVerbose) {
				Set tKey = ""
				For {
					Set tKey = $Order(tProperties(tKey),1,tValue)
					Quit:tKey=""
					Write !,?4,tKey,": ",tValue
				}
			}
			$$$ThrowOnError(tSC)
			Write:pVerbose !,"Done."
		}
	} Catch ex {
		Set tSC = ex.AsStatus()
	} 
	Quit tSC
]]></Implementation>
</Method>

<Method name="DeleteCSPApp">
<Description>
This removes an existing CSP application</Description>
<Internal>1</Internal>
<FormalSpec>pVerbose:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// TODO: Make mirror-safe.
	
  Set tSC = $$$OK
  If ..Keep {
    Quit tSC
  }
	Try {
		// Only try to purge files if the directory exists.
		Set tDirExists = (..Directory '= "") && ##class(%File).DirectoryExists(..Directory)
		Set tSC = ##class(%Library.EnsembleMgr).deletePortal(..Url,tDirExists,pVerbose)
		If ($System.Status.GetErrorCodes(tSC) [ $$$ApplicationDoesNotExist) {
			// Not actually a problem - allow Clean/Uninstall to continue if it fails while trying to remove something that doesn't exist.
			Set tSC = $$$OK
		}
	} Catch ex {
		Set tSC = ex.AsStatus()
	} 
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnBeforeArtifact">
<FormalSpec><![CDATA[pExportDirectory:%String,pWorkingDirectory:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (pExportDirectory = pWorkingDirectory) {
			Quit
		}
		Write !,"[OnBeforeArtifact] "_..ResourceReference.Name
		If '..ResourceReference.Deploy {
			Set tSC = ##class(%ZPM.PackageManager.Developer.File).CopyDir(
				pExportDirectory_..ResourceReference.Name,
				pWorkingDirectory_..ResourceReference.Name)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnGetUniqueName">
<Description><![CDATA[
Returns a unique name for this resource.
Default implementation, leaving <var>pUniqueName</var> undefined, reverts to default behavior.
An empty string indicates guaranteed uniqueness (useful for folders relative to module root)]]></Description>
<FormalSpec>*pUniqueName</FormalSpec>
<Implementation><![CDATA[
	If (..Url '= "") {
		Set pUniqueName = ..Url
	}
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.Copy">
<Super>%ZPM.PackageManager.Developer.Processor.AbstractCompilable</Super>
<TimeCreated>65797,80972.301514</TimeCreated>

<Parameter name="DESCRIPTION">
<Description>
Description of resource processor class (shown in UI)</Description>
<Type>STRING</Type>
<Default>Resource processor to copy the specified resource from the (Source) database to the target namespace (respecting mappings configured for that namespace) during the Reload phase.</Default>
</Parameter>

<Parameter name="ATTRIBUTES">
<Description>
Comma-separated list of resource attribute names that this processor uses</Description>
<Type>STRING</Type>
<Default>Source,Overwrite,CompileAfter,Flags</Default>
</Parameter>

<Property name="Source">
<Description>
Name of the namespace we are copying the resources from</Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="Overwrite">
<Description>
If set to false (default is true), resources that already exist in the current/target namespace will not be overwritten.</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="Target">
<Description>
Namespace to which the resources will be copied (managed internally)</Description>
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="TargetResourceCache">
<Description>
Cache of resources discovered in the target namespace</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
<Transient>1</Transient>
</Property>

<Method name="TargetSet">
<FormalSpec>%val</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If (..Target '= %val) {
		Kill ..TargetResourceCache
	}
	Set i%Target = %val
]]></Implementation>
</Method>

<Method name="OnAfterPhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Copy specified resources from the Source namespace to current namespace
	Set tSC = $$$OK
	New $Namespace
	Try {
		If pPhase="Reload" {
			Set tQuals = $Select($g(pParams("Verbose")):"/display",1:"/nodisplay")
			Set tFileName = ##class(%File).TempFilename("xml")
			Set ..Target = $Namespace
			Set $Namespace = ..Source
			If (..Target = ..Source) {
				// no-op
				Quit
			}
			$$$ThrowOnError(..ResourceReference.ResolveChildren(.tResourceArray))
			If '..Overwrite {
				Set $Namespace = ..Target
				Set tKey = ""
				For {
					Set tKey = $Order(tResourceArray(tKey))
					Quit:tKey=""
					
					If ##class(%Library.RoutineMgr).Exists(tKey) {
						Kill tResourceArray(tKey)
					}
				}
				Set $Namespace = ..Source
			}
			If $Data(tResourceArray) {
				$$$ThrowOnError($System.OBJ.Export(.tResourceArray,tFileName,tQuals))
				Set $Namespace = ..Target
		        $$$ThrowOnError($System.OBJ.Load(tFileName,"/nocompile/checkuptodate"_tQuals))
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnPhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams,*pResourceHandled:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If (pPhase = "Compile") && (..Source = $Namespace) {
		// No need to compile the resource if we're already in the right namespace.
		Set pResourceHandled = 1
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnResolveChildren">
<FormalSpec><![CDATA[&pResourceArray]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// For each child detected, see if the individual class or any more granular package containing is part of any module. If so, clear it from the array of child resources.
	// Otherwise, indicate that the resource is generated (meaning "do not attempt to load/export").
	
	Set tSC = $$$OK
	
	// When called from OnAfterPhase, compare against resources/modules present in the target namespace.
	New $Namespace
	Set $Namespace = ..Target
	Try {
		Set tKey = ""
		For {
			Set tKey = $Order(pResourceArray(tKey))
			If (tKey = "") {
				Quit
			}
			
			If (tKey = ..ResourceReference.Name) {
				Set pResourceArray(tKey,"Generated") = 1
				Continue
			}
			
			Set tSourceName = $Piece(..ResourceReference.Name,".",*-1)
			Set tName = $Piece(tKey,".",1,*-1)
			Set tExt = $Piece(tKey,".",*)
			
			// Check cache first (for common packages)
			If $Data(..TargetResourceCache(tKey)) {
				Kill pResourceArray(tKey)
				Continue
			} ElseIf (tExt = "CLS") {
				For i=$Length(tName,".")-1:-1:1 {
					Set tPackageKey = $Piece(tName,".",1,i)_".PKG"
					If (tPackageKey = ..ResourceReference.Name) {
						Quit
					}
					
					If $Data(..TargetResourceCache(tPackageKey)) {
						Kill pResourceArray(tKey)
						Continue
					}
				}
			}
			
			// Then check persistent records for all modules
			If ##class(%ZPM.PackageManager.Developer.ResourceReference).ResourceNameExists(tKey) {
				// Resource exists as part of some module.
				// Don't include it in the copy.
				Kill pResourceArray(tKey)
				Set ..TargetResourceCache(tKey) = ""
				Continue
			} ElseIf (tExt = "CLS") {
				// See if a subpackage is defined as part of some module.
				// Don't include it in the copy either.
				For i=$Length(tName,".")-1:-1:1 {
					Set tPackageKey = $Piece(tName,".",1,i)_".PKG"
					If (tPackageKey = ..ResourceReference.Name) {
						Quit
					}
					If ##class(%ZPM.PackageManager.Developer.ResourceReference).ResourceNameExists(tPackageKey) {
						Kill pResourceArray(tKey)
						Set ..TargetResourceCache(tPackageKey) = ""
						Quit
					}
				}
			}
			
			// If we haven't killed it, indicate that it's generated.
			If $Data(pResourceArray(tKey)) {
				Set pResourceArray(tKey,"Generated") = 1
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnGetUniqueName">
<FormalSpec>*pUniqueName</FormalSpec>
<Implementation><![CDATA[
	// Validation occurs elsewhere via SQL.
	Set pUniqueName = $c(0)
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.Default.Class">
<Super>%ZPM.PackageManager.Developer.Processor.Default.Document</Super>
<TimeCreated>65797,80972.39</TimeCreated>

<Parameter name="DESCRIPTION">
<Description>
Description of resource processor class (shown in UI)</Description>
<Type>STRING</Type>
<Default>Standard resource processor for class definitions.</Default>
</Parameter>

<Property name="Format">
<Description>
Export format</Description>
<Type>%String</Type>
<Parameter name="VALUELIST" value=",UDL,XML"/>
</Property>

<Property name="FilenameExtension">
<Type>%String</Type>
<InitialExpression>"cls"</InitialExpression>
</Property>

<Property name="Directory">
<Type>%String</Type>
<InitialExpression>"cls"</InitialExpression>
<Parameter name="MAXLEN"/>
</Property>

<Method name="OnConfigureMappings">
<Description>
Subclasses may override to customize mapping behavior at the beginning of the Reload phase.</Description>
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tName = $Piece(..ResourceReference.Name,".",1,*-1)
		Set tGlobalScope = ..ResourceReference.Module.GlobalScope && '$Get(pParams("Reload","ForceLocalScope"),0)
		If 'tGlobalScope {
			Set tPackage = $p(tName,".",1,*-1)
			Set tSourceDB = ##class(%ZPM.PackageManager.Developer.Utils).GetRoutineDatabase($Namespace)
			Set tSC = ##class(%ZPM.PackageManager.Developer.Utils).AddPackageMapping($namespace,tPackage,tSourceDB)
			If $$$ISERR(tSC) {
				Quit
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%OnNew">
<FormalSpec>pResourceReference:%ZPM.PackageManager.Developer.ResourceReference</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set tSC = ##super(pResourceReference)
	If (..Format = "") {
		Set ..Format = $Case($$$lcase(..FilenameExtension),"cls":"UDL",:"XML")
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnExportItem">
<FormalSpec><![CDATA[pFullExportPath:%String,pItemName:%String,&pItemParams,&pParams,*pItemHandled:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tVerbose = $Get(pParams("Verbose"))
	If ..Format = "XML" {
		Set tSC = $System.OBJ.Export(pItemName,pFullExportPath,"-d")
	} ElseIf (..Format = "UDL") {
		Set tSC = $System.OBJ.ExportUDL(pItemName,pFullExportPath,"-d")
	}
	Set pItemHandled = 1
	If $$$ISOK(tSC),tVerbose {
		WRITE !,"Exported '",pItemName,"' to ",pFullExportPath
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.Default.DeepSeeItem">
<Super>%ZPM.PackageManager.Developer.Processor.Default.Document</Super>
<TimeCreated>65797,80972.411625</TimeCreated>

<Parameter name="EXTENSION">
<Default>.DFI</Default>
</Parameter>

<Parameter name="ATTRIBUTES">
<Type>STRING</Type>
<Default>Directory,Keywords,FilenameTranslateIdentifier,FilenameTranslateAssociator</Default>
</Parameter>

<Property name="Format">
<Description>
Export format</Description>
<Type>%String</Type>
</Property>

<Property name="Directory">
<Type>%String</Type>
<InitialExpression>"dfi"</InitialExpression>
<Parameter name="MAXLEN"/>
</Property>

<Property name="FilenameExtension">
<Type>%String</Type>
<InitialExpression>"xml"</InitialExpression>
</Property>

<Property name="Keywords">
<Type>%String</Type>
</Property>

<Property name="FilenameTranslateIdentifier">
<Description>
Characters in the filename to use as the identifier in $translate when determining the resource's filename on disk
The default behavior is to replace "." with "/" and ignore "%"</Description>
<Type>%String</Type>
<InitialExpression>"-% ,("")"</InitialExpression>
</Property>

<Property name="FilenameTranslateAssociator">
<Description>
Characters in the filename to use as the associator in $translate when determining the resource's filename on disk
The default behavior is to replace "." with "/" and ignore "%"</Description>
<Type>%String</Type>
<InitialExpression>"/_____"</InitialExpression>
</Property>

<Method name="%OnNew">
<FormalSpec>pResourceReference:%ZPM.PackageManager.Developer.ResourceReference</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
    Set tSC = ##super(pResourceReference)
    If (..Format = "") {
        Set ..Format = $Case($$$lcase(..FilenameExtension),"dfi":"UDL",:"XML")
    }
    Quit tSC
]]></Implementation>
</Method>

<Method name="OnExportItem">
<FormalSpec><![CDATA[pFullExportPath:%String,pItemName:%String,&pItemParams,&pParams,*pItemHandled:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set tVerbose = $Get(pParams("Verbose"))
	If ..Format = "XML" {
        Set tSC = $System.OBJ.Export(pItemName,pFullExportPath,"-d")
	} ElseIf (..Format = "UDL") {
	    Set tSC = $System.OBJ.ExportUDL(pItemName,pFullExportPath,"-d")
	}
	Set pItemHandled = 1
	If $$$ISOK(tSC),tVerbose {
		Write !,"Exported '",pItemName,"' to ",pFullExportPath
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnPhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams,*pResourceHandled:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set tSC = $$$OK
    Set pResourceHandled = 0
    Try {
        Set tVerbose = $Get(pParams("Verbose"),0)
        Set tDeveloperMode = $Get(pParams("DeveloperMode"),0)
        Set tName = $Piece(..ResourceReference.Name,".",1,*-1)
        Set tRoot = ..ResourceReference.Module.Root

        If (pPhase = "Reload") {
            If '..ResourceReference.Generated,'..ResourceReference.Preload { 
                Set tSubDirectory = $Select(..ResourceReference.Preload:"preload/",1:"")
                Set tResourceDirectory = tRoot_"/"_tSubDirectory
                
                Set tSourceRoot = ..ResourceReference.Module.SourcesRoot
                If tSourceRoot'="","\/"'[$Extract(tSourceRoot, *) {
                    Set tSourceRoot = tSourceRoot _ "/"
                }

                Set tDirectory = ..Directory
                If tDirectory'="","\/"'[$Extract(tDirectory, *) {
                    Set tDirectory = tDirectory _ "/"
                } Else {
                    Set tDirectory = "dfi/"
                }

                Set tResourceDirectory = ##class(%File).NormalizeDirectory(tResourceDirectory_tSourceRoot_tDirectory)

                If (tName [ "*") {
                  Set tName = $Translate(tName, "*"_..FilenameTranslateIdentifier, "*"_..FilenameTranslateAssociator)
                  Set tWildcards = tName_".xml"
                  If $$$isUNIX Set tWildcards = $$$ucase(tWildcards)_";"_$$$lcase(tWildcards)
                  Do ##class(%ZPM.PackageManager.Developer.File).FindFiles(tResourceDirectory, tWildcards, .tList)
                } Else {
                  Set tName = $Translate(tName, ..FilenameTranslateIdentifier, ..FilenameTranslateAssociator) _ ".xml"
                  Set tList($Increment(tList)) = $ListBuild(tName, tResourceDirectory _ tName) 
                }

                For i=1:1:tList {
  								Set $ListBuild(tDocName, tResourcePath) = tList(i)

                  Set tSC = $System.OBJ.Load(tResourcePath,$Select(tVerbose:"/display",1:"/nodisplay")_"/nocompile")
                  If $$$ISERR(tSC) {
                    Quit
                  }
                }
              }
        }

    } Catch e {
		    Set tSC = e.AsStatus()
	  }
	  Quit tSC
]]></Implementation>
</Method>

<Method name="OnResolveChildren">
<FormalSpec><![CDATA[&pResourceArray]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set tItem = ""
    For {
        Set tItem = $Order(pResourceArray(tItem))
        If (tItem = "") {
            Quit
        }
        Set tItemName = $Piece(tItem, "." , 1, *-1)
        Set tFullName = ##class(%DeepSee.UserLibrary.FolderItem).fullNameFromDocumentName(tItem)
        #dim tObj As %DeepSee.UserLibrary.FolderItem = ##class(%DeepSee.UserLibrary.Utils).%OpenFolderItem(tFullName, .tSC)
        If ('$IsObject(tObj)) {
            Kill pResourceArray(tItem)
            Continue
        }
        If (..Keywords'="") {
            Set tKeywords = $ListFromString(tObj.keywords)
            Set tDesiredKeywords = $ListFromString(..Keywords)
            Set tGood = 1
            For i=1:1:$ListLength(tDesiredKeywords) {
                If ('$ListFind(tKeywords, $ListGet(tDesiredKeywords, i))) {
                    Set tGood = 0
                    Quit
                }
            }
            If ('tGood) {
                Kill pResourceArray(tItem)
                Continue
            }
        }
        Set tSourceRoot = ..ResourceReference.Module.SourcesRoot
        If tSourceRoot'="","\/"'[$Extract(tSourceRoot, *) {
            Set tSourceRoot = tSourceRoot _ "/"
        }
        Set tItemName = $Translate(tItemName, ..FilenameTranslateIdentifier, ..FilenameTranslateAssociator)
        Set pResourceArray(tItem,"RelativePath") = tSourceRoot_..Directory_"/"_tItemName_"."_..FilenameExtension
    }
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnGetUniqueName">
<FormalSpec>*pUniqueName</FormalSpec>
<Implementation><![CDATA[
    If (..Keywords '= "") {
        Set pUniqueName = ..Keywords
    }
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^%ZPM.PackageMaE05F.DeepSeeItemD</DataLocation>
<DefaultData>DeepSeeItemDefaultData</DefaultData>
<IdLocation>^%ZPM.PackageMaE05F.DeepSeeItemD</IdLocation>
<IndexLocation>^%ZPM.PackageMaE05F.DeepSeeItemI</IndexLocation>
<StreamLocation>^%ZPM.PackageMaE05F.DeepSeeItemS</StreamLocation>
<Data name="DeepSeeItemDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>FilenameExtension</Value>
</Value>
<Value name="3">
<Value>Format</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.Default.Document">
<Super>%ZPM.PackageManager.Developer.Processor.AbstractCompilable</Super>
<TimeCreated>65797,80972.414756</TimeCreated>

<Parameter name="DESCRIPTION">
<Description>
Description of resource processor class (shown in UI)</Description>
<Type>STRING</Type>
<Default>Default resource processor class for %Studio.AbstractDocument subclasses</Default>
</Parameter>

<Parameter name="ATTRIBUTES">
<Description>
Comma-separated list of resource attribute names that this processor uses</Description>
<Type>STRING</Type>
<Default>Compile,CompileAfter,Flags,Directory,LoadAsDirectory,FilenameExtension,FilenameTranslateIdentifier,FilenameTranslateAssociator,Format</Default>
</Parameter>

<Parameter name="EXTENSION">
<Description><![CDATA[
May be set to determine the value of <property>Extension</property> based on a static value rather than based on the resource name.
The only expected use case at this point is class packages (.PKG, but Extension will be .CLS)]]></Description>
</Parameter>

<Property name="Compile">
<Description>
If true, the resource will be compiled during the compilation phase in the module lifecycle.</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="Directory">
<Description>
Directory relative to module root containing the exported resource.
Defaults to the resource's extension (lower-case) if unspecified.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="LoadAsDirectory">
<Description>
If true (default is false), the resource is loaded as a directory.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="FilenameTranslateIdentifier">
<Description>
Characters in the filename to use as the identifier in $translate when determining the resource's filename on disk
The default behavior is to replace "." with "/" and ignore "%"</Description>
<Type>%String</Type>
<InitialExpression>".%"</InitialExpression>
</Property>

<Property name="FilenameTranslateAssociator">
<Description>
Characters in the filename to use as the associator in $translate when determining the resource's filename on disk
The default behavior is to replace "." with "/" and ignore "%"</Description>
<Type>%String</Type>
<InitialExpression>"/"</InitialExpression>
</Property>

<Property name="FilenameExtension">
<Description>
Extension for individual filename(s) that comprise this resource</Description>
<Type>%String</Type>
<InitialExpression>"xml"</InitialExpression>
</Property>

<Property name="Format">
<Description>
Export format - list of acceptable values may differ by subclass.</Description>
<Type>%String</Type>
</Property>

<Property name="Name">
<Description>
Name of the server document (without extension)</Description>
<Type>%String</Type>
<Private>1</Private>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="Extension">
<Description>
Extension of the server document(s) represented by this resource</Description>
<Type>%String</Type>
<Private>1</Private>
</Property>

<Method name="OnPhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams,*pResourceHandled:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pResourceHandled = 0
	Try {
		Set tVerbose = $Get(pParams("Verbose"),0)
		Set tDeveloperMode = $Get(pParams("DeveloperMode"),0)
		Set tName = $Piece(..ResourceReference.Name,".",1,*-1)
		Set tName = $TRANSLATE(tName, "%", "_")
		Set tRoot = ##class(%File).NormalizeDirectory(..ResourceReference.Module.SourcesRoot, ..ResourceReference.Module.Root)
		If (pPhase = "Reload") {
			Set tGlobalScope = ..ResourceReference.Module.GlobalScope && '$Get(pParams("Reload","ForceLocalScope"),0)
			
			$$$ThrowOnError(..OnConfigureMappings(.pParams))
			
			If '..ResourceReference.Generated {
				Set tSubDirectory = $Select(..ResourceReference.Preload:"preload/",1:"")
        Set tResourceDirectory = ##class(%File).NormalizeDirectory(tRoot_"/"_tSubDirectory)
        If ('##class(%File).DirectoryExists(tResourceDirectory)) {
          Quit 
        }
        
        Set tResourceCatDirectory = ##class(%File).NormalizeDirectory(tResourceDirectory_..Directory_"/")
        if (##class(%File).DirectoryExists(tResourceCatDirectory)) {
          Set tResourceDirectory = tResourceCatDirectory
        } 
        ElseIf (..Directory="mac") {
          Set tResourceCatDirectory = ##class(%File).NormalizeDirectory(tResourceDirectory_"rtn/")
          if (##class(%File).DirectoryExists(tResourceCatDirectory)) {
            Set tResourceDirectory = tResourceCatDirectory
          }
        }
				
				If '..ResourceReference.Preload {
					Set tFileExtension = $Select(..LoadAsDirectory:"",1:"."_..FilenameExtension)
					Set tResourcePath = ##class(%File).NormalizeFilename(tResourceDirectory_$tr(tName,..FilenameTranslateIdentifier,..FilenameTranslateAssociator))_tFileExtension
					If ($$$lcase(tFileExtension)=".xml")&&('##class(%File).Exists(tResourcePath)) {
            Set $PIECE(tResourcePath, ".", *) = "cls"
            Set ..Format = "UDL"
          } 
          ElseIf ($$$lcase(tFileExtension)=".cls")&&('##class(%File).Exists(tResourcePath)) {
            Set $PIECE(tResourcePath, ".", *) = "xml"
            Set ..Format = "XML"            
          }
          
					If ($$$lcase(tFileExtension)=".mac")&&('##class(%File).Exists(tResourcePath)) {
						Set $PIECE(tResourcePath, ".", *) = "rtn"
					}

					Set tResourceParentPath = ##class(%File).ParentDirectoryName(tResourcePath)

					$$$ThrowOnError(..OnLoad(tResourcePath,tVerbose,.tHandled))
					If 'tHandled {
						If (..Format = "UDL") {
							// This is tailored toward support of "Other" documents exported in UDL format.
							// NOTE: Does not support LoadAsDirectory in the general implementation, although subclasses (e.g., Package) may.
							Set tDocName = ..ResourceReference.Name
							Set tList = ""
							If (tDocName [ "*") {
								set tWildcards = tDocName
								if $$$isUNIX set tWildcards = $$$ucase(tWildcards)_";"_$$$lcase(tWildcards)
								do ##class(%ZPM.PackageManager.Developer.File).FindFiles(tResourceParentPath, tWildcards, .tList)
							} Else {
								set tList($i(tList)) = $LISTBUILD(tDocName, tResourcePath) 
							}

							For i=1:1:tList {
								set $LISTBUILD(tDocName, tResourcePath) = tList(i)
								If ($$$ucase($Piece(tDocName, ".", *)) = "DFI") {
									Set tDocName = $Translate($Piece(tResourcePath, tResourceParentPath, 2), "-\", "_/")
									If (tDocName [ "/") {
										Set tDocName = $Piece(tDocName, "/", 1, *-1) _ "-" _ $Piece(tDocName, "/", *)
									}
								}
                Set tFlags = $Select(tVerbose:"/display",1:"/nodisplay")_"/nocompile"
                set tSC = $System.OBJ.Load(tResourcePath, tFlags)

								#; // Slimmed down version of %Api.Atelier.v1:PutDoc
								#; If ##class(%Atelier.v1.Utils.General).ValidateDocName(tDocName,.tSC,.tCategory) {
								#; 	Set tFileStream = ##class(%Stream.FileCharacter).%New()
								#; 	$$$ThrowOnError(tFileStream.LinkToFile(tResourcePath))
								#; 	Kill tDocArray
								#; 	While 'tFileStream.AtEnd {
								#; 		Set tDocArray($i(tDocArray(0))) = tFileStream.ReadLine($$$MaxLocalLength,.tSC)
								#; 		$$$ThrowOnError(tSC)
								#; 	}
								#; 	Set tSC = ##class(%Atelier.v1.Utils.TextServices).SetTextFromArray(.tDocArray,,tDocName,tCategory)
								#; 	$$$ThrowOnError(tSC)
								#; 	If tVerbose {
								#; 		Write !,"Loaded "_tDocName
								#; 	}
								#; }
							}
						} Else {
							Set tFlags = $Select(tVerbose:"/display",1:"/nodisplay")_"/nocompile"
							If ..LoadAsDirectory {
								Set tSC = $System.OBJ.LoadDir(tResourcePath,tFlags,.tErrors,1)
							} Else {
								Set tSC = $System.OBJ.Load(tResourcePath,tFlags,.tErrors)
							}
							For i=1:1:$Get(tErrors) {
								Write !,tErrors(i)
							}
							$$$ThrowOnError(tSC)
						}
					}
				}
			}
			Set pResourceHandled = 1
		} ElseIf (pPhase = "Compile") {
			// If Compile is false, indicate that the resource's compilation phase has already been handled and nothing special should happen.
			Set pResourceHandled = '..Compile
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnExportItem">
<FormalSpec><![CDATA[pFullExportPath:%String,pItemName:%String,&pItemParams,&pParams,*pItemHandled:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tVerbose = $Get(pParams("Verbose"))
		#; if $$$lcase($p(pItemName,".",*))="dfi" write !,pItemName," -> ",pFullExportPath
		If ..Format = "UDL" {
			// This is tailored toward support of "Other" documents exported in UDL format.
			// Slimmed down version of %Api.Atelier.v1:GetDoc
			If ##class(%Atelier.v1.Utils.General).ValidateDocName(pItemName,.tSC,.tCategory) {
				// Ensure directory containing file exists, and attempt to create it if not.
				If $Extract(pFullExportPath) = """" {
					// Avoid issues with the path being quoted. (These mess up GetDirectory().)
					Set pFullExportPath = $Extract(pFullExportPath,2,*-1)
				}
				Set tTargetDirectory = ##class(%Library.File).GetDirectory(pFullExportPath)
				If '##class(%Library.File).DirectoryExists(tTargetDirectory) {
					// TODO: Use cleaner/more robust method for this?
					Set tGood = ##class(%Library.File).CreateDirectoryChain(tTargetDirectory,.tReturn)
					If 'tGood {
						Set tMsg = $$$FormatText("Could not create directory '%1': %2",tTargetDirectory,$zu(209,tReturn))
						$$$ThrowStatus($$$ERROR($$$GeneralError,tMsg))
					}
				}
				
				If ($SYSTEM.Version.GetMajor()<2017) {
					Set tFileStream = ##class(%Stream.FileCharacter).%New()
					$$$ThrowOnError(tFileStream.LinkToFile(pFullExportPath))
					Set tSC = ##class(%Atelier.v1.Utils.TextServices).GetTextAsArray(pItemName,,.tDocArray)
					$$$ThrowOnError(tSC)
					
					For tLine=1:1:tDocArray(0) {
						Do tFileStream.WriteLine(tDocArray(tLine))
					}
					$$$ThrowOnError(tFileStream.%Save())					
				} Else {
					$$$ThrowOnError($SYSTEM.OBJ.ExportUDL(pItemName, pFullExportPath, "-d"))
				}
				If tVerbose {
					WRITE !,"Exported '",pItemName,"' to ",pFullExportPath
				}
				Set pItemHandled = 1
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnConfigureMappings">
<Description>
Subclasses may override to customize mapping behavior at the beginning of the Reload phase.</Description>
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnLoad">
<Description>
Subclasses may override to customize resource load behavior during the Reload phase.</Description>
<FormalSpec>pFullResourcePath:%String,pVerbose:%Boolean,*pHandled:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnNew">
<FormalSpec>pResourceReference:%ZPM.PackageManager.Developer.ResourceReference</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set ..Name = $Piece(pResourceReference.Name,".",1,*-1)
	Set ..Extension = $Case(..#EXTENSION,"":$Piece(pResourceReference.Name,".",*),:..#EXTENSION)
	Set tSC = ##super(pResourceReference)
	If (..Directory = "") {
		Set ..Directory = $ZConvert(..Extension,"L")
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnAfterPhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (pPhase = "Validate") {
			If ($Extract(..Name) = "/") {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Invalid resource name '%1' - must be a Studio document type.",..Name))
				Quit
			}
			If (..Extension = "") {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Invalid resource name '%1' - must have a file extension to identify the Studio document type.",..Name))
				Quit
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnResolveChildren">
<FormalSpec><![CDATA[&pResourceArray]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ('$Data(pResourceArray(..ResourceReference.Name))) {
		Quit $$$OK
	}
	// Add the relative path for purposes of lifecycle %Export method
	Set tFileExtension = $Select(..LoadAsDirectory:"",1:"."_..FilenameExtension)
	Set tSourceRoot = ..ResourceReference.Module.SourcesRoot
	If tSourceRoot'="","\/"'[$EXTRACT(tSourceRoot, *) {
		Set tSourceRoot = tSourceRoot _ "/"
	}
	set tClassName = ..Name
	Set tClassName = $TRANSLATE(tClassName, "%", "_")
	Set pResourceArray(..ResourceReference.Name,"RelativePath") = tSourceRoot_..Directory_"/"_$tr(tClassName,..FilenameTranslateIdentifier,..FilenameTranslateAssociator)_tFileExtension
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.Default.Global">
<Super>%ZPM.PackageManager.Developer.Processor.Abstract</Super>
<TimeCreated>65797,80972.427757</TimeCreated>

<Parameter name="DESCRIPTION">
<Description>
Description of resource processor class (shown in UI)</Description>
<Type>STRING</Type>
<Default>Standard resource processor for global exports.</Default>
</Parameter>

<Parameter name="ATTRIBUTES">
<Description>
Comma-separated list of resource attribute names that this processor uses</Description>
<Type>STRING</Type>
<Default>Directory</Default>
</Parameter>

<Property name="Directory">
<Description>
Directory relative to module root containing the exported resource.
Defaults to the resource's extension (lower-case) if unspecified.</Description>
<Type>%String</Type>
<InitialExpression>"gbl/"</InitialExpression>
<Parameter name="MAXLEN"/>
</Property>

<Method name="OnPhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams,*pResourceHandled:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pResourceHandled = 0
	Try {
		Set tVerbose = $Get(pParams("Verbose"),0)
		Set tDeveloperMode = $Get(pParams("DeveloperMode"),0)
		Set tName = $Piece(..ResourceReference.Name,".",1,*-1)
		Set tRoot = ..ResourceReference.Module.Root
		If (pPhase = "Reload") {
			Set tGlobalScope = ..ResourceReference.Module.GlobalScope && '$Get(pParams("Reload","ForceLocalScope"),0)
			
			If 'tGlobalScope && ##class(%RoutineMgr).IsMapped(..ResourceReference.Name) {
				// Format: ^^directory (to which the global is currently mapped)
				Set tGlobalDBDir = $$$GBLDB(@("^"_$Piece(..ResourceReference.Name,".",1,*-1)))
				Set tGlobalDB = ##class(%ZPM.PackageManager.Developer.Utils).GetGlobalDatabase($Namespace)
				Set tExpectedDir = "^^"_##class(%ZPM.PackageManager.Developer.Utils).GetDatabaseDirectory(tGlobalDB)
				
				// Normalize the directory name in case of case-insensitivity
				Set tGlobalDBDir = ##class(%File).NormalizeDirectory($e(tGlobalDBDir,3,*))
				Set tExpectedDir = ##class(%File).NormalizeDirectory($e(tExpectedDir,3,*))
				If tGlobalDBDir'=tExpectedDir {
					Set tSC = ##class(%ZPM.PackageManager.Developer.Utils).AddGlobalMapping($Namespace,tName,tGlobalDB)
					If $$$ISERR(tSC) {
						Quit
					}
				}
			}
			
			If '..ResourceReference.Generated {
				Set tSubDirectory = $Select(..ResourceReference.Preload:"preload/",1:"")
				Set tResourceDirectory = tRoot_"/"_tSubDirectory

				Set tSourceRoot = ..ResourceReference.Module.SourcesRoot
				If tSourceRoot'="","\/"'[$EXTRACT(tSourceRoot, *) {
					Set tSourceRoot = tSourceRoot _ "/"
				}

				Set tDirectory = ..Directory
				If tDirectory'="","\/"'[$EXTRACT(tDirectory, *) {
					Set tDirectory = tDirectory _ "/"
				} Else {
					Set tDirectory = "gbl/"
				}
				
				Set tResourceDirectory = ##class(%File).NormalizeDirectory(tResourceDirectory_tSourceRoot_tDirectory)

				If '..ResourceReference.Preload {
					Set tResourcePath = tResourceDirectory_$tr(tName,"%,("")","___")_".xml"
					Set tSC = $System.OBJ.Load(tResourcePath,$Select(tVerbose:"/display",1:"/nodisplay")_"/nocompile")
					If $$$ISERR(tSC) {
						Quit
					}
				}
			}
			Set pResourceHandled = 1
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnResolveChildren">
<FormalSpec><![CDATA[&pResourceArray]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ('$Data(pResourceArray(..ResourceReference.Name))) {
		Quit $$$OK
	}
	// Add the relative path for purposes of lifecycle %Export method
	Set tName = $Piece(..ResourceReference.Name,".",1,*-1)
	Set tSourceRoot = ..ResourceReference.Module.SourcesRoot
	If tSourceRoot'="","\/"'[$EXTRACT(tSourceRoot, *) {
		Set tSourceRoot = tSourceRoot _ "/"
	}
	Set tDirectory = ..Directory
	If tDirectory'="","\/"'[$EXTRACT(tDirectory, *) {
		Set tDirectory = tDirectory _ "/"
	} Else {
		Set tDirectory = "gbl/"
	}
	Set pResourceArray(..ResourceReference.Name,"RelativePath") = tSourceRoot_tDirectory_$tr(tName,"%,("")","___")_".xml"
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.Default.Include">
<Super>%ZPM.PackageManager.Developer.Processor.Default.Document</Super>
<TimeCreated>65797,80972.443593</TimeCreated>

<Parameter name="DESCRIPTION">
<Description>
Description of resource processor class (shown in UI)</Description>
<Type>STRING</Type>
<Default>Standard resource processor for include files.</Default>
</Parameter>

<Property name="FilenameTranslateAssociator">
<Description>
Characters in the filename to use as the associator in $translate when determining the resource's filename on disk
The default behavior is to replace "." with "/" and change "%" to "_"</Description>
<Type>%String</Type>
<InitialExpression>"/_"</InitialExpression>
</Property>

<Property name="FilenameExtension">
<Description>
Extension for individual filename(s) that comprise this resource</Description>
<Type>%String</Type>
<InitialExpression>"inc"</InitialExpression>
</Property>

<Method name="OnConfigureMappings">
<Description>
Subclasses may override to customize mapping behavior at the beginning of the Reload phase.</Description>
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tName = $Piece(..ResourceReference.Name,".",1,*-1)
		Set tGlobalScope = ..ResourceReference.Module.GlobalScope && '$Get(pParams("Reload","ForceLocalScope"),0)
		If 'tGlobalScope {
			Set tSourceDB = ##class(%ZPM.PackageManager.Developer.Utils).GetRoutineDatabase($Namespace)
			Set tSC = ##class(%ZPM.PackageManager.Developer.Utils).AddRoutineMapping($namespace,tName,"INC",tSourceDB)
			If $$$ISERR(tSC) {
				Quit
			}
    }
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnLoad">
<Description>
Subclasses may override to customize resource load behavior during the Reload phase.</Description>
<FormalSpec>pFullResourcePath:%String,pVerbose:%Boolean,*pHandled:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pHandled = 1
	Set tFlags = $Select(pVerbose:"/display",1:"/nodisplay")_"/nocompile"
	Set tSC = $System.OBJ.Load(pFullResourcePath,tFlags,.errors,1)
	For i=1:1:$Get(errors) {
		Write !,$Get(errors(i))
		Set pHandled = 0
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.Default.Interoperability">
<Super>%ZPM.PackageManager.Developer.Processor.Default.Document</Super>
<TimeCreated>65797,80972.423359</TimeCreated>

<Property name="Directory">
<Type>%String</Type>
<InitialExpression>"i14y/"</InitialExpression>
<Parameter name="MAXLEN"/>
</Property>

<Property name="FilenameTranslateIdentifier">
<Type>%String</Type>
<InitialExpression>"-%,("")"</InitialExpression>
</Property>

<Property name="FilenameTranslateAssociator">
<Type>%String</Type>
<InitialExpression>"/___"</InitialExpression>
</Property>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.Default.LocalizedErrorMessages">
<Super>%ZPM.PackageManager.Developer.Processor.AbstractCompilable,%ZPM.PackageManager.Developer.Processor.LocalizationExport</Super>
<TimeCreated>65797,80972.474838</TimeCreated>

<Parameter name="DESCRIPTION">
<Description>
Description of resource processor class (shown in UI)</Description>
<Type>STRING</Type>
<Default>Standard resource processor for localized error messages.</Default>
</Parameter>

<Method name="OnBeforePhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// Handle export of messages file for localization using the LocalizationExport resource processor class.
	If (..Filename = "") {
		// Default
		Set ..Filename = "/localize/"_$Translate($Piece(..ResourceReference.Name,".",1,*-1),".")_".xml"
	}
	Quit ##class(%ZPM.PackageManager.Developer.Processor.LocalizationExport)$This.OnBeforePhase(pPhase,.pParams)
]]></Implementation>
</Method>

<Method name="OnPhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams,*pResourceHandled:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pResourceHandled = 0
	Try {
		Set tVerbose = $Get(pParams("Verbose"),0)
		Set tDeveloperMode = $Get(pParams("DeveloperMode"),0)
		Set tName = $Piece(..ResourceReference.Name,".",1,*-1)
		Set tRoot = ..ResourceReference.Module.Root
		If (pPhase = "Reload") {
			Set tGlobalScope = ..ResourceReference.Module.GlobalScope && '$Get(pParams("Reload","ForceLocalScope"),0)
			
			If 'tGlobalScope {
				Set tSourceDB = ##class(%ZPM.PackageManager.Developer.Utils).GetRoutineDatabase($Namespace)
				Set tSC = ##class(%ZPM.PackageManager.Developer.Utils).AddRoutineMapping($namespace,tName,"INC",tSourceDB)
				If $$$ISERR(tSC) {
					Quit
				}
			}
			
			If '..ResourceReference.Generated {
				Set tSubDirectory = $Select(..ResourceReference.Preload:"preload/",1:"")
				Set tResourceDirectory = ##class(%File).NormalizeDirectory(tRoot_"/"_tSubDirectory_"localize/")
				
				If '..ResourceReference.Preload {
					Set tResourcePath = ##class(%File).NormalizeFilename(tResourceDirectory_$tr(tName,".%","/")_".xml")
					Set tSC = $System.OBJ.Load(tResourcePath,$Select(tVerbose:"/display",1:"/nodisplay")_"/nocompile")
					If $$$ISERR(tSC) {
						Quit
					}
				}
			}
			Set pResourceHandled = 1
		} ElseIf (pPhase = "Compile") {
			// Uses CompileList rather than Compile to support custom document type (.LOC)
			Set tSC = $System.OBJ.CompileList(..ResourceReference.Name,$Select(tVerbose:"d",1:"-d")_..Flags)
			Set pResourceHandled = 1
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.Default.Package">
<Super>%ZPM.PackageManager.Developer.Processor.Default.Document</Super>
<TimeCreated>65797,80972.485427</TimeCreated>

<Parameter name="DESCRIPTION">
<Description>
Description of resource processor class (shown in UI)</Description>
<Type>STRING</Type>
<Default>Standard resource processor for packages of classes included in a module.</Default>
</Parameter>

<Parameter name="EXTENSION">
<Default>.CLS</Default>
</Parameter>

<Property name="Format">
<Description>
Export format</Description>
<Type>%String</Type>
<Parameter name="VALUELIST" value=",UDL,XML"/>
</Property>

<Property name="Directory">
<Type>%String</Type>
<InitialExpression>"cls"</InitialExpression>
<Parameter name="MAXLEN"/>
</Property>

<Property name="LoadAsDirectory">
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="FilenameExtension">
<Description>
Extension for individual filename(s) that comprise this resource</Description>
<Type>%String</Type>
<InitialExpression>"cls"</InitialExpression>
</Property>

<Method name="OnConfigureMappings">
<Description>
Subclasses may override to customize mapping behavior at the beginning of the Reload phase.</Description>
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tName = $Piece(..ResourceReference.Name,".",1,*-1)
		Set tGlobalScope = ..ResourceReference.Module.GlobalScope && '$Get(pParams("Reload","ForceLocalScope"),0)
		If 'tGlobalScope {
			Set tSourceDB = ##class(%ZPM.PackageManager.Developer.Utils).GetRoutineDatabase($Namespace)
			Set tSC = ##class(%ZPM.PackageManager.Developer.Utils).AddPackageMapping($namespace,tName,tSourceDB)
			If $$$ISERR(tSC) {
				Quit
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%OnNew">
<FormalSpec>pResourceReference:%ZPM.PackageManager.Developer.ResourceReference</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set tSC = ##super(pResourceReference)
	If (..Format = "") {
		Set ..Format = $Case(..FilenameExtension,"cls":"UDL",:"XML")
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnResolveChildren">
<FormalSpec><![CDATA[&pResourceArray]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tClassKey = ""
	For {
		Set tClassKey = $Order(pResourceArray(tClassKey))
		If (tClassKey = "") {
			Quit
		}
		Set tClassName = $Piece(tClassKey,".",1,*-1)
		Set tSourceRoot = ..ResourceReference.Module.SourcesRoot
		If tSourceRoot'="","\/"'[$EXTRACT(tSourceRoot, *) {
			Set tSourceRoot = tSourceRoot _ "/"
		}
		
		Set tClassName = $TRANSLATE(tClassName, "%", "_")
    Set tFilenameExtension = $Piece(tClassKey, ".", *)    
		Set pResourceArray(tClassKey,"RelativePath") = tSourceRoot_..Directory_"/"_$tr(tClassName,..FilenameTranslateIdentifier,..FilenameTranslateAssociator)_"."_tFilenameExtension
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnExportItem">
<FormalSpec><![CDATA[pFullExportPath:%String,pItemName:%String,&pItemParams,&pParams,*pItemHandled:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	If (pItemName="") {
		Quit $$$ERROR($$$GeneralError, "Nothing to export")
	}
	Set tVerbose = $Get(pParams("Verbose"))
	If ..Format = "XML" {
		Set tSC = $System.OBJ.Export(pItemName,pFullExportPath,"-d")
	} ElseIf (..Format = "UDL") {
		Set tSC = $System.OBJ.ExportUDL(pItemName,pFullExportPath,"-d")
	}
	Set pItemHandled = 1
	If $$$ISOK(tSC),tVerbose {
		WRITE !,"Exported '",pItemName,"' to ",pFullExportPath
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnLoad">
<Description>
Subclasses may override to customize resource load behavior during the Reload phase.</Description>
<FormalSpec>pFullResourcePath:%String,pVerbose:%Boolean,*pHandled:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	// This works for either UDL or XML.
	Set pHandled = 1
	Set tFlags = $Select(pVerbose:"/display",1:"/nodisplay")_"/nocompile"
	Set tSC = $System.OBJ.ImportDir(pFullResourcePath,,tFlags,.tErrors,1)
	For i=1:1:$Get(tErrors) {
		Write !,$Get(tErrors(i))
		Set pHandled = 0
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.Default.Routine">
<Super>%ZPM.PackageManager.Developer.Processor.Default.Document</Super>
<TimeCreated>65797,80972.527581</TimeCreated>

<Parameter name="DESCRIPTION">
<Description>
Description of resource processor class (shown in UI)</Description>
<Type>STRING</Type>
<Default>Standard resource processor for routines.</Default>
</Parameter>

<Property name="FilenameTranslateAssociator">
<Description>
Characters in the filename to use as the associator in $translate when determining the resource's filename on disk
The default behavior is to replace "." with "/" and change "%" to "_"</Description>
<Type>%String</Type>
<InitialExpression>"/_"</InitialExpression>
</Property>

<Property name="Directory">
<Description>
Directory relative to module root containing the exported resource.
Defaults to the resource's extension (lower-case) if unspecified.</Description>
<Type>%String</Type>
<InitialExpression>"mac"</InitialExpression>
<Parameter name="MAXLEN"/>
</Property>

<Property name="FilenameExtension">
<Description>
Extension for individual filename(s) that comprise this resource</Description>
<Type>%String</Type>
<InitialExpression>"mac"</InitialExpression>
</Property>

<Method name="OnConfigureMappings">
<Description>
Subclasses may override to customize mapping behavior at the beginning of the Reload phase.</Description>
<FormalSpec><![CDATA[&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tName = $Piece(..ResourceReference.Name,".",1,*-1)
		Set tGlobalScope = ..ResourceReference.Module.GlobalScope && '$Get(pParams("Reload","ForceLocalScope"),0)
		If 'tGlobalScope {
			Set tSourceDB = ##class(%ZPM.PackageManager.Developer.Utils).GetRoutineDatabase($Namespace)
			Set tSC = ##class(%ZPM.PackageManager.Developer.Utils).AddRoutineMapping($namespace,tName,"MAC",tSourceDB)
			If $$$ISERR(tSC) {
				Quit
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnLoad">
<Description>
Subclasses may override to customize resource load behavior during the Reload phase.</Description>
<FormalSpec>pFullResourcePath:%String,pVerbose:%Boolean,*pHandled:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pHandled = 1
	Set tFlags = $Select(pVerbose:"/display",1:"/nodisplay")_"/nocompile"
	Set tSC = $System.OBJ.Load(pFullResourcePath,tFlags,.errors,1)
	For i=1:1:$Get(errors) {
		Write !,$Get(errors(i))
		Set pHandled = 0
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.FileCopy">
<Super>%ZPM.PackageManager.Developer.Processor.Abstract</Super>
<TimeCreated>65797,80972.321573</TimeCreated>

<Parameter name="DESCRIPTION">
<Description>
Description of resource processor class (shown in UI)</Description>
<Type>STRING</Type>
<Default>Copies the specified directory (the resource name) to a specific target location (InstallDirectory) during the Activate phase.</Default>
</Parameter>

<Parameter name="ATTRIBUTES">
<Description>
Comma-separated list of resource attribute names that this processor uses</Description>
<Type>STRING</Type>
<Default>Name,InstallDirectory,Overlay</Default>
</Parameter>

<Property name="Name">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="InstallDirectory">
<Type>%String</Type>
<Aliases>Target,Dest</Aliases>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Overlay">
<Description>
Directory to which the directory should be copied upon installation; may contain expressions.
If true, the files should be added to the target location (rather than fully replacing it, causing other files there to be deleted)</Description>
<Type>%Boolean</Type>
</Property>

<Method name="OnBeforePhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  Set tVerbose = $Get(pParams("Verbose"))
	// Default implementation: call %ValidateObject to validate attributes
	Set tSC = $$$OK
	Try {
		Set tSC = ##super(pPhase,.pParams)
		If $$$ISERR(tSC) {
			Quit
		}

		If (pPhase = "Activate") && (..InstallDirectory '= "") {
      Set tSource = ..ResourceReference.Module.Root _ ..Name
      Set tTarget = ..InstallDirectory
      Set tSC = ..DoCopy(tSource, tTarget, .pParams)
      If $$$ISERR(tSC) {
        Quit
      }
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnBeforeArtifact">
<FormalSpec><![CDATA[pExportDirectory:%String,pWorkingDirectory:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (pExportDirectory = pWorkingDirectory) {
			Quit
		}
		Write !,"[OnBeforeArtifact] "_..ResourceReference.Name
		If '..ResourceReference.Deploy {
			Set tSC = ##class(%ZPM.PackageManager.Developer.File).CopyDir(
				pExportDirectory_..ResourceReference.Name,
				pWorkingDirectory_..ResourceReference.Name)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="NormalizeNames">
<FormalSpec><![CDATA[&pSource:%String,&pTarget:%String,*pTargetDir,*pAsFile:%Boolean]]></FormalSpec>
<Implementation><![CDATA[
  Set pAsFile = 0
  If ("\/"[$Extract(pSource, *))
    ||(
      (##class(%File).NormalizeDirectory(pSource)'="")
      &&##class(%File).DirectoryExists(##class(%File).NormalizeDirectory(pSource))) {
    Set pSource = ##class(%File).NormalizeDirectory(pSource)
    Set pTarget = ##class(%File).NormalizeDirectory(pTarget)
    Set pTargetDir = pTarget
  } Else {
    Set pAsFile = 1
    Set pSource = ##class(%File).NormalizeFilename(pSource)
    If ("\/"[$Extract(pTarget, *)) {
      Set pTargetDir = ##class(%File).NormalizeDirectory(pTarget)
      Set pTarget = ##class(%File).NormalizeFilename(##class(%File).GetFilename(pSource), pTargetDir)
    } Else {
      Set pTarget = ##class(%File).NormalizeFilename(pTarget)
      Set pTargetDir = ##class(%File).ParentDirectoryName(pTarget)
    }
  }
]]></Implementation>
</Method>

<Method name="DoCopy">
<FormalSpec>tSource,tTarget,pParams</FormalSpec>
<Implementation><![CDATA[
  Set tVerbose = $Get(pParams("Verbose"))
  Set tSC = $$$OK
  Try {
    Do ..NormalizeNames(.tSource, .tTarget, .tTargetDir, .copyAsFile)

    If '##class(%File).DirectoryExists(tTargetDir) {
      If '##class(%File).CreateDirectoryChain(tTargetDir,.tReturn) {
        Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Error creating directory %1: %2",tTargetDir,$ZUtil(209,tReturn)))
        Quit
      }
    }

    Write:tVerbose !,"Copying ",tSource," to ",tTarget
    If (copyAsFile) {
      Write:tVerbose " as file "
      If '##class(%File).Exists(tSource) {
        Set tSC = $$$ERROR($$$GeneralError, "Source file does not exists")
        Quit
      }
      If '##class(%File).CopyFile(tSource, tTarget,'..Overlay, .return) {
        Set tSC = $$$ERROR($$$GeneralError, "File not copied: " _ return)
        Quit
      }
    }
    Else {
      Write:tVerbose " as directory "
      Set tSC = ##class(%ZPM.PackageManager.Developer.File).CopyDir(tSource,tTarget,'..Overlay)
    }
	} Catch e {
		Set tSC = e.AsStatus()
	}

  Quit tSC
]]></Implementation>
</Method>

<Method name="OnExportItem">
<FormalSpec><![CDATA[pFullExportPath:%String,pItemName:%String,&pItemParams,&pParams,*pItemHandled:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  Set tVerbose = $Get(pParams("Verbose"))
  Set pItemHandled = 1
  
  Set tExportPath = $Get(pParams("ModuleExportPath"))
  Set tSource = ..InstallDirectory
  Set tTarget = tExportPath _ ..Name

	Quit ..DoCopy(tSource, tTarget, .pParams)
]]></Implementation>
</Method>

<Method name="OnPhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams,*pResourceHandled:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  Set tVerbose = $Get(pParams("Verbose"))
  If (pPhase = "Clean") {
    Set pResourceHandled = 1
    Set tSource = ..ResourceReference.Module.Root _ ..Name
    Set tTarget = ..InstallDirectory
    Do ..NormalizeNames(.tSource, .tTarget, .tTargetDir, .copyAsFile)
    Write:tVerbose !,"Deleting ",tTarget
    If copyAsFile {
      Do ##class(%File).Delete(tTarget)
    } Else {
      Do ##class(%File).RemoveDirectoryTree(tTarget)
    }
  }
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.LegacyErrorMessages">
<Super>%ZPM.PackageManager.Developer.Processor.Abstract</Super>
<TimeCreated>65797,80972.307182</TimeCreated>

<Parameter name="DESCRIPTION">
<Description>
Description of resource processor class (shown in UI)</Description>
<Type>STRING</Type>
<Default>Processes a message dictionary export of error message names, generating an include file with macros to represent them.</Default>
</Parameter>

<Parameter name="ATTRIBUTES">
<Description>
Comma-separated list of resource attribute names that this processor uses</Description>
<Type>STRING</Type>
<Default>includeFiles</Default>
</Parameter>

<Property name="includeFiles">
<Description><![CDATA[
Acceptable Formats:
<include file name>
<domain>:<include file name>[,<domain>:<include file name>[,<domain>:<include file name>...]]]]></Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Method name="OnBeforePhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (pPhase = "Validate") {
			If (..includeFiles = "") || (..includeFiles = $c(0)) {
				Set tMsg = $$$FormatText("Must specify an 'includeFiles' attribute for resource processor class %1 on resource %2",$classname(),..ResourceReference.Name)
				$$$ThrowStatus($$$ERROR($$$GeneralError,tMsg))
			} ElseIf (..includeFiles [ ",") || (..includeFiles [ ":") {
				// TODO: Use a regex for validation?
				Set tIncludeList = $ListFromString(..includeFiles,",")
				Set tPtr = 0
				While $ListNext(tIncludeList,tPtr,tInclude) {
					If '$Data(tInclude) || ($Piece(..includeFiles,":") = "") || ($Piece(..includeFiles,":",2) = "") {
						$$$ThrowStatus($$$ERROR($$$GeneralError,"Invalid value for 'includeFiles': "_..includeFiles))
					}
				}
			}
		} ElseIf (pPhase = "Compile") {
			Set tFile = ..ResourceReference.Module.Root_..ResourceReference.Name
			
			// Copied from HSLIB error load process
			Set tSC = $$Import^%occMsgXML(tFile,.tPresentDomains,1)
			If $$$ISERR(tSC) {
				Quit
			}
			
			// Build map of domain to target include file (for multi-include case)
			Set tMultiInclude = ($Length(..includeFiles,",") > 1) || ($Length(..includeFiles,":") > 1)
			If (tMultiInclude) {
				Set tIncludeList = $ListFromString(..includeFiles,",")
				Set tPtr = 0
				While $ListNext(tIncludeList,tPtr,tInclude) {
					Set tDomainMap($Piece(tInclude,":")) = $Piece(tInclude,":",2)
				}
			}
			
			// Build map of include file to domain (for all cases; for a single include file this is trivial)
			Set tDomain = ""
			For {
				Set tDomain=$Order(tPresentDomains(tDomain))
				Quit:tDomain=""
				
				// Generate the include
				If (tMultiInclude) {
					If $Data(tDomainMap(tDomain),tTarget) && (tTarget '= "") {
						Set tIncludeMap(tTarget) = $Get(tIncludeMap(tTarget))_$ListBuild(tDomain)
					} Else {
						Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Domain %1 in resource %2 is not mapped to an include file."),tDomain,..ResourceReference.Name)
						Quit
					}
				} Else {
					Set tIncludeMap(..includeFiles) = $Get(tIncludeMap(..includeFiles))_$ListBuild(tDomain)
				}
			}
			If $$$ISERR(tSC) {
				Quit
			}
			
			// Generate all include files
			Set tInclude = ""
			For {
				Set tInclude = $Order(tIncludeMap(tInclude),1,tDomainList)
				Quit:tInclude=""
				
				Do GenerateInclude^%occMsgXML(tInclude,0,$lts(tDomainList),1)
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnResolveChildren">
<FormalSpec><![CDATA[&pResourceArray]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (..includeFiles [ ",") || (..includeFiles [ ":") {
			Set tIncludeList = $ListFromString(..includeFiles,",")
			Set tPtr = 0
			While $ListNext(tIncludeList,tPtr,tInclude) {
				If $Data(tInclude) || ($Piece(..includeFiles,":") '= "") {
					Set tName = $Piece(..includeFiles,":")_".INC"
					Set pResourceArray(tName) = ..ResourceReference.Module.Name
					Set pResourceArray(tName,"Generated") = 1
				}
			}
		} ElseIf (..includeFiles '= "") {
			Set pResourceArray(..includeFiles_".INC") = ..ResourceReference.Module.Name
			Set pResourceArray(..includeFiles_".INC","Generated") = 1
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.LocalizationExport">
<Description>
Resource processor to automatically export messages in given list of domains to a particular file after compilation.
This works with a resource like /localize/MessageFileName.xml (Domains attribute required; resource name used as export target), or
MyPackage.Errors.LOC (Filename attribute required; Domains populated automatically from the message file)
For .LOC resources, the default resource processor class (%ZPM.PackageManager.Developer.Processor.Default.LocalizedErrorMessages) should be used instead.</Description>
<Super>%ZPM.PackageManager.Developer.Processor.Abstract</Super>
<TimeCreated>65797,80972.324359</TimeCreated>

<Parameter name="DESCRIPTION">
<Description>
Description of resource processor class (shown in UI)</Description>
<Type>STRING</Type>
<Default>Exports messages for localization after the module is compiled.</Default>
</Parameter>

<Parameter name="ATTRIBUTES">
<Description>
Comma-separated list of resource attribute names that this processor uses</Description>
<Type>STRING</Type>
<Default>Domains,Filename</Default>
</Parameter>

<Property name="Domains">
<Description>
Comma-separated list of domains to export to the specified file. For .LOC documents, this is determined automatically and is not overridable.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Filename">
<Description>
Filename to export to. For .LOC documents, this is required; otherwise, this is set to the resource name and is not overridable.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Method name="OnBeforePhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tVerbose = $Get(pParams("Verbose"))
		Set tIsLoc = ($Piece(..ResourceReference.Name,".",*) = "LOC")
		If tIsLoc {
			Set ..Domains = ..GetDomainsForResource()
		} Else {
			Set ..Filename = ..ResourceReference.Name
		}
		
		Set tSC = ##super(pPhase,.pParams)
		If $$$ISERR(tSC) {
			Quit
		}
		
		If (pPhase = "Activate") {
			// This is only an error at this stage.
			If (..Domains = "") {
				Set tSC = $$$ERROR($$$PropertyRequired,"Domains")
			}
			
			Set tExportDir = ..ResourceReference.Module.Root
			If (..Filename '= "") {
				Set tExportFile = ##class(%File).NormalizeFilename(tExportDir_"/"_..Filename)
			} ElseIf ($Extract(..ResourceReference.Name) = "/") {
				Set tExportFile = ##class(%File).NormalizeFilename(tExportDir_..ResourceReference.Name)
			} Else {
				Set tSC = $$$ERROR($$$PropertyRequired,"Filename")
			}
			If tVerbose {
				Write !,"Exporting messages for '",..Domains,"' domain(s) to ",tExportFile
			}
			Set tSC=$$ExportDomainList^%occMessages(tExportFile,..Domains)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%OnValidateObject">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%ValidateObject</METHOD> method to 
provide notification that the current object is being validated.

<P>If this method returns an error then <METHOD>%ValidateObject</METHOD> will fail.]]></Description>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set tSC = $$$OK
	If (..Filename = "") && ($Extract(..ResourceReference.Name) '= "/") {
		// If we're using a database resource as a source, Filename is required.
		Set tSC = $$$ERROR($$$PropertyRequired,"Filename")
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetDomainsForResource">
<Description>
Returns a comma-separated list of domains for the specified resource.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tDomains = ""
	Set tExt = $Piece(..ResourceReference.Name,".",*)
	If ($Extract(..ResourceReference.Name) '= "/") && (tExt = "LOC") {
		// Get list of domains in .LOC file. We'll ignore errors, since the file may not be loaded yet.
		#dim tMsgFile As %ZPM.PackageManager.Developer.ErrorMessages.MsgFile
		Set tSC = ##class(%ZPM.PackageManager.Developer.API.ErrorMessages).GetMessageFile(..ResourceReference.Name,.tMsgFile)
		If $$$ISOK(tSC) {
			Set tDomain = ""
			For {
				Do tMsgFile.Domains.GetNext(.tDomain)
				If (tDomain = "") {
					Quit
				}
				Set tDomains = tDomains_$ListBuild(tDomain)
			}
		}
	}
	Quit $ListToString(tDomains)
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.PropertyParameters">
<System>3</System>
<TimeCreated>65797,80972.352787</TimeCreated>

<Parameter name="ATTRIBUTEREQUIRED">
<Description>
Can set to true if the attribute should be listed as required in property list APIs (without requiring it at the Objects level).
This can also be set to 0 to override the [ Required ] keyword.
If unset, it has no effect.</Description>
<Type>BOOLEAN</Type>
</Parameter>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.SystemSetting">
<Super>%ZPM.PackageManager.Developer.Processor.Abstract</Super>
<TimeCreated>65797,80972.355741</TimeCreated>

<Parameter name="ATTRIBUTES">
<Description>
Comma-separated list of resource attribute names that this processor uses</Description>
<Type>STRING</Type>
<Default>Name,Value</Default>
</Parameter>

<Property name="Name">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Value">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Method name="OnPhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams,*pResourceHandled:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  If pPhase = "Compile" {
    if $PIECE(..ResourceReference.Name, ".") = "CSP" {
      Set tName = $PIECE(..Name, ".", 2)
      If tName '= "" {
        Set ^%SYS("CSP", tName) = ..Value
        Set pResourceHandled = 1
      }
    }
  }
  Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnResolveChildren">
<FormalSpec><![CDATA[&pResourceArray]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  Kill pResourceArray
  Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.UIFW">
<Super>%ZPM.PackageManager.Developer.Processor.Abstract,%ZPM.PackageManager.Developer.IConfigurable</Super>
<TimeCreated>65797,80972.390405</TimeCreated>

<Parameter name="ATTRIBUTES">
<Description>
Comma-separated list of resource attribute names that this processor uses</Description>
<Type>STRING</Type>
<Default>RunTests,Project,SkipIfBuilt</Default>
</Parameter>

<Property name="RunTests">
<Description>
Set to 1 to run tests via gulp during the test lifecycle phase</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Project">
<Description><![CDATA[
Build "project" name - this becomes a directory in <module root>/built]]></Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="SkipIfBuilt">
<Description>
If ..BuildDirectory already exists, don't rebuild. (Eventually will be subject to a "force build" parameter.)</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="OnAfterPhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tVerbose = $Get(pParams("Verbose"),0)
		Set tDevMode = '..ResourceReference.Deploy
		
		Set tDir = ..ResourceReference.Module.Root
		If (tDir = "") {
			Write:tVerbose !,"Skipping UIFW resource processor - module root directory is missing."
			Quit
		}
		
		If (..Project = "") {
			Set ..Project = $Translate($ZStrip(..ResourceReference.Name,"<>P"),"/\","__")
		}
		
		Set tBuiltDir = ##class(%File).NormalizeDirectory(tDir_"built/"_..Project)
		
		If (pPhase = "Clean") {
			$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.File).RemoveDirectoryTree(tBuiltDir))
			Quit
		}
		
		If ..SkipIfBuilt && ##class(%File).DirectoryExists(tBuiltDir) {
			Write:tVerbose !,tBuiltDir," already exists - skipping UIFW build."
			Quit
		}
		
		// TODO: Generalize.
		Set tGitPath = ..GetPortableGitPath()
		Set tPythonPath = ..GetPythonPath()
		
		// Strip trailing slash - necessary for build-ui.bat!
		If ($Extract(tGitPath,*)="\") {
			Set tGitPath = $Extract(tGitPath,1,*-1)
		}
		
		If (pPhase = "Validate") {
			If (tPythonPath = "") {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Python executable not specified. Correct with: Do ##class("_$classname()_").SetPythonPath(""<valid path to python.exe>"")",tPythonPath))
				Quit
			} ElseIf '##class(%File).Exists(tPythonPath) {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Python executable '%1' does not exist. Correct this by running: Do ##class("_$classname()_").SetPythonPath(""<valid path to python.exe>"")",tPythonPath))
				Quit
			}
			If (tGitPath = "") {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Portable git directory not specified. Correct with: Do ##class("_$classname()_").SetPortableGitPath(""<valid path to portable git>"")",tGitPath))
				Quit
			} ElseIf '##class(%File).DirectoryExists(tGitPath) {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Portable git directory '%1' does not exist. Correct this by running: Do ##class("_$classname()_").SetPortableGitPath(""<valid path to portable git>"")",tGitPath))
				Quit
			}
		} ElseIf (pPhase = "Compile") || (..RunTests && (pPhase = "Test")) {
			Set tBuildRoot = ##class(%File).NormalizeDirectory(tDir_..ResourceReference.Name)
			Set tBuildDir = ##class(%File).NormalizeDirectory(tBuildRoot_"isc-tools/build")
			
			// Remove existing built directory (TODO: move to build script?)
			$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.File).RemoveDirectoryTree(tBuiltDir))
			
			// Select build/test/deploy based on context
			Set tPhase = $Case(pPhase,"Test":"test",:$Select(tDevMode:"build",1:"deploy"))
			
			Set tCmd = "cd "_tDir_" && "_tBuildDir_"ui-build.bat "_tBuildRoot_" "_..Project_" """" """" "_tPhase_" "_tGitPath_" "_tPythonPath_" 1"
			Set tSC = ..RunCommandWrapper(tCmd,tVerbose)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="SetPortableGitPath">
<ClassMethod>1</ClassMethod>
<FormalSpec>pPath:%String</FormalSpec>
<Implementation><![CDATA[
	Set ^SYS("PackageManager","Utilities","PortableGit") = pPath
	Set ^%SYS("PackageManager","Utiltities","PortableGit") = pPath
]]></Implementation>
</Method>

<Method name="GetPortableGitPath">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tGitPath = ""
	If '$Data(^ZPM.Dev.PortableGitPath,tGitPath) {
		If '$Data(^SYS("PackageManager","Utilities","PortableGit"),tGitPath) {
			If '$Data(^%SYS("PackageManager","Utiltities","PortableGit"),tGitPath)
		}
	}
	
	If (tGitPath '= "") {
		Set ^SYS("PackageManager","Utilities","PortableGit") = tGitPath
		Set ^%SYS("PackageManager","Utiltities","PortableGit") = tGitPath
	}
	Quit tGitPath
]]></Implementation>
</Method>

<Method name="SetPythonPath">
<ClassMethod>1</ClassMethod>
<FormalSpec>pPath:%String</FormalSpec>
<Implementation><![CDATA[
	Set ^SYS("PackageManager","Utilities","Python") = pPath
	Set ^%SYS("PackageManager","Utiltities","Python") = pPath
]]></Implementation>
</Method>

<Method name="GetPythonPath">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tPythonPath = ""
	If '$Data(^ZPM.Dev.PythonPath,tPythonPath) {
		If '$Data(^SYS("PackageManager","Utilities","Python"),tPythonPath) {
			If '$Data(^%SYS("PackageManager","Utiltities","Python"),tPythonPath)
		}
	}
	
	If (tPythonPath '= "") {
		Set ^SYS("PackageManager","Utilities","Python") = tPythonPath
		Set ^%SYS("PackageManager","Utiltities","Python") = tPythonPath
	}
	
	Quit tPythonPath
]]></Implementation>
</Method>

<Method name="RunCommandWrapper">
<ClassMethod>1</ClassMethod>
<FormalSpec>pCmd:%String,pVerbose:%Boolean</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Write:pVerbose !,pCmd
		Set tSC = ##class(%ZPM.PackageManager.Developer.Utils).RunCommandViaZF(pCmd,.tLogOutput,.tErrOutput,,.tRetCode)
		If $$$ISERR(tSC) {
			Quit
		}
		If (pVerbose) {
			For i=1:1:$Get(tLogOutput) {
				Write !,tLogOutput(i)
			}
		}
		For i=1:1:$Get(tErrOutput) {
			Write !,tErrOutput(i)
		}
		If (tRetCode '= 0) {
			Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("An error occurred executing command '%1' - see log for details.",pCmd))
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Parameter name="SETTINGS">
<Description>
A delimited string in the format:
Key:Description[|Key:Description...]</Description>
<Default>PythonPath:Path to python.exe; required for UIFW build processes.|PortableGitPath:Root path to Portable Git; required for UIFW build processes.</Default>
</Parameter>

<Parameter name="DESCRIPTION">
<Description>
A string to show in the grouping of settings for this class</Description>
<Default>UIFW Build Processes</Default>
</Parameter>

<Method name="GetSettingValue">
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Quit $Case(pName,
		"PythonPath":..GetPythonPath(),
		"PortableGitPath":..GetPortableGitPath())
]]></Implementation>
</Method>

<Method name="SettingIsDefined">
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	Quit (..GetSettingValue(pName) '= "")
]]></Implementation>
</Method>

<Method name="ClearSettingValue">
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Do ..SetSettingValue(pName,"")
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="SetSettingValue">
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String,pValue:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Do $Case(pName,
			"PythonPath":..SetPythonPath(pValue),
			"PortableGitPath":..SetPortableGitPath(pValue))
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnBeforeArtifact">
<FormalSpec><![CDATA[pExportDirectory:%String,pWorkingDirectory:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If (pExportDirectory = pWorkingDirectory) {
			Quit
		}
		Write !,"[OnBeforeArtifact] "_..ResourceReference.Name
		If '..ResourceReference.Deploy {
			Set tSC = ##class(%ZPM.PackageManager.Developer.File).CopyDir(
				pExportDirectory_..ResourceReference.Name,
				pWorkingDirectory_..ResourceReference.Name)
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Processor.UnitTest">
<Super>%ZPM.PackageManager.Developer.Processor.Abstract</Super>
<TimeCreated>65797,80972.414262</TimeCreated>

<Parameter name="DESCRIPTION">
<Description>
Description of resource processor class (shown in UI)</Description>
<Type>STRING</Type>
<Default>Loads unit tests (extending %UnitTest.TestCase) from the specified directory and runs them during (Phase). For modules in development mode, the unit tests are always loaded and are not deleted after they are run.</Default>
</Parameter>

<Parameter name="ATTRIBUTES">
<Description>
Comma-separated list of resource attribute names that this processor uses</Description>
<Type>STRING</Type>
<Default>Phase,Package,ManagerClass</Default>
</Parameter>

<Property name="ManagerClass">
<Description>
Class extending %UnitTest.Manager to use to run unit tests</Description>
<Type>%Dictionary.CacheClassname</Type>
<InitialExpression>"%ZPM.PackageManager.Developer.UnitTest.Manager"</InitialExpression>
</Property>

<Property name="Phase">
<Description>
Phase in which the unit tests run - "test" (dev namespace), "verify" (separate, clean namespace), or "test,verify" (to run in both cases).</Description>
<Type>%ZPM.PackageManager.Core.ListOfOptions</Type>
<InitialExpression>$ListBuild("test")</InitialExpression>
<Required>1</Required>
<Parameter name="VALUELIST" value=",test,verify"/>
</Property>

<Property name="Package">
<Description>
Package containing unit tests - this will be mapped properly on development systems, and unit tests won't be deleted in the "test" phase if any classes in it exist.</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Method name="OnAfterPhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tVerbose = $Get(pParams("Verbose"))
		Set tUnitTestDir = ##class(%File).NormalizeDirectory(..ResourceReference.Module.Root_..ResourceReference.Name)
		If (pPhase = "Reload") {
			// Only load unit tests if we're in developer mode.
			If $Get(pParams("DeveloperMode")) {
				// LoadTestDirectory rather than recursive $System.OBJ.LoadDir to omit _ directories.
				Set tSC = ##class(%ZPM.PackageManager.Developer.UnitTest.Manager).LoadTestDirectory(tUnitTestDir,tVerbose)
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="TestsShouldRun">
<FormalSpec><![CDATA[pPhase:%String,&pParams]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set tPathMatch = 1
	Set tTestPath = ""
	If $Data(pParams("UnitTest","Suite"),tTestSuite)#2 {
		Set tTestPath = $Translate(tTestSuite,"/\","..")
	} ElseIf $Data(pParams("UnitTest","Case"),tTestCase)#2 {
		Set tTestPath = tTestCase
	}
	If (tTestPath '= "") && (..Package '= "") {
		If $Length(tTestPath) > $Length(..Package) {
			Set tPathMatch = ($Extract(tTestPath,1,$Length(..Package)) = ..Package)
		} Else {
			Set tPathMatch = ($Extract(..Package,1,$Length(tTestPath)) = tTestPath)
		}
	}
	Quit tPathMatch && ($ListFind(..Phase,$ZConvert(pPhase,"L")) > 0)
]]></Implementation>
</Method>

<Method name="OnPhase">
<FormalSpec><![CDATA[pPhase:%String,&pParams,*pResourceHandled:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If ..TestsShouldRun(pPhase,.pParams) {
			// In test/verify phase, run unit tests.
			Set tVerbose = $Get(pParams("Verbose"))
			Set tFlags = $Select(tVerbose:"/display=all",1:"/display=none")
			
			If (..Package '= "") {
				// See if package contains any classes.
				// If it does, we won't delete the classes after running the test.
				// It's assumed that the version of these classes on disk is the authority.
				Set tNextClass = $Order(^oddDEF(..Package_"."))
				If ($Extract(tNextClass,1,$Length(..Package)) = ..Package) {
					Set tFlags = tFlags_"/nodelete"
				}
			}
			
			Set tUnitTestDir = ##class(%File).NormalizeDirectory(..ResourceReference.Module.Root_..ResourceReference.Name)
			Set tUnitTestRoot = ##class(%File).NormalizeDirectory(tUnitTestDir_$Replace(..Package,".","/"))
			Set tTestSpec = ""
			If $Data(pParams("UnitTest","Suite"),tTestSuite) {
				Set tTestSubDir = $Replace(tTestSuite,".","/")
				Set tUnitTestDir = ##class(%File).NormalizeDirectory(tUnitTestDir_tTestSubDir)
			} ElseIf $Data(pParams("UnitTest","Case"),tTestCase) {
				Set tTestSpec = ":"_tTestCase
				// Target the directory that contains this specific test case.
				Set tTestSubDir = $Replace($Piece(tTestCase,".",1,*-1),".","/")
				// Avoid nested directories
				Set tFlags = tFlags_"/norecursive"
				Set tUnitTestDir = ##class(%File).NormalizeDirectory(tUnitTestDir_tTestSubDir)
				If $Data(pParams("UnitTest","Method"),tTestMethod) {
					Set tTestSpec = tTestSpec_":"_tTestMethod
				}
			} Else {
				Set tUnitTestDir = tUnitTestRoot
			}

			If (tUnitTestDir '[ tUnitTestRoot) {
				// Case of multiple unit test resources
				Quit
			}
			
			Set tFlags = tFlags_$Get(pParams("UnitTest","Flags"))
			
			Set tManagerClass = $Get(pParams("UnitTest","ManagerClass"),..ManagerClass)
			If (tManagerClass = "") {
				Set tManagerClass = "%ZPM.PackageManager.Developer.UnitTest.Manager"
			}
			Merge tUserParams = pParams("UnitTest","UserParam")
			
			If $Data(^UnitTestRoot,tOldUnitTestRoot) // Stash ^UnitTestRoot
			Set ^UnitTestRoot = tUnitTestDir
			Set tSC = $ClassMethod(tManagerClass,"RunTest",tTestSpec,tFlags,.tUserParams)
			ZKill ^UnitTestRoot
			$$$ThrowOnError(tSC)

			// Allow the manager class to change its own UserParam array for later use in separate test runs
			Merge pParams("UnitTest","UserParam") = tUserParams
			
			If $Data(pParams("UnitTest","JUnitOutput"),tJUnitFile) {
				Set tPostfix = "-"_$ZConvert(pPhase,"L")_"-"_$Replace(..Package,".","-")
				Set $Piece(tJUnitFile,".",*-1,*) = $Piece(tJUnitFile,".",1,*-1)_tPostfix_".xml"
				Set tSC = ##class(%ZPM.PackageManager.Developer.UnitTest.JUnitOutput).ToFile(tJUnitFile)
				$$$ThrowOnError(tSC)
			}
			
			// By default, detect and report unit test failures as an error from this phase
			If $Get(pParams("UnitTest","FailuresAreFatal"),1) {
				Set tSC = ##class(%ZPM.PackageManager.Developer.UnitTest.Manager).GetLastStatus()
				$$$ThrowOnError(tSC)
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	If $Data(tOldUnitTestRoot,^UnitTestRoot) // Restore ^UnitTestRoot
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnResolveChildren">
<FormalSpec><![CDATA[&pResourceArray]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK	
	QUIT tSC
	#; Don't see any reasons why we need it, it still works other way
	Try {
		If (..Package '= "") {
			Set tRes = ##class(%SQL.Statement).%ExecDirect(,"select Name from %Dictionary.ClassDefinition where Name %STARTSWITH ? And Deployed = 0",..Package_".")
			If (tRes.%SQLCODE < 0) {
				Throw ##class(%Exception.SQL).CreateFromSQLCODE(tRes.%SQLCODE,tRes.%Message)
			}
			While tRes.%Next(.tSC) {
				Set tResource = tRes.%Get("Name")_".CLS"
				Set pResourceArray(tResource) = ..ResourceReference.Module.Name
				Set pResourceArray(tResource,"Generated") = 0
				Set pResourceArray(tResource,"Preload") = 0
				Set pResourceArray(tResource,"Scope") = ..Phase
				Set pResourceArray(tResource,"Deploy") = 0
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnGetUniqueName">
<Description><![CDATA[
Returns a unique name for this resource.
Default implementation, leaving <var>pUniqueName</var> undefined, reverts to default behavior.
An empty string indicates guaranteed uniqueness (useful for folders relative to module root)]]></Description>
<FormalSpec>*pUniqueName</FormalSpec>
<Implementation><![CDATA[
	If (..Package '= "") {
		Set pUniqueName = ..Package_".PKG"
	}
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.ResourceReference">
<IncludeCode>%ZPM.PackageManager.Common</IncludeCode>
<Super>%Persistent,%ZPM.PackageManager.Core.ResourceReference</Super>
<TimeCreated>65797,80972.001129</TimeCreated>

<Index name="ResourceName">
<Description>
Name index is unique per namespace.</Description>
<Properties>UniqueName</Properties>
<Unique>1</Unique>
</Index>

<Property name="Module">
<Type>%ZPM.PackageManager.Developer.Module</Type>
<Cardinality>parent</Cardinality>
<Inverse>Resources</Inverse>
<Relationship>1</Relationship>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="Scope">
<Description>
Restrict the scope in which this resource is included. Default is "all scopes"</Description>
<Type>%String</Type>
<Parameter name="VALUELIST" value=",test,verify"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Preload">
<Description>
Specify if this resource is from reload directory</Description>
<Type>%Boolean</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Generated">
<Description>
Specify if this resource is generated. A generated resource will not be loaded nor exported by lifecycle methods</Description>
<Type>%Boolean</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Attributes">
<Description>
Additional name-value pairs related to this resource
May be referred to in lifecycle methods</Description>
<Type>%String</Type>
<Collection>array</Collection>
<Parameter name="MAXLEN"/>
<Parameter name="XMLKEYNAME" value="Name"/>
<Parameter name="XMLNAME" value="Attribute"/>
<Parameter name="XMLPROJECTION" value="ELEMENT"/>
</Property>

<Property name="ProcessorClass">
<Description>
Specifies a class that handles lifecycle events for this resource
Typically only applicable to directory/file resources</Description>
<Type>%Dictionary.CacheClassname</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Processor">
<Description>
Transient instance of ProcessorClass</Description>
<Type>%ZPM.PackageManager.Developer.Processor.Abstract</Type>
<Transient>1</Transient>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="Deploy">
<Description>
If set to true, this source code is not shipped in application packaging.
(Of course, it must be included in module packaging.)</Description>
<Type>%Boolean</Type>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="UniqueName">
<Description><![CDATA[
Unique identifier for the resource.
For most typical resources (classes, include files, etc.) this is set to the resource name.
For resources starting with /, this is set to "" by default (indicating "not required to be unique").
If a resource processor class is defined, this name can be customized via the OnGetUniqueName method, and override the above behaviors (via <property>OverrideName</property>)]]></Description>
<Type>%String</Type>
<Calculated>1</Calculated>
<SqlComputeCode>Set {*} = $Case({OverrideName},"":{Name},$c(0):"",:{OverrideName})</SqlComputeCode>
<SqlComputed>1</SqlComputed>
<Parameter name="MAXLEN" value="255"/>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Property name="OverrideName">
<Description>
Overridden unique identifier for this resource; provided by resource processor classes.</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="255"/>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Method name="ProcessorGet">
<ReturnType>%ZPM.PackageManager.Developer.Processor.Abstract</ReturnType>
<Implementation><![CDATA[
	// Similar to LifecycleGet in Module.
	If $IsObject(r%Processor) {
		Quit r%Processor
	}
	Set tProcessorClass = ..ProcessorClass
	If (tProcessorClass '= "") && '$$$comClassDefined(tProcessorClass) && $$$comClassDefined($$$DefaultProcessorPackageDot_tProcessorClass) {
		Set tProcessorClass = $$$DefaultProcessorPackageDot_tProcessorClass
	}
	If (tProcessorClass = "") {
		// Default class for resource extension
		Set tProcessorClass = ..Module.Lifecycle.GetDefaultResourceProcessor(..Name)
	}
	If (tProcessorClass = "") || '$$$comClassDefined(tProcessorClass) {
		Quit $$$NULLOREF
	}
	Set r%Processor = $ClassMethod(tProcessorClass,"%New",$this)
	Quit r%Processor
]]></Implementation>
</Method>

<Method name="ProcessorClassGet">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit $Replace(i%ProcessorClass, $$$DefaultProcessorPackageDot, "")
]]></Implementation>
</Method>

<Method name="OverrideNameGet">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If $IsObject(..Processor) {
		// This method may leave tName undefined (the default implementation, actually)
		Do ..Processor.OnGetUniqueName(.tName)
	}
	If '$Data(tName) {
		// Default
		Set tName = $Case($Extract(..Name),
			"/":$c(0),
			:"")
	}
	Quit tName
]]></Implementation>
</Method>

<Method name="ResolveChildren">
<FormalSpec><![CDATA[&pResourceArray]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If ($Piece(..Name,".",*) = "PKG") {
			Set tPackage = $Piece(..Name,".",1,*-1)_"."
			
			// Build a cache of known packages and classes (within the given package) owned by other modules.
			Set tCacheResult = ##class(%SQL.Statement).%ExecDirect(,
				"select UniqueName from %ZPM_PackageManager_Developer.ResourceReference "_
				"where ""Module""->Name != ? "_
				"and UniqueName %STARTSWITH ?",
				..Module.Name, tPackage)
			If (tCacheResult.%SQLCODE < 0) {
				Set tSC = $$$ERROR($$$SQLCode,tCacheResult.%SQLCODE,tCacheResult.%Message)
				Quit
			}
			While tCacheResult.%Next(.tSC) {
				$$$ThrowOnError(tSC)
				Set tResourceCache(tCacheResult.%Get("UniqueName")) = ""
			}
			
			Set tFilesResult = ##class(%SQL.Statement).%ExecDirect(,
        "select Name from  %Library.RoutineMgr_StudioOpenDialog(?,'',1,1,1,0,0)",
				tPackage_"*.cls,"_tPackage_"*.mac,"_tPackage_"*.int,"_tPackage_"*.inc")
			If (tFilesResult.%SQLCODE < 0) {
				Set tSC = $$$ERROR($$$SQLCode,tFilesResult.%SQLCODE,tFilesResult.%Message)
				Quit
			}
			While tFilesResult.%Next(.tSC) {
				If $$$ISERR(tSC) {
					Quit
				}
				
				Set tFileName = tFilesResult.%Get("Name")
				
				// Skip resources owned by other modules (using cache).
				If $Data(tResourceCache(tFileName)) {
					Continue
				}
				Set tFoundInPackage = 0
				For i=$Length(tFileName,".")-2:-1:1 {
					If $Data(tResourceCache($Piece(tFileName,".",1,i)_".PKG")) {
						Set tFoundInPackage = 1
						Quit
					}
				}
				If (tFoundInPackage) {
					Continue
				}
				
				Set tResourceArray(tFileName) = ..Module.Name
				Set tResourceArray(tFileName,"Processor") = ..Processor
				Set tResourceArray(tFileName,"Generated") = ..Generated
				Set tResourceArray(tFileName,"Preload") = ..Preload
				Set tResourceArray(tFileName,"Scope") = ..Scope
				Set tResourceArray(tFileName,"Deploy") = ..Deploy
			}
			If $$$ISERR(tSC) {
				Quit
			}
		} ElseIf (..Name [ "*") {
			Set tRS = ##class(%RoutineMgr).StudioOpenDialogFunc(..Name)
			If (tRS.%SQLCODE < 0) {
				Set tSC = $$$ERROR($$$SQLCode, tRS.%SQLCODE, tRS.%Message)
				Quit
			}
			While tRS.%Next(.tSC) {
				Set tName = tRS.Name
				Set tResourceArray(tName) = ..Module.Name
				Set tResourceArray(tName,"Processor") = ..Processor
				Set tResourceArray(tName,"Generated") = ..Generated
				Set tResourceArray(tName,"Preload") = ..Preload
				Set tResourceArray(tName,"Scope") = ..Scope
				Set tResourceArray(tName,"Deploy") = ..Deploy
			}

			If $$$ISERR(tSC) {
				Quit
			}
		} Else {
			Set tResourceArray(..Name) = ..Module.Name
			Set tResourceArray(..Name,"Processor") = ..Processor
			Set tResourceArray(..Name,"Generated") = ..Generated
			Set tResourceArray(..Name,"Preload") = ..Preload
			Set tResourceArray(..Name,"Scope") = ..Scope
			Set tResourceArray(..Name,"Deploy") = ..Deploy
		}
		
		If $IsObject(..Processor) {
			Set tSC = ..Processor.OnResolveChildren(.tResourceArray)
			If $$$ISERR(tSC) {
				Quit
			}
		}
		
		Merge pResourceArray = tResourceArray
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetStatus">
<ClassMethod>1</ClassMethod>
<FormalSpec>InternalName:%String,*pReferenced:%Boolean,*pEditable:%Boolean,*pSourceModuleName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pReferenced = 0
	Set pEditable = 1
	Try {
		// Special case: module itself
		If ($Piece(InternalName,".",*) = "MODULE") {
			Set tName = $Piece(InternalName,".",1,*-1)
			If ##class(%ZPM.PackageManager.Developer.Module).NameExists(tName) {
				Set tModule = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(tName,,.tSC)
				If $$$ISERR(tSC) {
					Quit
				}
				Set pReferenced = 1
				Set pEditable = 'tModule.IsLocked()
			}
			Quit
		}
		
		// Otherwise, we're dealing with an actual resource reference.
		Set tRef = ""
		If ..ResourceNameExists(InternalName) {
			Set tRef = ..ResourceNameOpen(InternalName,,.tSC)
		} ElseIf ($Piece(InternalName,".",*) = "CLS") {
			// Classes may be included by package.
			For i=$Length(InternalName,".")-2:-1:1 {
				Set tPackage = $Piece(InternalName,".",1,i)_".PKG"
				If ..ResourceNameExists(tPackage) {
					Set tRef = ..ResourceNameOpen(tPackage,,.tSC)
					Quit
				}
			}
		}
		If $$$ISERR(tSC) || (tRef = $$$NULLOREF) {
			Quit
		}
		
		Set pReferenced = 1
		Set pEditable = 'tRef.Module.IsLocked()
		Set pSourceModuleName = tRef.Module.Name
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="%OnBeforeSave">
<Description><![CDATA[
This callback method is invoked by the <METHOD>%Save</METHOD> method to 
provide notification that the object is being saved. It is called before 
any data is written to disk.

<P><VAR>insert</VAR> will be set to 1 if this object is being saved for the first time.

<P>If this method returns an error then the call to <METHOD>%Save</METHOD> will fail.]]></Description>
<FormalSpec>insert:%Boolean</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	// Ensure OverrideName is set (if needed).
	Set ..OverrideName = ..OverrideNameGet()
	
	// Normalize resource extension for server resources - should always be upper case.
	If ($Extract(..Name) '= "/") && (..Name [ ".") {
		Set tExt = $Piece(..Name,".",*)
		Set ..Name = $Piece(..Name,".",1,*-1)_"."_$ZConvert($Piece(..Name,".",*),"U")
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Trigger name="OnChange">
<Code>	New tModule,tSC,tEx
	Set tSC = $$$OK
	Try {
		Set tModule = ##class(%ZPM.PackageManager.Developer.Module).%OpenId({Module},,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		
	} Catch tEx {
		Set tSC = tEx.AsStatus()
	}
	If $$$ISERR(tSC) {
		Set %ok = 0
		Set %msg = $System.Status.GetErrorText(tSC)
	}</Code>
<Event>INSERT/UPDATE</Event>
<Time>AFTER</Time>
<Foreach>row/object</Foreach>
</Trigger>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>{%%PARENT}("Resources")</DataLocation>
<DefaultData>ResourceReferenceDefaultData</DefaultData>
<IdLocation>^ZPM.Dev.ModuleC("Resources")</IdLocation>
<IndexLocation>^ZPM.Dev.ResourceI</IndexLocation>
<StreamLocation>^ZPM.Dev.ResourceS</StreamLocation>
<Data name="Attributes">
<Attribute>Attributes</Attribute>
<Structure>subnode</Structure>
<Subscript>"Attributes"</Subscript>
</Data>
<Data name="ResourceReferenceDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>Scope</Value>
</Value>
<Value name="4">
<Value>Preload</Value>
</Value>
<Value name="5">
<Value>Generated</Value>
</Value>
<Value name="6">
<Value>ProcessorClass</Value>
</Value>
<Value name="7">
<Value>Deploy</Value>
</Value>
<Value name="8">
<Value>UniqueName</Value>
</Value>
<Value name="9">
<Value>OverrideName</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Developer.SASchema">
<Super>%Studio.SASchemaClass</Super>
<TimeCreated>65797,80971.998158</TimeCreated>

<Parameter name="ROOTCLASSES">
<Description>
This is a comma-separated list of the classes whose xml elements
can be used as the root level element of a document separated with a ':' and the
XML tag name to correlate this with e.g. "User.Person:person,User.Company:company".</Description>
<Type>STRING</Type>
<Default>%ZPM.PackageManager.Developer.Module:Module</Default>
</Parameter>

<Parameter name="XMLNAMESPACE">
<Description>
This is the namespace value used to identify this SA schema.
This corresponds to the XMLNamespace keyword of a Studio XData block.</Description>
<Type>STRING</Type>
<Default>http://www.intersystems.com/PackageManager</Default>
</Parameter>

<Method name="Install">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		Set tStatus = ..OutputToFile(##class(%File).TempFilename())
		If $$$ISERR(tStatus) {
			Quit
		}
		Set tStatus = ##class(%Studio.SASchemaUtil).loadSchema(..#XMLNAMESPACE,1,1)
	} Catch e {
		Set tStatus = e.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetSchemaForClasses">
<Description>
Overridden to handle wrapped collections and relationships</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pClassList:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Do {
		#; start with list of top-level elements
		#; find list of all possible elements
 		Set tClass = $O(pClassList(""))
		While (tClass '= "") {
			Set tTopName = ..GetXMLNameForClass(tClass)
			Set ppDefaultNS = ..XMLName2NameSpace(tTopName)

			If ppDefaultNS="" {
				Set tSC=$$$ERROR($$$NoDefaultNamespaceForClass,tClass) Quit
			}

			Set ppCurrentNS = ppDefaultNS
			Set %VisitedClasses(tClass) = ""
			Set %VisitedElements(tTopName) = ""
			Set tFixedTopName = ..XMLName2DisplayName(tTopName,ppCurrentNS)
			If ('+$G(%useronly) || (tClass'["%")) {
				set ^||%Studio.Schema(ppDefaultNS,ppCurrentNS,tFixedTopName,"top")=1
			}

			Kill tLocalList

			#; get list of elements within this top-level
			Set tSC = ..GetElementsForClass(tClass,.tLocalList,.tRefClasses,.tElementList)
			If $$$ISERR(tSC) Quit

			Set tEl = $O(tLocalList(""))
			While (tEl '= "") {
				#; Skip if INCLUDEGROUP = 0
				Set tIncGroup = $$$comMemberKeyGet(tLocalList(tEl),$$$cCLASSparameter,"XMLINCLUDEINGROUP",$$$cPARAMdefault)
				If (tIncGroup '= 0) {
					If ('+$G(%useronly) || (tLocalList(tEl)'["%")) {
						Set tSkip = 0
						If ($D(%saCategories)) {
							// check categories
							Set tCat = $$$UPPER($$$comMemberKeyGet(tLocalList(tEl),$$$cCLASSparameter,"SACATEGORY",$$$cPARAMdefault))
							If ((tCat="")||'$D(%saCategories(tCat))) {
								Set tSkip = 1
							}
						}
						If ('tSkip) {
							Set tElDisplayName = ..XMLName2DisplayName(tEl,ppCurrentNS)
							Set ^||%Studio.Schema(ppDefaultNS,ppCurrentNS,tFixedTopName,"sub",tElDisplayName)=""
							Set tTypeInfo = tLocalList(tEl)
							If $ListValid(tTypeInfo) && $ListLength(tTypeInfo) {
								// Collection:
								// Add another element for elements in the collection
								Set tSubName = $ListBuild($ListGet(tEl),$ListGet(tTypeInfo))
								Set ^||%Studio.Schema(ppDefaultNS,ppCurrentNS,tElDisplayName,"sub",..XMLName2DisplayName(tSubName,ppCurrentNS))=""
							}
						}
					}
				}
				Set tEl = $O(tLocalList(tEl))
			}

			#; merge elements into list of ALL elements
			Merge tElementList = tLocalList

			Set tClass = $O(pClassList(tClass))
		}
		If $$$ISERR(tSC) Quit

		#; now walk over set of possible elements
		#; and make list of what elements are contained by other elements
		Set tElement = $O(tElementList(""))
		While (tElement '= "") {
			#; skip if visited
			Set tClass = tElementList(tElement)

			If ('$D(%VisitedClasses(tClass)) && '$D(%VisitedElements(tElement))) {
				Set %VisitedClasses(tClass) = ""
				Set %VisitedElements(tElement) = ""
				Kill tLocalList
				
				#; see if we need to switch NS
				Set ppCurrentNS = ..XMLName2NameSpace(tElement)

				#; get list of elements within this element
				Set tSC = ..GetElementsForClass(tClass,.tLocalList,.tRefClasses,.tElementList)
				If $$$ISERR(tSC) Quit

				Set tFixedName = ..XMLName2DisplayName(tElement,ppCurrentNS)
				Set tEl = $O(tLocalList(""))
				While (tEl '= "") {
					#; Skip if INCLUDEGROUP = 0
					Set tIncGroup = $$$comMemberKeyGet(tLocalList(tEl),$$$cCLASSparameter,"XMLINCLUDEINGROUP",$$$cPARAMdefault)
					If (tIncGroup '= 0) {
						If ('+$G(%useronly) || (tLocalList(tEl)'["%")) {
							Set tSkip = 0
							If ($D(%saCategories)) {
								// check categories
								Set tCat = $$$UPPER($$$comMemberKeyGet(tLocalList(tEl),$$$cCLASSparameter,"SACATEGORY",$$$cPARAMdefault))
								If ((tCat="")||'$D(%saCategories(tCat))) {
									Set tSkip = 1
								}
							}
							If ('tSkip) {
								Set tElDisplayName = ..XMLName2DisplayName(tEl,ppCurrentNS)
								Set ^||%Studio.Schema(ppDefaultNS,ppCurrentNS,tFixedName,"sub",tElDisplayName)=""
								Set tTypeInfo = tLocalList(tEl)
								If $ListValid(tTypeInfo) && $ListLength(tTypeInfo) {
									// Collection:
									// Add another element for elements in the collection
									Set tSubName = $ListBuild($ListGet(tEl),$ListGet(tTypeInfo))
									Set ^||%Studio.Schema(ppDefaultNS,ppCurrentNS,tElDisplayName,"sub",..XMLName2DisplayName(tSubName,ppCurrentNS))=""
								}
							}
						}
					}
					Set tEl = $O(tLocalList(tEl))
				}
			}
			Set tElement = $O(tElementList(tElement))
		}

		Set count = 0 // loop counter
		Set done = '+$D(tRefClasses)
		While ('done && (count < 100)) {
			Set count = count + 1
			// now process list of classes that were referenced by other elements
			Kill tRefClasses2
			Set tClass = $O(tRefClasses(""))
			While (tClass '= "") {
				Set tElement = ..GetXMLNameForClass(tClass)

				If ((..XMLName2NameSpace(tElement)'="") && '$D(%VisitedClasses(tClass))&&'$D(%VisitedElements(tElement))) {
					Set %VisitedClasses(tClass) = ""
					Set %VisitedElements(tElement) = ""
					#; add to list to pick up attrs
					Set tElementList(tElement) = tClass

					Kill tLocalList

					#; write out subelements, if any
					#; see if we need to switch NS
					Set ppCurrentNS = ..XMLName2NameSpace(tElement)
		
					#; get list of elements within this element
					Set tSC = ..GetElementsForClass(tClass,.tLocalList,.tRefClasses2,.tElementList)
					If $$$ISERR(tSC) Quit
	
					Set tFixedName = ..XMLName2DisplayName(tElement,ppCurrentNS)
					Set tEl = $O(tLocalList(""))
					While (tEl '= "") {
						#; Skip if INCLUDEGROUP = 0
						Set tIncGroup = $$$comMemberKeyGet(tLocalList(tEl),$$$cCLASSparameter,"XMLINCLUDEINGROUP",$$$cPARAMdefault)
						If (tIncGroup '= 0) {
							If ('+$G(%useronly) || (tLocalList(tEl)'["%")) {
								Set tSkip = 0
								If ($D(%saCategories)) {
									// check categories
									Set tCat = $$$UPPER($$$comMemberKeyGet(tLocalList(tEl),$$$cCLASSparameter,"SACATEGORY",$$$cPARAMdefault))
									If ((tCat="")||'$D(%saCategories(tCat))) {
										Set tSkip = 1
									}
								}
								If ('tSkip) {
									Set tElDisplayName = ..XMLName2DisplayName(tEl,ppCurrentNS)
									Set ^||%Studio.Schema(ppDefaultNS,ppCurrentNS,tFixedName,"sub",tElDisplayName)=""
									Set tTypeInfo = tLocalList(tEl)
									If $ListValid(tTypeInfo) && $ListLength(tTypeInfo) {
										// Collection:
										// Add another element for elements in the collection
										Set tSubName = $ListBuild($ListGet(tEl),$ListGet(tTypeInfo))
										Set ^||%Studio.Schema(ppDefaultNS,ppCurrentNS,tElDisplayName,"sub",..XMLName2DisplayName(tSubName,ppCurrentNS))=""
									}
								}
							}
						}
						Set tEl = $O(tLocalList(tEl))
					}
				}
				Set tClass = $O(tRefClasses(tClass))
			}
			
			#; more to do
			If ($D(tRefClasses2)) {
				Set done = 0
				Kill tRefClasses
				Merge tRefClasses = tRefClasses2
			}
			Else {
				Set done = 1
			}
		}

		#; JMD544
		#; Make sure every topclass gets its attributes processed
 		Set tClass = $O(pClassList(""))
		While (tClass '= "") {
			Set tElementList(..GetXMLNameForClass(tClass)) = tClass
			Set tClass = $O(pClassList(tClass))
		}

		#; now walk over set of all possible elements
		#; and write out attribute definitions for each
		Set tElement = $O(tElementList(""))
		While (tElement '= "") {
			Kill tAttrList
			Set tClass = tElementList(tElement)
			Set tSC = ..GetAttrsForClass(tClass,.tAttrList)
			If $$$ISERR(tSC) Quit

			#; test for additional key attributes for this element
			#; JMD381
			If $D(%saKeyAttrs(tClass)) {
				Set parcls = $O(%saKeyAttrs(tClass,""))
				While (parcls '= "") {
					Set prop = $O(%saKeyAttrs(tClass,parcls,""))
					While (prop '= "") {
						Set a = $G(%saKeyAttrs(tClass,parcls,prop))
						If (a '= "") {
							Set tAttrList(a) = ""
						}
						Set prop = $O(%saKeyAttrs(tClass,parcls,prop))
					}
					Set parcls = $O(%saKeyAttrs(tClass,parcls))
				}
			}

			If ('+$G(%useronly) || (tClass'["%")) {
				If $D(tAttrList) {
					Set tSkip = 0
					If ($D(%saCategories)) {
						// check categories
						Set tCat = $$$UPPER($$$comMemberKeyGet(tClass,$$$cCLASSparameter,"SACATEGORY",$$$cPARAMdefault))
						If ((tCat="")||'$D(%saCategories(tCat))) {
							Set tSkip = 1
						}
					}
					If ('tSkip) {
						#; see if we need to switch NS
						Set ppCurrentNS = ..XMLName2NameSpace(tElement)
						Set n = 0
						set tFixedElementName=..XMLName2DisplayName(tElement,ppCurrentNS)
						Set tAttr = $O(tAttrList(""))
						While (tAttr '= "") {
							Set tType = tAttrList(tAttr)
							set ^||%Studio.Schema(ppDefaultNS,ppCurrentNS,tFixedElementName,"att",tAttr)=tType
							Set n = n + 1
							Set tAttr = $O(tAttrList(tAttr))
						}
					}
				}
			}
			Set tElement = $O(tElementList(tElement))
		}
		If $$$ISERR(tSC) Quit

	} While(0)

	Quit tSC
]]></Implementation>
</Method>

<Method name="GetElementsForClass">
<Description>
Overridden to handle list collections and relationships</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%String,*pElementList,*pReferencedClasses,*pXMLNameAliases</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK

	Do {
		#; only deal with compiled classes
		#; gather properties as attributes or elements
		If ($$$comClassDefined(pClass)) {
			Set tAbstract = +$$$comClassKeyGet(pClass,$$$cCLASSabstract)
			If ('tAbstract) {
				#; get all properties of this class
				Set tRS = ##class(%ResultSet).%New("%Dictionary.CompiledClass.MemberSummary")
				Set tSC = tRS.%Execute(pClass,$$$cCLASSproperty)
				If $$$ISERR(tSC) Quit

				While (tRS.%Next(.tSC)) {
					If $$$ISERR(tSC) Quit
					Set tName = tRS.Data("Name")
					If (tName ["%%") Continue  // internal property
					If $classmethod(pClass,"%Extends","%Persistent")&&(tName="%Concurrency") Continue // omit this one specifically
					Set tType = $$$comMemberKeyGet(pClass,$$$cCLASSproperty,tName,$$$cPROPtype)
					Set tCollect = $$$comMemberKeyGet(pClass,$$$cCLASSproperty,tName,$$$cPROPcollection)
					Set tXML = $$$comMemberArrayGet(pClass,$$$cCLASSproperty,tName,$$$cPROPparameter,"XMLPROJECTION")
					Set tXMLName = $$$comMemberArrayGet(pClass,$$$cCLASSproperty,tName,$$$cPROPparameter,"XMLNAME")
					Set tXMLItemName = $$$comMemberArrayGet(pClass,$$$cCLASSproperty,tName,$$$cPROPparameter,"XMLITEMNAME")
					Set tXMLKey = $$$comMemberArrayGet(pClass,$$$cCLASSproperty,tName,$$$cPROPparameter,"XMLKEYNAME")

					Set tXML = $ZCVT(tXML,"L")
					Set:tXML="" tXML="element"
					Set:tXMLName="" tXMLName = tName
	
					If (tXML = "element") || (tXML = "wrapped") {
						#; find out if this an object-valued property
						#; get normalized type of property
						#; figure out the classtype for the property
						#; first normalize the type name
						If ((tType '[ ".") && (tType '[ "%")) {
							#; assume this type belongs to our package
							Set tType = $P(pClass,".",1,$L(pClass,".")-1) _ "." _ tType
						}
						Set tType = $$$NormalizeClassname(tType)

						If (tCollect="array") {
							If (tXMLKey '= "") {
								#; We use the globally visible variable, %saKeyAttrs,
								#; to track additional elements used as array keys.
								#; This implementation is not correct; in the general case
								#; the same element could be used in different contexts with
								#; different key names. This is not very typical, however.
								Set %saKeyAttrs(tType,pClass,tName) = tXMLKey
							}
						}

						If ($$$classIsDataType(tType)) {
							#; add literal element to list
							Set tDTNS = ..XMLName2NameSpace(..GetXMLNameForClass(pClass))
							If (tDTNS'="") {
								Set pElementList($LB(tDTNS,tXMLName)) = tType
							}
						}
						Else {
							Set pReferencedClasses(tType) = ""
							#; Skip if INCLUDEGROUP = 0
							Set tIncGroup = $$$comMemberKeyGet(tType,$$$cCLASSparameter,"XMLINCLUDEINGROUP",$$$cPARAMdefault)
							If (tIncGroup '= 0) {
								If (tCollect="") {
									Set tElements(tXMLName) = tType
									Set tElementsRef(tXMLName,tName) = "" // JMD517
								} Else {
									Set tDTNS = ..XMLName2NameSpace(..GetXMLNameForClass(pClass))
									Set tReferenceXMLName = ..GetXMLNameForClass(tType)
									Set tItemNamespace = ..XMLName2NameSpace(tReferenceXMLName)
									If (tXMLItemName = "") {
										Set tXMLItemName = ..XMLName2ShortName(tReferenceXMLName)
									} Else {
										Set pXMLNameAliases($ListBuild(tItemNamespace,tXMLItemName)) = tType
									}
									If (tItemNamespace'="") {
										Set pElementList($LB(tDTNS,tXMLName)) = $ListBuild(tXMLItemName,tType)
									}
								}
							}
						}
					}
				}
				If $$$ISERR(tSC) Quit
				
				#; process elements
				#; (for each element expand into available subclasses)
				Set tEl = $O(tElements(""))
				While (tEl '= "") {
					Kill tChoiceList
					Set tSubClass = tElements(tEl)

					if tSubClass'="%Library.RegisteredObject",tSubClass'="%Library.SerialObject",tSubClass'="%Library.Persistent" {
						Set tSC = ..GetXMLElementsForClass(tSubClass,.tChoiceList)
						If $$$ISERR(tSC) Quit
					}

					Set k = $O(tChoiceList(""))
					While (k'="") {
						If $D(tElementsRef(tEl)) { // non-collection, reference property
							// for each property that refers to this, there is an entry
							Set xn = $O(tElementsRef(tEl,""))
							While (xn'="") {
								Set k2 = k
								Set $List(k2,2) = xn
								Set pElementList(k2) = tChoiceList(k)
								Set tType = $$$NormalizeClassname(tChoiceList(k))
								If ('$$$classIsDataType(tType)) {
									// set up alias so that this name refers to correct class
									// n.b. this assumes that property names do not conflict!
									Set %saAliases($LG(k2,1),$LG(k2,2)) = $LG(k,2)
								}
								Set xn = $O(tElementsRef(tEl,xn))
							}
						}
						Else {
							Set tType = $$$NormalizeClassname(tChoiceList(k))
							If ('$$$classIsDataType(tType)) {
								#; JMD544
								#; Skip if INCLUDEGROUP = 0 OR abstract
								Set tIncGroup = $$$comMemberKeyGet(tType,$$$cCLASSparameter,"XMLINCLUDEINGROUP",$$$cPARAMdefault)
								Set tTypeAbstract = +$$$comClassKeyGet(tType,$$$cCLASSabstract)
								If ('tTypeAbstract && (tIncGroup '= 0)) {
									Set pElementList(k) = tChoiceList(k)		
									Set pReferencedClasses(tType) = ""
								}
							}
							Else {
								Set pElementList(k) = tChoiceList(k)
							}
						}
						Set k = $O(tChoiceList(k))
					}
					Set tEl = $O(tElements(tEl))
				}
				If $$$ISERR(tSC) Quit
			}
		}
	} While(0)

	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.SystemRequirements">
<Super>%Persistent,%XML.Adaptor</Super>
<TimeCreated>65797,80972.023131</TimeCreated>

<Property name="VersionString">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100"/>
<Parameter name="XMLNAME" value="Version"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Property name="Version">
<Type>%ZPM.PackageManager.Core.SemanticVersionExpression</Type>
<Parameter name="XMLPROJECTION" value="NONE"/>
</Property>

<Method name="VersionStringSet">
<FormalSpec>tValue</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set i%VersionString = tValue
	Set tSC = ##class(%ZPM.PackageManager.Core.SemanticVersionExpression).FromString(tValue,.tExpression)
	If $$$ISOK(tSC) {
		Set ..Version = tExpression
	}
	Quit tSC
]]></Implementation>
</Method>

<Property name="Interoperability">
<Type>%String</Type>
<Parameter name="VALUELIST" value=",enabled,disabled"/>
<Parameter name="XMLPROJECTION" value="ATTRIBUTE"/>
</Property>

<Method name="CheckRequirements">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC1 = ..CheckVersion()
	Set tSC2 = ..CheckInteroperability()
	Return $$$ADDSC(tSC1, tSC2)
]]></Implementation>
</Method>

<Method name="CheckVersion">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSystemMajor = $System.Version.GetMajor()
	Set tSystemMinor = $System.Version.GetMinor()
	If (..VersionString = "") { Return $$$OK } 
	Try {
		Set tComparator = ..Version.Options.GetAt(1).Comparators.GetAt(1)
		Set CurrentSystemVersion = ##class(%ZPM.PackageManager.Core.SemanticVersion).FromString($System.Version.GetNumber())
		If CurrentSystemVersion.Patch = "" { 
			Set CurrentSystemVersion.Patch = 0
		}
		If ('tComparator.Evaluate(CurrentSystemVersion)) {
			Return $$$ERROR($$$GeneralError,"The module cannot be installed on the current version ("_tSystemMajor_"."_tSystemMinor_") of the system, version """_..VersionString_""" is required")
		}
		Return $$$OK
	} Catch ex {
		Return $$$ERROR($$$GeneralError, "Unable to check reqired system version")
	}
]]></Implementation>
</Method>

<Method name="CheckInteroperability">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
	If ( (..Interoperability="enabled") && '##class(%EnsembleMgr).IsEnsembleNamespace($Namespace) ) {
		Return $$$ERROR($$$GeneralError, "The module requires Interoperability Production Enabled. Namespace <"_$Namespace_"> doesn't support Interoperability Production")
	}
	Return $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^%ZPM.Packa360D.SystemRequi5D02D</DataLocation>
<DefaultData>SystemRequirementsDefaultData</DefaultData>
<IdLocation>^%ZPM.Packa360D.SystemRequi5D02D</IdLocation>
<IndexLocation>^%ZPM.Packa360D.SystemRequi5D02I</IndexLocation>
<StreamLocation>^%ZPM.Packa360D.SystemRequi5D02S</StreamLocation>
<Data name="SystemRequirementsDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>VersionString</Value>
</Value>
<Value name="3">
<Value>Product</Value>
</Value>
<Value name="4">
<Value>Interoperability</Value>
</Value>
<Value name="5">
<Value>Version</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Developer.UnitTest.JUnitOutput">
<TimeCreated>65797,80972.502856</TimeCreated>

<Method name="ToFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFileName:%String,pTestIndex:%Integer={$Order(^UnitTest.Result(""),-1)}</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tFile = ##class(%Stream.FileCharacter).%New()
		Do tFile.LinkToFile(pFileName)
		
		Kill ^||TMP // results global
		Set tSuite=""
		For {
			Set tSuite=$Order(^UnitTest.Result(pTestIndex,tSuite),1,tSuiteData)
			Quit:tSuite=""
			Set ^||TMP("S",tSuite,"time")=$ListGet(tSuiteData,2)
			
			Set tCase=""
			For {
				Set tCase=$Order(^UnitTest.Result(pTestIndex,tSuite,tCase),1,tCaseData)
				Quit:tCase=""
				
				if $Increment(^||TMP("S",tSuite,"tests"))
				Set ^||TMP("S",tSuite,"C",tCase,"time")=$ListGet(tCaseData,2)
				Set tMethod=""
				For {
					Set tMethod=$Order(^UnitTest.Result(pTestIndex,tSuite,tCase,tMethod),1,tMethodData)
					Quit:tMethod=""
					
					Set ^||TMP("S",tSuite,"C",tCase,"M",tMethod,"time")=$ListGet(tMethodData,2)
					Set tAssert=""
					For {
						Set tAssert=$Order(^UnitTest.Result(pTestIndex,tSuite,tCase,tMethod,tAssert),1,tAssertData)
						Quit:tAssert=""
						
						If $Increment(^||TMP("S",tSuite,"assertions"))
						If $Increment(^||TMP("S",tSuite,"C",tCase,"assertions"))
						If $Increment(^||TMP("S",tSuite,"C",tCase,"M",tMethod,"assertions"))
						If $ListGet(tAssertData)=0 {
							If $Increment(^||TMP("S",tSuite,"failures"))
							If $Increment(^||TMP("S",tSuite,"C",tCase,"failures"))
							Set tIndex = $Increment(^||TMP("S",tSuite,"C",tCase,"M",tMethod,"failures"))
							Set ^||TMP("S",tSuite,"C",tCase,"M",tMethod,"failures",tIndex) =
								$ListGet(tAssertData,2) _ ": " _ $ListGet(tAssertData,3)
						}
					}
					If ($ListGet(tMethodData)=0)
					&& ('$data(^||TMP("S",tSuite,"C",tCase,"M",tMethod,"failures"))) {
						If $Increment(^||TMP("S",tSuite,"failures"))
						If $Increment(^||TMP("S",tSuite,"C",tCase,"failures"))
						Set tIndex = $Increment(^||TMP("S",tSuite,"C",tCase,"M",tMethod,"failures"))
						Set ^||TMP("S",tSuite,"C",tCase,"M",tMethod,"failures",tIndex) = 
							$ListGet(tMethodData,3) _ ": " _ $ListGet(tMethodData,4)
					}
				}
				
				If $ListGet(tCaseData)=0
				&& ('$data(^||TMP("S",tSuite,"C",tCase,"failures"))) {
					If $Increment(^||TMP("S",tSuite,"failures"))
					If $Increment(^||TMP("S",tSuite,"C",tCase,"failures"))
					Set tIndex = $Increment(^||TMP("S",tSuite,"C",tCase,"M",tCase,"failures"))
					Set ^||TMP("S",tSuite,"C",tCase,"M",tCase,"failures",tIndex) =
						$ListGet(tCaseData,3) _ ": " _ $ListGet(tCaseData,4)
				}
			}
		}
		
		Do tFile.WriteLine("<?xml version=""1.0"" encoding=""UTF-8"" ?>")
		Do tFile.WriteLine("<testsuites>")
		Set tSuite=""
		For {
			Set tSuite=$Order(^||TMP("S",tSuite))
			Quit:tSuite=""
			
			Do tFile.Write("<testsuite")
			Do tFile.Write(" name="""_$zconvert(tSuite,"O","XML")_"""")
			Do tFile.Write(" assertions="""_$get(^||TMP("S",tSuite,"assertions"))_"""")
			Do tFile.Write(" time="""_$get(^||TMP("S",tSuite,"time"))_"""")
			Do tFile.Write(" tests="""_$get(^||TMP("S",tSuite,"tests"))_"""")
			Do tFile.WriteLine(">")
			
			Set tCase=""
			For {
				Set tCase=$Order(^||TMP("S",tSuite,"C",tCase))
				Quit:tCase=""
				
				Do tFile.Write("<testsuite")
				Do tFile.Write(" name="""_$zconvert(tCase,"O","XML")_"""")
				Do tFile.Write(" assertions="""_$get(^||TMP("S",tSuite,"C",tCase,"assertions"))_"""")
				Do tFile.Write(" time="""_$get(^||TMP("S",tSuite,"C",tCase,"time"))_"""")
				Do tFile.Write(" tests="""_$get(^||TMP("S",tSuite,"C",tCase,"tests"))_"""")
				Do tFile.WriteLine(">")
				
				Set tMethod=""
				For {
					Set tMethod=$Order(^||TMP("S",tSuite,"C",tCase,"M",tMethod))
					Quit:tMethod=""
					
					Do tFile.Write("<testcase")
					Do tFile.Write(" name="""_$zconvert(tMethod,"O","XML")_"""")
					Do tFile.Write(" assertions="""_$get(^||TMP("S",tSuite,"C",tCase,"M",tMethod,"assertions"))_"""")
					Do tFile.Write(" time="""_$get(^||TMP("S",tSuite,"C",tCase,"M",tMethod,"time"))_"""")
					Do tFile.WriteLine(">")
					Set tFailureKey = ""
					For {
						Set tFailureKey = $Order(^||TMP("S",tSuite,"C",tCase,"M",tMethod,"failures",tFailureKey),1,tMessage)
						If (tFailureKey = "") {
							Quit
						}
						Set tMessage = $zstrip(tMessage,"*C")
						Set tMessage = $zconvert($zconvert(tMessage,"O","UTF8"),"O","XML")
						// Also encode newlines - $zconvert doesn't do this.
						Set tMessage = $replace(tMessage,$c(10),"&#10;")
						Set tMessage = $replace(tMessage,$c(13),"&#13;")
						Do tFile.Write("<failure type=""cache-error"" message="""_tMessage_""">")
						Do tFile.WriteLine("</failure>")
					}
					Do tFile.WriteLine("</testcase>")
				}
				Do tFile.WriteLine("</testsuite>")
			}
			Do tFile.WriteLine("</testsuite>")
		}
		Do tFile.WriteLine("</testsuites>")
		Kill ^||TMP
		
		$$$ThrowOnError(tFile.%Save())
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.UnitTest.Manager">
<Super>%UnitTest.Manager</Super>
<TimeCreated>65797,80972.514883</TimeCreated>

<Method name="RunTest">
<Description>
Ensures the last run variable is cleared out, then just does the usual.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[testspec:%String,qspec:%String,&userparam]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill ^||%UnitTest.Manager.LastResult
	Quit ##super(.testspec,.qspec,.userparam)
]]></Implementation>
</Method>

<Method name="SaveResult">
<Description>
Does the default behavior, then stashes the latest run index</Description>
<FormalSpec>duration</FormalSpec>
<Implementation><![CDATA[
	Do ##super(.duration)
	Set ^||%UnitTest.Manager.LastResult = i%LogIndex
	Quit
]]></Implementation>
</Method>

<Method name="LoadTestDirectory">
<Description>
Loads unit test classes from a directory without compiling or running them. (Other debug loading approaches would compile them.)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRootDirectory:%String,pVerbose:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		$$$ThrowOnError(..GetSubDirectories(pRootDirectory,pRootDirectory,1,"",.tSubDirs))
		
		Set tDirectory = ""
		For {
			Set tDirectory = $Order(tSubDirs(tDirectory))
			If (tDirectory = "") {
				Quit
			}
			$$$ThrowOnError($System.OBJ.LoadDir(tDirectory,"k" _ $Select(pVerbose:"/display",1:"/nodisplay")))
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetLastStatus">
<Description>
Returns $$$OK if the last unit test run was successful, or an error if it was unsuccessful.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pFailureCount:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		If '$Data(^||%UnitTest.Manager.LastResult,tLogIndex)#2 {
			Set tLogIndex = $Order(^UnitTest.Result(""),-1)
		}
		Kill ^||%UnitTest.Manager.LastResult // Clean up
		If tLogIndex {
			Set tRes = ##class(%SQL.Statement).%ExecDirect(,"select count(*) "_
				"from %UnitTest_Result.TestAssert where Status = 0 "_
				"and TestMethod->TestCase->TestSuite->TestInstance->InstanceIndex = ?",tLogIndex)
			If (tRes.%SQLCODE < 0) {
				Throw ##class(%Exception.SQL).CreateFromSQLCODE(tRes.%SQLCODE,tRes.%Message)
			}
			Do tRes.%Next(.tSC)
			$$$ThrowOnError(tSC)
			Set pFailureCount = tRes.%GetData(1)
			If (pFailureCount > 0) {
				Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("%1 assertion(s) failed.",pFailureCount))
			} Else {
				// Double check that no other failures were reported - e.g., failures loading that would lead to no assertions passing or failing!
				Set tRes = ##class(%SQL.Statement).%ExecDirect(,"select count(*) "_
					"from %UnitTest_Result.TestSuite where Status = 0 "_
					"and TestInstance->InstanceIndex = ?",tLogIndex)
				If (tRes.%SQLCODE < 0) {
					Throw ##class(%Exception.SQL).CreateFromSQLCODE(tRes.%SQLCODE,tRes.%Message)
				}
				Do tRes.%Next(.tSC)
				$$$ThrowOnError(tSC)
				Set pFailureCount = tRes.%GetData(1)
				If (pFailureCount > 0) {
					Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("%1 test suite(s) failed.",pFailureCount))
				}
			}
		} Else {
			Set tSC = $$$ERROR($$$GeneralError,"No unit test results recorded.")
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.UnitTest.Utils">
<IncludeCode>%sySecurity</IncludeCode>
<TimeCreated>65797,80972.50376</TimeCreated>

<Method name="CreateNamespace">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNSName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set tSC = $$$OK
	Try {
		Set $Namespace = "%SYS"
		Set tLowerName = $ZCVT(pNSName,"L")

		//Create directories
		Set tPath = ##class(%File).ManagerDirectory() _ pNSName
		Set tCreated = ##class(%File).CreateDirectory(tPath,.tResult)
		If 'tCreated {
			Set tSC = $$$ERROR($$$GeneralError,"Error creating directory '"_tPath_"': "_tResult)
			Quit
		}
		
		Set tWebPath = ##class(%File).NormalizeDirectory(##class(%File).ParentDirectoryName(##class(%File).ManagerDirectory()) _ "csp") _ pNSName
		If '##class(%File).DirectoryExists(tWebPath) {
			Set tCreated = ##class(%File).CreateDirectory(tWebPath,.tResult)
			If 'tCreated {
				Set tSC = $$$ERROR($$$GeneralError,"Error creating directory '"_tWebPath_"': "_tResult)
				Quit
			}
		}	

		// Create database
		Set tSC = ##class(SYS.Database).CreateDatabase(tPath)
		If $$$ISERR(tSC) {
			Quit
		}

		// Mount database
		Set tDBProps("Directory") = tPath
		Set tDBProps("MountRequired") = 1
		Set tSC = ##class(Config.Databases).Create(pNSName,.tDBProps)
		If $$$ISERR(tSC) {
			Quit
		}
		Set Properties("MountRequired") = 1
		Set tSC = ##class(Config.Databases).Modify(pNSName,.tDBProps)
		If $$$ISERR(tSC) {
			Quit
		}

		// Create namespace
		Set tNSProps("Globals") = pNSName
		Set tNSProps("Routines") = pNSName
		If $ZVERSION["IRIS" {
			Set tNSProps("Library") = "IRISLIB"
			Set tNSProps("SysGlobals") = "IRISSYS"
			Set tNSProps("SysRoutines") = "IRISSYS"
			Set tNSProps("TempGlobals") = "IRISTEMP"
		} else {
			Set tNSProps("Library") = "CACHELIB"
			Set tNSProps("SysGlobals") = "CACHESYS"
			Set tNSProps("SysRoutines") = "CACHESYS"
			Set tNSProps("TempGlobals") = "CACHETEMP"
		}
		Set tSC = ##class(Config.Namespaces).Create(pNSName,.tNSProps)
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Ensemble-enable namespace
		Set tSC = ##class(%EnsembleMgr).EnableNamespace(pNSName)
		If $$$ISERR(tSC) {
			Quit
		}

		// Create default web application
		Set tWebProps("AutheEnabled") = $$$AutheCache + $$$AutheUnauthenticated
		Set tWebProps("NameSpace") = pNSName
		Set tWebProps("Path") = tWebPath
		Set tWebProps("IsNameSpaceDefault") = 1
		if ##class(Security.Applications).Exists("/csp/"_tLowerName) {
			Set tSC = ##class(Security.Applications).Modify("/csp/"_tLowerName,.tWebProps)
		} else {
			Set tSC = ##class(Security.Applications).Create("/csp/"_tLowerName,.tWebProps)
		}
		If $$$ISERR(tSC) {
			Quit
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="DeleteNamespace">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNSName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set tFinalStatus = $$$OK
	Try {
		Set $Namespace = "%SYS"
		Set tLowerName = $ZCVT(pNSName,"L")
		Set tPath = ##class(%File).ManagerDirectory() _ pNSName
		Set tWebPath = ##class(%File).NormalizeDirectory(##class(%File).ParentDirectoryName(##class(%File).ManagerDirectory()) _ "csp") _ pNSName
		
		// Delete Web Application
		Set tSC = ##class(Security.Applications).Delete("/csp/"_tLowerName)
		Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)

		// Delete namespace
		Set tSC = ##class(Config.Namespaces).Delete(pNSName)
		Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)
		
		// Close CSP connections for the namespace
		// (There were some issues with these processes locking the DB folder and preventing its deletion later.)
		Set tSC = ..CloseConnectionsForNamespace(pNSName)
		Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)

		// Delete secondary database
		Set tSecondaryDB = pNSName_##class(%Library.EnsembleMgr).#SECONDARYSUFFIX
		Set tEnsTempDB = pNSName_##class(%Library.EnsembleMgr).#TEMPSUFFIX
		For tOtherDB = tSecondaryDB,tEnsTempDB {
			Set tSC = $$$OK
			Set tDB = ##class(Config.Databases).Open(tOtherDB,,.tSC)
			If $IsObject(tDB) {
				// Delete database
				Set tSC = ##class(Config.Databases).Delete(tOtherDB)
				Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)
				
				// Delete database file
				Set tOtherPath = tDB.Directory
				Set tSC = ##class(SYS.Database).DeleteDatabase(tOtherPath)
				Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)
			} ElseIf $$$ISERR(tSC) {
				Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)
			}
		}

		// Delete database
		Set tSC = ##class(Config.Databases).Delete(pNSName)
		Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)

		// Delete database file
		Set tSC = ##class(SYS.Database).DeleteDatabase(tPath)
		Set tFinalStatus = $$$ADDSC(tFinalStatus,tSC)

		// Delete directories
		Set tDirRemoved = ##class(%ZPM.PackageManager.Developer.File).RemoveDirectoryTree(tPath)
		If 'tDirRemoved {
			Set tFinalStatus = $$$ADDSC(tFinalStatus,$$$ERROR($$$GeneralError,"Error removing directory '"_tPath_"'"))
		}
		
		Set tDirRemoved = ##class(%ZPM.PackageManager.Developer.File).RemoveDirectoryTree(tWebPath)
		If 'tDirRemoved {
			Set tFinalStatus = $$$ADDSC(tFinalStatus,$$$ERROR($$$GeneralError,"Error removing directory '"_tWebPath_"'"))
		}
	} Catch e {
		Set tFinalStatus = $$$ADDSC(tFinalStatus,e.AsStatus())
	}
	Quit tFinalStatus
]]></Implementation>
</Method>

<Method name="CreateUser">
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String,pPassword:%String,pRoles:%String="%All"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set tStatus = $$$OK
	Try {
		Set $Namespace = "%SYS"
		Set tStatus = ##class(Security.Users).Create(pName,pRoles,pPassword)
	} Catch e {
		Set tStatus = e.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="DeleteUser">
<ClassMethod>1</ClassMethod>
<FormalSpec>pName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set tStatus = $$$OK
	Try {
		Set $Namespace = "%SYS"
		Set tStatus = ##class(Security.Users).Delete(pName)
	} Catch e {
		Set tStatus = e.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="CloseConnectionsForNamespace">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tClosed = 0
	Try {
		Set tProcs = ##class(%SQL.Statement).%ExecDirect(,"select PID from %SYS.ProcessQuery where Namespace = ?",pNamespace)
		If (tProcs.%SQLCODE < 0) {
			Set tStatus = $$$ERROR($$$SQLCode,tProcs.%SQLCODE,tProcs.%Message)
			Quit
		}
		While tProcs.%Next(.tStatus) {
			Set tProc = ##class(SYS.Process).%OpenId(tProcs.%Get("PID"))
			Set tStatus = $$$ADDSC(tStatus,tProc.Terminate())
		}
	} Catch e {
		Set tStatus = e.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.Utils">
<IncludeCode>%occInclude,%occErrors,%ZPM.PackageManager.Common</IncludeCode>
<System>3</System>
<TimeCreated>65797,80972.086663</TimeCreated>

<Method name="LoadDependencies">
<Description><![CDATA[
Format of <var>pDependencyGraph</var>:
pDependencyGraph("module name") = $ListBuild(depth, "server name")]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pDependencyGraph,&pParams]]></FormalSpec>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// Sort dependencies by depth.
		Set tKey = ""
		For {
			Set tKey = $Order(pDependencyGraph(tKey),1,tData)
			Quit:tKey=""
			
			Set $ListBuild(tDepth,tServerName,tVersion) = tData
			Set tDepthList(tDepth,$Increment(tDepthList(tDepth))) = $ListBuild(tServerName,tKey,tVersion)
		}
		
		// Load and install dependencies in reverse order by depth.
		Set tDepth = ""
		For {
			Set tDepth = $Order(tDepthList(tDepth),-1,tCount)
			Quit:tDepth=""
			For i=1:1:tCount {
				Set $ListBuild(tServerName,tModuleName,tVersion) = tDepthList(tDepth,i)
				
				// Missing server name indicates that it's already present locally.
				If (tServerName '= "") {
					Set tSC = ..LoadModuleReference(tServerName,tModuleName,tVersion,.pParams)
					If $$$ISERR(tSC) {
						Quit
					}
				}
			}
			If $$$ISERR(tSC) {
				Quit
			}
		}
		If $$$ISERR(tSC) {
			Quit
		}
	} Catch e {
		If (e.Name["ZSOAP") {
			Set tSC = $Get(%objlasterror,e.AsStatus())
		} Else {
			Set tSC = e.AsStatus()
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="LoadQualifiedReference">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pReference:%ZPM.PackageManager.Core.QualifiedModuleReference,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		#dim tReference As %ZPM.PackageManager.Core.QualifiedModuleReference
		Set tReference = pReference.%ConstructClone()
		If (tReference.ServerName = "") && ##class(%ZPM.PackageManager.Client.LocalServerDefinition).SingletonExists(1,.tID) {
			Set tServer = ##class(%ZPM.PackageManager.Client.LocalServerDefinition).%OpenId(tID)
			Set tReference.ServerName = tServer.Name
    }
		Set tSC = ..LoadModuleReference(tReference.ServerName, tReference.Name, tReference.VersionString, .pParams)
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="LoadModuleReference">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pServerName:%String,pModuleName:%String,pVersion:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tExpression As %ZPM.PackageManager.Core.SemanticVersionExpression
	Set tSC = $$$OK
	Try {
		// Backward-compatibility: if params isn't an array, use it as qstruct
		If $Data(pParams) = 1 {
			Set qstruct = pParams
		}
		
		Set tVerbose = $Get(pParams("Verbose"))
		
		If '$Data(pParams("qstruct")) {
			Set qstruct = "ck"_$Select(tVerbose:"d",1:"-d")
		} Else {
			Merge qstruct = pParams("qstruct")
		}
		
		Set tServer = ##class(%ZPM.PackageManager.Client.ServerDefinition).ServerDefinitionKeyOpen(pServerName,,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tClient = tServer.GetPackageService()

		Set tModRef = ##class(%ZPM.PackageManager.Core.ResolvedModuleReference).%New()
		Set tModRef.Name = pModuleName
		Set tModRef.VersionString = pVersion
		
		// Make sure we're not downgrading.
		If '$Get(pParams("PermitDowngrade")) {
			If ##class(%ZPM.PackageManager.Developer.Module).NameExists(pModuleName) {
				Set tInstModule = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(pModuleName,,.tSC)
				If $$$ISERR(tSC) {
					Quit
				}
				
				If tInstModule.Version.Follows(tModRef.Version) {
					Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Cannot downgrade %1 from version %2 to %3",tInstModule.Name,tInstModule.VersionString,pVersion))
					Quit
				}
			}
		}
		
		Set tSC = ..GetRequiredVersionExpression(pModuleName,"",.tExpression)
		If $$$ISERR(tSC) {
			Quit
		}
		
		If 'tExpression.IsSatisfiedBy(tModRef.Version) {
			Set tSC = $$$ERROR($$$GeneralError,"Requested version (%1) does not satisfy the requirements of other modules installed in the current namespace (%2).",pVersion,tExpression.ToString())
			Quit
		}
		
		If tClient.Supports("GetModuleDirectory") {
			Set tDirectory = tClient.GetModuleDirectory(tModRef)
			Set tDeveloperMode = 0
			If (tModRef.Version.IsSnapshot() && $Get(pParams("DeveloperMode"),0)) {
				// If we are loading a module in developer mode, and are loading a snapshot version of a dependency from disk,
				// also load the snapshot version of that dependency in developer mode.
				// This doesn't make sense if we're loading the dependency from a remote server.
				Set tDeveloperMode = 1
			}
			Set tSC = ..LoadModuleFromDirectory(tDirectory,.pParams,tDeveloperMode)
		} Else {
			Set tAsArchive = -1
			Set tPayload = tClient.GetModule(tModRef, .tAsArchive)
			If (tVerbose) {
				Write !,"Module "_pModuleName_" was downloaded from "_tServer.Name_" "_tServer.URL
			}
			Set tFileName = ""
			If ($ISOBJECT(tPayload)) && (tPayload.%IsA("%Stream.FileBinary") ) {
				Set tFileName = tPayload.Filename
			}
			
			If tAsArchive<0 {
				// Read the file header
				Set tHeader = tPayload.Read(2,.tSC)
				If (tHeader = $Char(31, 139)) {
					// This is a .tgz file
					set tAsArchive = 1
				}
			}
			If (tFileName="") {
				Set tFileName = "module." _ $SELECT(tAsArchive: "tgz", 1: "xml")
			}
			Do tPayload.Rewind()
			Set tTmpStream = ##class(%Stream.FileBinary).%New()
			Set tTmpStream.Filename = tFileName
			Do tTmpStream.CopyFromAndSave(tPayload)
			
			If (tAsArchive) {
				Set tSC = ..LoadModuleFromArchive(tModRef.Name,tModRef.VersionString,tTmpStream,.pParams)
			} Else {
				// Old format (TODO: officially deprecate): try loading a .xml file
				Set tSC = $System.OBJ.Load(tTmpStream.Filename,.qstruct)
			}
            Set errorMsg = "", success = 0
            If $$$ISOK(tSC) {
                Set success = 1
            } Else {
                Set success = 0
                Set errorMsg = $System.Status.GetErrorText(tSC)
            }
            if ($System.CLS.IsMthd(tClient, "CollectAnalytics")) {
              do tClient.CollectAnalytics("install", pModuleName, pVersion,success,errorMsg)
            }
		}
		If $$$ISERR(tSC) {
			Quit
		}
		
		// If remote load is successful, also register the module in the local cache.
		If 'tModRef.Version.IsSnapshot() && ##class(%ZPM.PackageManager.Client.LocalServerDefinition).SingletonExists(1) {
			Set tLocalServer = ##class(%ZPM.PackageManager.Client.LocalServerDefinition).SingletonOpen(1,,.tSC)
			If $$$ISERR(tSC) {
				Quit
			}
			
			// Don't need to register if loading from the local server.
			If (tLocalServer '= tServer) && $IsObject($Get(tPayload)) && '##class(%ZPM.PackageManager.Server.Module).NameVersionExists(pModuleName, pVersion) {
				Set tCacheMod = ##class(%ZPM.PackageManager.Core.Module).%New()
				Set tCacheMod.Name = pModuleName
				Set tCacheMod.VersionString = pVersion
				Set tCacheMod.Manifest = tServer.GetPackageService().GetModuleManifest(tModRef)
				Do tPayload.Rewind()
				Do tCacheMod.Payload.CopyFrom(tPayload)
				Do tLocalServer.GetPublishService().PublishModule(tCacheMod)
			}
		}
	} Catch e {
		If (e.Name["ZSOAP") {
			Set tSC = $Get(%objlasterror,e.AsStatus())
		} Else {
			Set tSC = e.AsStatus()
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="LoadModuleFromArchive">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pModuleName:%String,pModuleVersion:%String,pArchiveStream:%Stream.Object,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tVerbose = $Get(pParams("Verbose"))
		
		Set tTargetDirectory = ##class(%File).ManagerDirectory()_".modules\"_$Namespace_"\"_pModuleName_"\"_pModuleVersion_"\"
		Set tTargetDirectory = ##class(%File).NormalizeDirectory(tTargetDirectory)
		If ##class(%File).DirectoryExists(tTargetDirectory) {
			// Delete it.
			Set tSC = ##class(%ZPM.PackageManager.Developer.File).RemoveDirectoryTree(tTargetDirectory)
			If $$$ISERR(tSC) {
				Quit
			}
		}
		Set tCreated = ##class(%File).CreateDirectoryChain(tTargetDirectory,.tReturnValue)
		If 'tCreated {
			Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Error creating directory %1: %2",tTargetDirectory,tReturnValue))
			Quit
		}
		Set tTargetDirectory = ##class(%File).NormalizeFilenameWithSpaces(tTargetDirectory)
		Set tSC = ##class(%ZPM.PackageManager.Developer.Archive).Extract(pArchiveStream.Filename,tTargetDirectory,.tOutput)
		If $$$ISERR(tSC) {
			Quit
		}
		For i=1:1:$Get(tOutput) {
			Write:tVerbose !,tOutput(i)
		}
		
		Set tSC = ..LoadModuleFromDirectory(tTargetDirectory, .pParams)
		If $$$ISERR(tSC) {
			Quit
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="LoadModuleFromDirectory">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pDirectory:%String,&pParams,pOverrideDeveloperMode:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tVerbose = $Get(pParams("Verbose"))
		// LoadNewModule goes all the way through Reload->Validate->Compile->Activate, also compiling the new module.
		Write:tVerbose !,"Loading from ",pDirectory,!
		If $Get(pParams("Install")) {
			// Propagate pParams fully.
			Merge tParams = pParams
			ZKill tParams("Install")
		} Else {
			// Only propagate selected settings that should apply to dependencies.
			Set tParams("DeveloperMode") = $Get(pOverrideDeveloperMode,0)
			Set tParams("Verbose") = tVerbose
		}
		Set tSC = ..LoadNewModule(pDirectory,.tParams)
		If $$$ISERR(tSC) {
			Quit
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetRequiredVersionExpression">
<Description>
Returns a semantic version expression capturing all version requirements for a given module name in the current namespace.
A list of modules to exclude may be provided (for example, if these modules would be updated at the same time).</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pModuleName:%String,pExcludeModules:%List="",*pExpression:%ZPM.PackageManager.Core.SemanticVersionExpression</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set pExpression = ##class(%ZPM.PackageManager.Core.SemanticVersionExpression).%New()
		
		Set tResult = ##class(%ZPM.PackageManager.Developer.Module).VersionRequirementsFunc(pModuleName,pExcludeModules)
		If (tResult.%SQLCODE < 0) {
			$$$ThrowStatus($$$ERROR($$$SQLCode,tResult.%SQLCODE,tResult.%Message))
		}
		
		While tResult.%Next(.tSC) {
			$$$ThrowOnError(tSC)
			$$$ThrowOnError(##class(%ZPM.PackageManager.Core.SemanticVersionExpression).FromString(tResult.%Get("Version"),.tVersionExpr))
			Set pExpression = pExpression.And(tVersionExpr)
		}
		$$$ThrowOnError(tSC)
	} Catch e {
		Set pExpression = $$$NULLOREF
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetDependentsList">
<Description><![CDATA[
Returns a flat list of dependents for a given module name (and optional version) <br />
<var>pRepoNames</var> is a $ListBuild list of repositories in which to search for dependents; if blank, only currently-installed modules (and any missing dependencies) are considered. <br />
@PrivateAPI]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pList:%Library.ListOfObjects(ELEMENTTYPE="%ZPM.PackageManager.Core.QualifiedModuleReference"),*pErrorList,pModuleName:%String,pModuleVersion:%String="",pRepoNames:%List=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Kill pErrorList
	Set pList = ##class(%Library.ListOfObjects).%New()
	Try {
		Set tSC = ..BuildAllDependencyGraphs(pRepoNames,.tGraphs,.pErrorList)
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Find subscripts containing the requested module name (and possibly version) as a dependency
		Set tDepList = ""
		For i=1:1:$Get(tGraphs) {
			If $Data(tGraphs(i,pModuleName),tInfo) {
				// Check for version match, if a version was specified.
				If (pModuleVersion '= "") && (pModuleVersion '= $ListGet(tInfo,3)) {
					Continue
				}
				
				Set tQualRef = ##class(%ZPM.PackageManager.Core.QualifiedModuleReference).%New()
				Set tQualRef.ServerName = $ListGet(tGraphs(i),1)
				Set tQualRef.Name = $ListGet(tGraphs(i),2)
				Set tQualRef.VersionString = $ListGet(tGraphs(i),3)
				Do pList.Insert(tQualRef)
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetDependentsAsTree">
<Description><![CDATA[
Returns a tree of dependents, with dependent modules at the root, for a given module name (and optional version) <br />
<var>pRepoNames</var> is a $ListBuild list of repositories in which to search for dependents; if blank, only currently-installed modules (and any missing dependencies) are considered. <br />
Tree subscripts are $lb(Name,VersionString,ServerName). <br />
@PrivateAPI]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pTree,*pErrorList,pModuleName:%String,pModuleVersion:%String="",pRepoNames:%List=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New %DepTree
	Set tSC = $$$OK
	Kill pErrorList
	Kill pTree
	Try {
		Set tSC = ..BuildAllDependencyGraphs(pRepoNames,.tGraphs,.pErrorList)
		If $$$ISERR(tSC) {
			Quit
		}
		
		// Find subscripts containing the requested module name (and possibly version) as a dependency
		Set tDepList = ""
		For i=1:1:$Get(tGraphs) {
			If $Data(tGraphs(i,pModuleName),tInfo) {
				// Check for version match, if a version was specified.
				If (pModuleVersion '= "") && (pModuleVersion '= $ListGet(tInfo,3)) {
					Continue
				}
				
				Set tDepList = tDepList_$ListBuild(i)
			}
		}
		
		// TODO: Handle cyclic dependencies?
		Set tPointer = 0
		While $ListNext(tDepList,tPointer,tDepIndex) {
			Kill tInfo Merge tInfo = tGraphs(tDepIndex)
			Do ..InvertDependencies(pModuleName,.tInfo,.tTree)
			Merge %DepTree = tTree
		}
		
		// Trim extra nodes from tree (i.e., those also dependend on by another module)
		Set tRef = "%DepTree"
		For {
			Set tRef = $Query(@tRef)
			Quit:tRef=""
			
			If $Data(@tRef) > 10 {
				ZKill @tRef
			}
		}
		
		Merge pTree = %DepTree
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="InvertDependencies">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pNodeName:%String,&pGraph,*pTree]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Kill pTree
	Set tSource = ""
	If ($ListGet(pGraph,2) = pNodeName) {
		Set tKey = $ListBuild(pNodeName,$ListGet(pGraph,3),$ListGet(pGraph,1))
		Set pTree(tKey) = ""
	} Else {
		Set tKey = $ListBuild(pNodeName,$ListGet(pGraph(pNodeName),3),$ListGet(pGraph(pNodeName),2))
		For {
			Set tSource = $Order(pGraph(pNodeName,tSource))
			Quit:(tSource="")
			
			Do ..InvertDependencies($Piece(tSource," "),.pGraph,.tTree)
			Merge pTree(tKey) = tTree
		}
	}
]]></Implementation>
</Method>

<Method name="BuildAllDependencyGraphs">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRepoNames:%List="",*pGraphs,*pErrorList</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tModule As %ZPM.PackageManager.Developer.Module
	Set tSC = $$$OK
	Kill pGraphs
	Kill pErrorList
	Try {
		If '$ListLength(pRepoNames) {
			Set tRes = ##class(%SQL.Statement).%ExecDirect(,"select Name from %ZPM_PackageManager_Developer.""Module""")
			If (tRes.%SQLCODE < 0) {
				Throw ##class(%Exception.SQL).CreateFromSQLCODE(tRes.%SQLCODE,tRes.%Message)
			}
			While tRes.%Next(.tSC) {
				If $$$ISERR(tSC) {
					Quit
				}
				
				Set tModule = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(tRes.%Get("Name"),,.tSC)
				If $$$ISERR(tSC) {
					Quit
				}
					
				// Build dependency graph. Unlike case below, do not force "reload"
				Kill tDependencyGraph,tSubModules
				Set tGraphSC = tModule.BuildDependencyGraph(.tDependencyGraph,,,,,.tSubModules)
				
				// If there's an error, note it and just move on.
				If $$$ISERR(tGraphSC) {
					// Non-fatal error
					Set pErrorList($i(pErrorList)) = $ListBuild("",tModule.Name,tModule.VersionString,tGraphSC)
					Continue
				}
				
				If '$Data(tDependencyGraph) {
					// No dependencies, don't bother recording anything.
					Continue
				}
				
				// Add dependency graph to pGraphs, subscripted by qualified module reference.
				Set pGraphs($Increment(pGraphs)) = $ListBuild("",tModule.Name,tModule.VersionString)
				Merge pGraphs(pGraphs) = tDependencyGraph
			}
			If $$$ISERR(tSC) {
				Quit
			}
		} Else {
			Set tPointer = 0
			While $ListNext(pRepoNames,tPointer,tRepoName) {
				Set tRepo = ##class(%ZPM.PackageManager.Client.ServerDefinition).ServerDefinitionKeyOpen(tRepoName,,.tSC)
				If $$$ISERR(tSC) {
					// Fatal error: repository name invalid
					Quit
				}
				
				If 'tRepo.Enabled {
					Continue
				}
				
				#dim tPackageService As %ZPM.PackageManager.Core.IPackageService
				Set tPackageService = tRepo.GetPackageService()
				Set tSearchCriteria = ##class(%ZPM.PackageManager.Core.SearchCriteria).%New()
				Set tSearchCriteria.IncludePrerelease = tRepo.Prereleases
				Set tSearchCriteria.IncludeSnapshots = tRepo.Snapshots
				Set tList = tPackageService.ListModules(tSearchCriteria)
				For i=1:1:tList.Count() {
					#dim tModRef As %ZPM.PackageManager.Core.ResolvedModuleReference
					Set tModRef = tList.GetAt(i)
					
					// Retrieve module manifest
					Set tManifest = tPackageService.GetModuleManifest(tModRef)
					
					Set tReader = ##class(%XML.Reader).%New()
					Set tSC = tReader.OpenStream(tManifest)
					If $$$ISERR(tSC) {
						Quit
					}
					Do tReader.Correlate("Module","%ZPM.PackageManager.Developer.Module")
					Do tReader.Next(.tModule,.tCorrSC)
					If $$$ISERR(tCorrSC) {
						// Non-fatal error
						Set pErrorList($i(pErrorList)) = $ListBuild(tRepoName,tModRef.Name,tModRef.VersionString,tCorrSC)
						Continue
					}
					
					// Build dependency graph, ignoring currently-installed modules (the last argument)
					Kill tDependencyGraph,tSubModules
					Set tGraphSC = tModule.BuildDependencyGraph(.tDependencyGraph,,,,,.tSubModules,,,1)
					
					// If there's an error, note it and just move on.
					If $$$ISERR(tGraphSC) {
						// Non-fatal error
						Set pErrorList($i(pErrorList)) = $ListBuild(tRepoName,tModRef.Name,tModRef.VersionString,tGraphSC)
						Continue
					}
					
					If '$Data(tDependencyGraph) {
						// No dependencies, don't bother recording anything.
						Continue
					}
					
					// Add dependency graph to pGraphs, subscripted by qualified module reference.
					Set pGraphs($Increment(pGraphs)) = $ListBuild(tRepoName,tModRef.Name,tModRef.VersionString)
					Merge pGraphs(pGraphs) = tDependencyGraph
				}
				If $$$ISERR(tSC) {
					Quit
				}
			}
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Query name="GetModuleList">
<Type>%Query</Type>
<FormalSpec>pServer:%String</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Name:%String,Version:%String,Repo:%String,Description:%String"/>
</Query>

<Method name="GetModuleListExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,pServer:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If (pServer = "") {
		Set qHandle = ""
		Quit $$$OK
	}
	Set tSC = $$$OK
	Try {
		Set tServer = ##class(%ZPM.PackageManager.Client.ServerDefinition).ServerDefinitionKeyOpen(pServer,,.tSC)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set tClient = tServer.GetPackageService()
		If tClient.IsAvailable() {
			Set tSearchCriteria = ##class(%ZPM.PackageManager.Core.SearchCriteria).%New()
			Set tSearchCriteria.IncludePrerelease = tServer.Prereleases
			Set tSearchCriteria.IncludeSnapshots = tServer.Snapshots
			Set tList = tClient.ListModules(tSearchCriteria)
			For i=1:1:tList.Count() {
				Set tMod = tList.GetAt(i)
				Set qHandle($i(qHandle)) = $ListBuild(tMod.Name,tMod.Version.ToString(),tMod.Repo,tMod.Description)
			}
		}
		
		Set qHandle = ""
	} Catch e {
		If (e.Name["ZSOAP") {
			Set tSC = $Get(%objlasterror,e.AsStatus())
		} Else {
			Set tSC = e.AsStatus()
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetModuleListFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>GetModuleListExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set qHandle = $Order(qHandle(qHandle),1,Row)
	Set:qHandle="" AtEnd = 1
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetModuleListClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>GetModuleListExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetModuleNameFromXML">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDirectory:%String,*name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set stream=##class(%Stream.FileBinary).%New()
	Set tSC = stream.LinkToFile(pDirectory_"module.xml")
	Return:$$$ISERR(tSC) tSC 
	Set tSC = ##class(%XML.XPATH.Document).CreateFromStream(stream, .tDocument)
	Return:$$$ISERR(tSC) tSC 	
	Set tSC = tDocument.EvaluateExpression("/Export/Document/Module/Name", "text()", .tRes)
    If $$$ISERR(tSC) Return tSC
	Set name = $$$lcase(tRes.GetAt(1).Value)
	Return $$$OK
]]></Implementation>
</Method>

<Method name="LoadNewModule">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pDirectory:%String,&pParams]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	Set (tPrevModule, name) = ""
	try {
		set tVerbose = $Get(pParams("Verbose"))
		If '$Data(pParams("qstruct")) {
			Set qstruct = "ck"_$Select(tVerbose:"d",1:"-d")
		}
		set pDirectory = ##class(%File).NormalizeDirectory("",pDirectory)
		
		// get modulename from xml
		$$$ThrowOnError(..GetModuleNameFromXML(pDirectory, .moduleName))
		// try opening module object 
		Set tModule = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(moduleName,,.tSC)
		If $IsObject(tModule) {
			Set tPrevModule = tModule.%ConstructClone()
			Kill tModule
		}

		set tSC = $system.OBJ.Load(pDirectory_"module.xml",$Select(tVerbose:"d",1:"-d"),.error,.tLoadedList) quit:$$$ISERR(tSC)
		;
		set first = $Order(tLoadedList(""))
		if first=""                   set tSC = $$$ERROR($$$GeneralError,"No module definition found.") quit
		if $Order(tLoadedList(first))'="" set tSC = $$$ERROR($$$GeneralError,"module.xml is malformed.") quit
		set first = $$$lcase(first)
		if $p(first,".",*)'="zpm"  set tSC = $$$ERROR($$$GeneralError,"No module definition found.") quit
		;
		set name = $p(first,".",1,*-1)
		;
		set tModule = ##class(%ZPM.PackageManager.Developer.Module).NameOpen(name,,.tSC) quit:$$$ISERR(tSC)
		if '$Data($$$ZPMHandledModules($Namespace)) {
			// The purpose of this NEW command is to make sure that the % variable $$$ZPMHandledModules refers to doesn't leak outside this scope.
			// This only happens for the first module to be loaded in a set of dependencies (using zpm "load ..." or zpm "install ...")
			// $$$ZPMHandledModules is also used in the ExecutePhases method of %ZPM.PackageManager.Developer.Module to
			// cover cases where new dependencies are added and a module is compiled without reloading, and in the BuildDependencyGraph
			// method to treat installed snapshot versions as installed rather than forcing reload if they have been reloaded
			// as part of the same root module operation.
			new $$$ZPMHandledModules
			set $$$ZPMHandledModules($Namespace) = "" //Initialize.
		}
		$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.Module).CheckSystemRequirements(name))
		set tSC = tModule.LoadDependencies("",.pParams) quit:$$$ISERR(tSC)
		;
		set path = pDirectory_"preload"
		if ##class(%File).DirectoryExists(path) {
			set tSC = $system.OBJ.ImportDir(path,"*.inc",$Select(tVerbose:"d",1:"-d")_"/compile",,1) quit:$$$ISERR(tSC)
			set tSC = $system.OBJ.LoadDir(path,$Select(tVerbose:"d",1:"-d")_"/compile",,1) quit:$$$ISERR(tSC)
		} else {
			write:tVerbose !,"Skipping preload - directory does not exist."
		}
		;
		set tSC = $system.OBJ.Load(pDirectory_"module.xml",$Select(tVerbose:"d",1:"-d"),.error,.tLoadedList) quit:$$$ISERR(tSC)
		set tSC = tModule.%Reload() quit:$$$ISERR(tSC)
		if $Get(pParams("DeveloperMode"),0) {
			if tModule.GlobalScope {
				set ^%SYS("ModuleRoot","*",name) = pDirectory
				set ^%SYS("ModuleRoot","*",name,"DeveloperMode") = 1
			} else {
				set ^%SYS("ModuleRoot",$namespace,name) = pDirectory
				set ^%SYS("ModuleRoot",$namespace,name,"DeveloperMode") = 1
			}
		}
		;
		set pParams("RootDirectory") = pDirectory
		set tSC = ##class(%ZPM.PackageManager.Developer.Module).ExecutePhases(name,$lb("Activate"),1,.pParams) quit:$$$ISERR(tSC)
		;
	} catch e {
		If ('$IsObject(tPrevModule)) {
			// delete module object if it's new one
			Do ##class(%ZPM.PackageManager.Developer.Module).NameDelete(name)
		} Else {
			// save previous vresion of the object
			Do ##class(%ZPM.PackageManager.Developer.Module).NameDelete(name)
			If $IsObject(tPrevModule) {
				Do tPrevModule.%Save()
			}
		}
		set tSC = e.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="AddPackageMapping">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String,pMapping:%String,pFrom:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		If $$$ucase(pNamespace) = "%ALL" {
			Set tSC = ..CreateAllNamespace()
			If $$$ISERR(tSC) {
				Quit
			}
		}
		new $namespace
		set $namespace = "%SYS"
		kill p set p("Database") = pFrom
		if '##Class(Config.MapPackages).Exists(pNamespace,pMapping) {
			set tSC = ##Class(Config.MapPackages).Create(pNamespace,pMapping,.p,,1) quit:$$$ISERR(tSC)
		}
		set tSC = ..ActivateMappings(pNamespace) quit:$$$ISERR(tSC)
	} catch e {
		set tSC = e.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="RemovePackageMapping">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String,pMapping:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		new $namespace
		set $namespace = "%SYS"
		if ##Class(Config.MapPackages).Exists(pNamespace,pMapping) {
			set tSC = ##Class(Config.MapPackages).Delete(pNamespace,pMapping) quit:$$$ISERR(tSC)
		}
		set tSC = ..ActivateMappings(pNamespace) quit:$$$ISERR(tSC)
	} catch e {
		set tSC = e.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="AddRoutineMapping">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String,pMapping:%String,pType:%String="ALL",pFrom:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		If $$$ucase(pNamespace) = "%ALL" {
			Set tSC = ..CreateAllNamespace()
			If $$$ISERR(tSC) {
				Quit
			}
		}
		new $namespace
		set $namespace = "%SYS"
		kill p set p("Database") = pFrom
		set pMapping = pMapping_$S(pType="ALL":"",1:"_"_pType)
		if '##Class(Config.MapRoutines).Exists(pNamespace,pMapping) {
			set tSC = ##Class(Config.MapRoutines).Create(pNamespace,pMapping,.p,,1) quit:$$$ISERR(tSC)
		}
		; work around bug that Config.MapRoutines doesn't map ^rINDEX for INC files
		if pType="INC" {
			set tSC = ..AddGlobalMapping(pNamespace,"rINDEX("""_$e(pMapping,1,*-4)_""",""INC"")",pFrom)
			quit:$$$ISERR(tSC)
		}
		set tSC = ..ActivateMappings(pNamespace) quit:$$$ISERR(tSC)
	} catch e {
		set tSC = e.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="RemoveRoutineMapping">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String,pMapping:%String,pType:%String="ALL"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		new $namespace
		set $namespace = "%SYS"
		set pMapping = pMapping_$S(pType="ALL":"",1:"_"_pType)
		if ##Class(Config.MapRoutines).Exists(pNamespace,pMapping) {
			set tSC = ##Class(Config.MapRoutines).Delete(pNamespace,pMapping) quit:$$$ISERR(tSC)
		}
		; work around bug that Config.MapRoutines doesn't map ^rINDEX for INC files
		if pType="INC" {
			set tSC = ..RemoveGlobalMapping(pNamespace,"rINDEX("""_$e(pMapping,1,*-4)_""",""INC"")")
			quit:$$$ISERR(tSC)
		}
		set tSC = ..ActivateMappings(pNamespace) quit:$$$ISERR(tSC)
	} catch e {
		set tSC = e.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="AddGlobalMapping">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String,pMapping:%String,pFrom:%String,pSetCollation:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		If $$$ucase(pNamespace) = "%ALL" {
			Set tSC = ..CreateAllNamespace()
			If $$$ISERR(tSC) {
				Quit
			}
		}
		new $namespace
		set $namespace = "%SYS"
		kill p set p("Database") = pFrom
		If pSetCollation {
			Set tDB=##class(SYS.Database).%OpenId($ZU(12)_pFrom)
			Set:$IsObject(tDB) p("Collation") = tDB.NewGlobalCollation
		}
		if pMapping[":(" set pMapping=$p(pMapping,":(")_"("_$p(pMapping,":(",2,999) // 2008 has glo:(subs), 2009 has glo(subs)
		if '##Class(Config.MapGlobals).Exists(pNamespace,pMapping) {
			set tSC=##Class(Config.MapGlobals).Create(pNamespace,pMapping,.p,,1) quit:$$$ISERR(tSC)
		}
		set tSC = ..ActivateMappings(pNamespace) quit:$$$ISERR(tSC)
	} catch e {
		set tSC = e.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="RemoveGlobalMapping">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String,pMapping:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	try {
		new $namespace
		set $namespace = "%SYS"
		if pMapping[":(" set pMapping=$p(pMapping,":(")_"("_$p(pMapping,":(",2,999) // 2008 has glo:(subs), 2009 has glo(subs)
		if ##Class(Config.MapGlobals).Exists(pNamespace,pMapping) {
			set tSC = ##Class(Config.MapGlobals).Delete(pNamespace,pMapping) quit:$$$ISERR(tSC)
		}
		set tSC = ..ActivateMappings(pNamespace) quit:$$$ISERR(tSC)
	} catch e {
		set tSC = e.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="CreateAllNamespace">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set $Namespace = "%SYS"

	Set ns = "%All"
	Set tSC = $$$OK

	if ('##Class(Config.Namespaces).Exists(ns)) {

		Set dbPrefix = $select($ZVERSION["IRIS": "IRIS", 1: "CACHE")
		Set Properties("Globals") = dbPrefix _ "TEMP"
		Set Properties("Routines") = dbPrefix _ "TEMP"
		
		Set tSC = ##Class(Config.Namespaces).Create(ns, .Properties)
		If ($$$ISERR(tSC)) {
			Return tSC
		}
	}
	Return tSC
]]></Implementation>
</Method>

<Method name="GetRoutineDatabase">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	new $namespace
	set $namespace="%SYS"
	quit ##class(Config.Namespaces).Open(pNamespace).Routines
]]></Implementation>
</Method>

<Method name="GetGlobalDatabase">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	new $namespace
	set $namespace="%SYS"
	quit ##class(Config.Namespaces).Open(pNamespace).Globals
]]></Implementation>
</Method>

<Method name="GetRoutineDatabaseDir">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	new $namespace
	set $namespace="%SYS"
	quit ..GetDatabaseDirectory(..GetRoutineDatabase())
]]></Implementation>
</Method>

<Method name="GetGlobalDatabaseDir">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	new $namespace
	set $namespace="%SYS"
	quit ..GetDatabaseDirectory(..GetGlobalDatabase())
]]></Implementation>
</Method>

<Method name="GetDatabaseDirectory">
<ClassMethod>1</ClassMethod>
<FormalSpec>pDatabase:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	new $namespace
	set $namespace="%SYS"
	quit ##class(Config.Databases).Open(pDatabase).Directory
]]></Implementation>
</Method>

<Method name="ActivateMappings">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace=$namespace</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC=$$$OK
	try {
		new $Namespace
		set $Namespace = "%SYS"
		set tSC = ##Class(Config.CPF).Write() Quit:$$$ISERR(tSC)
		set tSC = ##Class(Config.Map).MoveToActive() Quit:$$$ISERR(tSC)
		set tSC = ##Class(Config.Namespaces).Load(pNamespace) Quit:$$$ISERR(tSC)
	} Catch ex {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="CopyItems">
<Description><![CDATA[
This method exports items (classes, routines, etc.) and reloads it into a different namespace
The syntax for itemspec is the Name attribute in <Resource> tag and <Mapping> tag]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>itemspec,source,target,qspec</FormalSpec>
<Implementation><![CDATA[
    set tSC = $$$OK
    try {
        new $namespace
        set $namespace = target
		set tSC = ##class(%ZPM.PackageManager.Developer.Utils).ResolveItems(.itemlist,itemspec,source) quit:$$$ISERR(tSC)
        set filestream=##class(%FileCharacterStream).%New()
        do filestream.Write("")
        set tSC = $$exportItems(source,.itemlist,filestream.Filename) quit:$$$ISERR(tSC)
        set tSC = $system.OBJ.Load(filestream.Filename,"/nocompile/checkuptodate"_qspec) quit:$$$ISERR(tSC)
    } catch ex {
        set tSC = ex.AsStatus()
    }
    quit tSC
    ;
exportItems(namespace,itemlist,filename)
    new $namespace
    set $namespace = namespace
    quit $system.OBJ.Export(.itemlist,filename,"/nodisplay"_qspec)
]]></Implementation>
</Method>

<Method name="ResolveItems">
<Description><![CDATA[
This method resolves itemspec used by Name sttribute in <Resource> and <Mapping>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>itemlist,itemspec,namespace</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set tSC = $$$OK
    try {
        new $namespace
        set $namespace = namespace
        kill itemlist
        set type = $p(itemspec,".",*)
        if type="PKG" do getPackage(.itemlist,$p(itemspec,".",1,*-1)) quit
        if $lf($lb("CLS","MAC","INC"),type) set itemlist(itemspec) = "" quit
    } catch ex {
        set tSC = ex.AsStatus()
    }
    quit tSC
	;
getPackage(itemlist,package)
	set pplen = $l(package,".")
	set class = package_"."
	for  {
		set class = $o(^oddDEF(class)) quit:class=""  quit:$p(class,".",1,pplen)'=package
		set itemlist(class_".CLS") = ""
	}
	quit
	;
]]></Implementation>
</Method>

<Method name="BeginCaptureOutput">
<Description><![CDATA[
This method enables I/O redirection (see EndCaptureOutput for retrieval). <var>pCookie</var> has the previous I/O redirection info.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>*pCookie:%String</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New tSC,e

	#dim tSC As %Status = $$$OK
	#dim e As %Exception.AbstractException

	Try {
		#; This facility is not re-entrant
		If $Data(^||%capture) Set tSC=$$$ERROR($$$GeneralError,"Capture Already Active") Quit

		#; If re-direction is already active
		If $zutil(82,12) {
			#; Retain the name of the re-directed routine
			Set pCookie=$ZU(96,12)
		} else {
			Set pCookie=""
		}

		#; Use THIS routine for redirection
		Use $io::("^"_$ZNAME)

		#; Switch redirection on
		Do $zutil(82,12,1)

		Kill ^||%capture

	} Catch (e) {
	Set tSC=e.AsStatus()
	}
	Quit tSC
    
   #; Internal Entry points for device re-direction
rstr(sz,to) [rt] public {
	New rt Set vr="rt"
	Set rd=$zutil(82,12,0)
	Set:$data(sz) vr=vr_"#"_sz Set:$data(to) vr=vr_":"_to
	Read @vr
	Do:$data(to) $zutil(96,4,$t)
	Do $zutil(82,12,rd)
	Quit rt
  }
wchr(s)public { Do write($char(s)) }
wff() public { Do write($char(12)) }
wnl() public {
	If '$data(^||%capture(0)) Set ^||%capture(0)=1,^(1)=""
	Set ^||%capture($increment(^||%capture(0)))=""
  }
wstr(s) public { Do write(s) }
wtab(s) public { Do write($justify("",s-$x)) }
write(s) public {
	Set lf=$find(s,$C(10))
	While lf {
	    Do write($Extract(s,1,lf-2)),wnl()
	    Set s=$Extract(s,lf,*)
	    Set lf=$find(s,$C(10))
	}
	Set lno=$get(^||%capture(0)) Set:lno="" lno=1,^||%capture(0)=1
	Set ^||%capture(lno)=$get(^||%capture(lno))_$translate(s,$char(13))
  }
]]></Implementation>
</Method>

<Method name="EndCaptureOutput">
<Description>
This method captures the output from a program and delivers it as an array of lines</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCookie:%String,*pText</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tLast,tKey,tValue As %String

	If pCookie'="" {
		#; Use the original redirected routine
		Use $io::("^"_pCookie)
	} else {
		#; Otherwise switch redirection off
		Do $zutil(82,12,0)
	}

	Try {
		Set tLast=$Get(^||%capture(0),0)
		For tKey=1:1:tLast-1 {
			Set pText($i(pText)) = ^||%capture(tKey)
		}
		If tLast,^||%capture(tLast)'="" {
			Set pText($i(pText)) = ^||%capture(tLast)
		}
	} Catch {
		Set pText($i(pText)) = "Capture error: "_$ZE
	}

	Kill ^||%capture

	Quit $$$OK
]]></Implementation>
</Method>

<Query name="OrphanedResources">
<Type>%Query</Type>
<FormalSpec>pNamespace:%String=$Namespace,pType:%String=""</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Name:%String"/>
</Query>

<Method name="OrphanedResourcesExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,pNamespace:%String=$Namespace,pType:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set tFilter = $Case(pType,"":"",:"*."_pType)
		// (Spec,Dir,OrderBy,SystemFiles,Flat,NotStudio=0,ShowGenerated=1,Filter,RoundTime=0,Mapped=1)
		Set tResult = ##class(%Library.RoutineMgr).StudioOpenDialogFunc(tFilter,1,1,0,1,,0,,,0)
		If (tResult.%SQLCODE < 0) {
			Set tSC = $$$ERROR($$$SQLCode,qHandle.%SQLCODE,qHandle.Message)
		}
		While tResult.%Next(.tSC) {
			If $$$ISERR(tSC) {
				Quit
			}
			
			Set tName = tResult.%Get("Name")
			If '$IsObject(##class(%ZPM.PackageManager.Developer.Extension.Utils).FindHomeModule(tName)) {
				Set ^||%ZPM.OrphanedResources($i(^||%ZPM.OrphanedResources)) = $ListBuild(tName)
			}
		}
		
		Set qHandle=""
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OrphanedResourcesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>OrphanedResourcesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Set qHandle = $Order(^||%ZPM.OrphanedResources(qHandle),1,tData)
		If (qHandle = "") {
			Set AtEnd = 1
		} Else {
			Set Row = tData
		}
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OrphanedResourcesClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>OrphanedResourcesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill ^||%ZPM.OrphanedResources
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetInstallerProperties">
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%String="",pExcept:%String=""</FormalSpec>
<PublicList>tExcept,tClass</PublicList>
<Implementation><![CDATA[
	Set tExcept = pExcept
	If '$LISTVALID(pExcept) {
		Set tExcept = $LISTFROMSTRING(pExcept)
	}
	Set tClass = "%Installer."_pClass
	Set tRes = ##class(%SQL.Statement).%ExecDirect(,
		"SELECT LIST(Name) FROM %Dictionary.PropertyDefinition "_
		"WHERE Parent = :tClass AND (:tExcept IS NULL OR Name NOT %INLIST :tExcept) "_
		"ORDER BY SequenceNumber")
	Do tRes.%Next()
	set res = tRes.%GetData(1)
	Quit tRes.%GetData(1)
]]></Implementation>
</Method>

<Method name="RunCommandViaCPIPE">
<Description><![CDATA[
Copied from %Net.Remote.Utility:RunCommandViaCPIPE and modified slightly to fit these purposes:
Run a command using a CPIPE device.
The first unused CPIPE device is allocated and returned in pDevice.  Upon exit the device is open; 
it is up to the caller to close that device when done with it. <br/>
<var>pTimeout</var> indicates how long to wait for the initial OPEN and <var>pTimeoutRead</var> indicates how long to wait between reading the output chunks</var>. <br/>
Note that CPIPE (and PIPE) devices are supported on Unix and Windows, but not on VMS.  If this method is invoked
on an instance installed on VMS, execution flow will be diverted to method <method>RunCommandViaZF</method>
which uses a different technique.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCmd:%String,*pOutput,pTimeout:%Integer=10,pTimeoutRead:%Integer=5</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pOutput
	
	If ($System.Version.GetBuildOS() = "VMS") {
		Quit ..RunCommandViaZF($G(pCmd), .pOutput, pTimeout)
	}

	Set tSC = $$$OK
	Set tIO = $IO
	Set tZEOFMode = $ZU(68,40,1)
	Set pDevice = "|CPIPE|"
	
	Try {
		Set p = ##class(%SYS.ProcessQuery).Open($J)
		Set od = ","_p.OpenDevices_","
		For x = "",1:1:100 If od'[(",|CPIPE|"_x_",") Set pDevice = "|CPIPE|"_x Quit
		Set p = ""
	}
	Catch {
	}
	
	Try {
		Open pDevice:(pCmd:"R"):pTimeout
		If '$T Set tSC = $$$ERROR($$$CacheError, "Failed to open |CPIPE| device in read mode for command: '"_pCmd_"'") Quit
		Use pDevice
		For {
			// Keep reading through end of input; save only first 32,000 characters
			Set tLine = "" Read tLine:pTimeoutRead
			If '$T && (tLine=$C(-1)) Quit  // Exit by timeout
			If $Length(tLine)<32000 {
				Set pOutput($i(pOutput)) = tLine
			} Else {
				Set pOutput($i(pOutput)) = $E(tLine,1,32000)_" (more...)"
			}
			If ($ZEOF=-1) Quit  // Exit by EOF
		}
	} Catch (ex) {
		Set tSC = ex.AsStatus()
	}
	
	Close pDevice
	
	If 'tZEOFMode {
		Do $ZU(68,40,0) // Restore ZEOF mode
	}
	Use tIO
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="RunCommandViaZF">
<Description><![CDATA[
Copied from %Net.Remote.Utility:RunCommandViaCPIPE and modified slightly to fit these purposes:
Run a command using $ZF(-1) and an external temporary file to store the command output. <br>
If <var>pDeleteTempFile</var> is 0 (false), the temporary file is not deleted; in this case, it is up to the caller to delete it when done with it.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCmd:%String,*pLogOutput,*pErrOutput,pTimeout:%Integer=10,*pRetCode:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set pRetCode = ""
	Set IO = $IO
	Set ZEOFMode = $ZU(68,40,1)

	Try {
		Set tFile = ##class(%File).TempFilename("txt")
		If tFile="" Set tSC = $$$ERROR($$$CacheError, "Failed to obtain a temporary file name") Quit
		Set tErrFile = ##class(%File).TempFilename("txt")
		If tErrFile="" Set tSC = $$$ERROR($$$CacheError, "Failed to obtain a temporary file name") Quit
		If $System.Version.GetBuildOS()="VMS" {
			Set pRetCode = $ZF(-1,pCmd,tFile)
		} Else {
			Set:pCmd[" 2>&1" pCmd = $P(pCmd,"2>&1",1)
			Set pRetCode = $ZF(-1,pCmd_" > "_tFile_" 2> "_tErrFile)
		}
		
		$$$ThrowOnError(..GetFileLines(tFile,.pLogOutput))
		$$$ThrowOnError(..GetFileLines(tErrFile,.pErrOutput))
	} Catch (ex) {
		Set tSC = ex.AsStatus()
	}

	If 'ZEOFMode Do $ZU(68,40,0) // Restore ZEOF mode
	Use IO
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetFileLines">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFileName:%String,*pOutput</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill pOutput
		Close pFileName Open pFileName:("RS"):5
		If '$T Set tSC = $$$ERROR($$$CacheError, "Failed to open temporary file '"_pFileName_"'") Quit
		Set TooMuch = 0
		Use pFileName
		For {
			// Keep reading through end of file; save only first 32,000 characters
			Set tLine = "" Read tLine:1
			If '$T && (tLine=$C(-1)) Quit  // Exit by timeout
			If $Length(tLine)<32000 {
				Set pOutput($i(pOutput)) = tLine
			} Else {
				Set pOutput($i(pOutput)) = $E(tLine,1,32000)_" (more...)"
			}
			If ($ZEOF=-1) Quit  // Exit by EOF
		}
		Close pFileName:"D"
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Developer.XML.CommentHandler">
<Description>
Use: Extracts XML comments from a document and allows them to be added back in later,
assuming that the XPath paths to their previous locations are still valid.</Description>
<Super>%XML.SAX.ContentHandler</Super>
<TimeCreated>65797,80972.541034</TimeCreated>

<Property name="Comments">
<Description><![CDATA[
..Comments = <number of comments extracted from document>
..Comments(i) = <text of ith comment in XML document>]]></Description>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="CommentMap">
<Description><![CDATA[
..CommentMap(i) = <XPath expression for location of ..Comments(i)>]]></Description>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="Path">
<Description><![CDATA[
..Path = <depth of current path in document>
..Path(i) = $ListBuild(<containing element descriptor>,<previous element descriptor>,<previous padding characters>)]]></Description>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Property name="Padding">
<Type>%String</Type>
<Private>1</Private>
<Parameter name="MAXLEN"/>
</Property>

<Method name="GetResults">
<Internal>1</Internal>
<FormalSpec>*pComments,*pCommentMap</FormalSpec>
<Implementation><![CDATA[
	Merge pComments = i%Comments
	Merge pCommentMap = i%CommentMap
]]></Implementation>
</Method>

<Method name="Reapply">
<FormalSpec><![CDATA[&pXMLStream:%Stream.Object,pIndent:%Boolean=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		// Construct XSLT to add comments back in.
		Do ..GetResults(.tComments, .tCommentMap)
		If '$Data(tComments) {
			// No-op.
			Quit
		}
		
		Set tXSL = ##class(%Stream.TmpBinary).%New()
		Do tXSL.Write("<?xml version=""1.0"" encoding=""UTF-8""?>")
		Do tXSL.Write("<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"">")
		Do tXSL.Write("<xsl:output method=""xml"" "_$Select(pIndent:"indent=""yes""",1:"")_"/>")
		Do tXSL.Write("<xsl:template match=""node()|@*"">")
    	Do tXSL.Write("<xsl:copy>")
        Do tXSL.Write("<xsl:text /><xsl:apply-templates select=""node()|@*""/><xsl:text />")     
    	Do tXSL.Write("</xsl:copy>")
		Do tXSL.Write("</xsl:template>")
		
		// First pass: build map of comments to associated elements (with filters)
		#define BEFORE 0
		#define AFTER 1
		For i=1:1:$Get(tComments) {
			Set tComment = tComments(i)
			Set tContainerElement = $ListGet(tCommentMap(i))
			Set tPrevElement = $ListGet(tCommentMap(i),2)
			Set tPadding = $ListGet(tCommentMap(i),3)
			
			If (tPrevElement = $lb("","")) {
				Set tMatch = $ListGet(tContainerElement,2)
				Set tPlace = $$$BEFORE
			} Else {
				Set tMatch = $ListGet(tPrevElement,2)
				Set tPlace = $$$AFTER
			}
			
			// Hash to avoid <SUBSCRIPT> errors
			Set tHash = $zcrc(tMatch,7)
			Set tLocationHashMap(tHash) = tMatch
			Set tLocationHashMap(tHash,tPlace,i) = $lb(tPadding,tComment)
		}
		
		// Second pass: write XSLT to add comments
		Set tKey = ""
		For {
			Set tKey = $Order(tLocationHashMap(tKey),1,tMatchExpression)
			Quit:tKey=""
			
			Do tXSL.Write("<xsl:template match="""_tMatchExpression_""">")
			Do tXSL.Write("<xsl:copy><xsl:copy-of select=""@*""/>")
			
			Set tBeforeKey = 0
			For {
				Set tBeforeKey = $Order(tLocationHashMap(tKey,$$$BEFORE,tBeforeKey),1,tData)
				Quit:tBeforeKey=""
				
				Do:pIndent tXSL.Write("<xsl:text>"_$ZConvert($ListGet(tData,1),"O","XML")_"</xsl:text>")
				Do tXSL.Write("<xsl:comment>"_$ZConvert($ListGet(tData,2),"O","XML")_"</xsl:comment>")
			}
			
			Do tXSL.Write("<xsl:apply-templates select=""node()|@*"" /></xsl:copy>")
			
			Set tAfterKey = 0
			For {
				Set tAfterKey = $Order(tLocationHashMap(tKey,$$$AFTER,tAfterKey),1,tData)
				Quit:tAfterKey=""
				
				Do:pIndent tXSL.Write("<xsl:text>"_$ZConvert($ListGet(tData,1),"O","XML")_"</xsl:text>")
				Do tXSL.Write("<xsl:comment>"_$ZConvert($ListGet(tData,2),"O","XML")_"</xsl:comment>")
			}
			Do tXSL.Write("</xsl:template>")
		}
		
		Do tXSL.Write("</xsl:stylesheet>")
		
		// Apply XSLT to input stream.
		Set tSC = ##class(%XML.XSLT.Transformer).TransformStream(pXMLStream, tXSL, .tOutStream)
		If $$$ISERR(tSC) {
			Quit
		}
		
		Set pXMLStream = tOutStream
	} Catch e {
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="BuildAttributeFilter">
<ClassMethod>1</ClassMethod>
<FormalSpec>pAttrList:%List</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If (pAttrList = "") {
		Quit ""
	}
	
	Set tPointer = 0
	Set tExpr = ""
	While $ListNext(pAttrList,tPointer,tAttr) {
		Set tExpr = tExpr_"[@"_$ListGet(tAttr)_"='"_$Replace($ListGet(tAttr,2),"'","\'")_"']"
	}
	Quit tExpr
]]></Implementation>
</Method>

<Method name="comment">
<Description><![CDATA[
Receive notification of comments.

<p>The Parser will call this method to report each occurence of
a comment in the XML document.</p>

<p>The application must not attempt to read from the array
outside of the specified range.</p>
<ul>
<li>chars: The characters from the XML document.</li>
<li>length: The number of characters to read from the array.</li>
</ul>
<p>
Exceptions thrown: SAXException - Any SAX exception, possibly
wrapping another exception.</p>]]></Description>
<FormalSpec>chars:%String,length:%Integer</FormalSpec>
<Implementation><![CDATA[
	Set tPosition = ..GetPosition()
	Set i%Comments($Increment(i%Comments)) = chars
	Set i%CommentMap(i%Comments) = tPosition
	Set i%Padding = ""
	Quit
]]></Implementation>
</Method>

<Method name="GetPosition">
<Description>
Returns current position in the XML document, as an XPath expression with information on the previous node.</Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tPath = ""
	Set tPrevious = ""
	Set tType = ""
	Set tPreviousType = ""
	Set tPadding = ""
	For i=1:1:$Get(..Path) {
		Kill tVal1,tVal2
		Set $ListBuild(tType,tVal1) = ..Path(i)
		If (i = ..Path) {
			Set tNext = $Case(tType,
				"element":"/"_tVal1,
				"document":"/",
				:"")
			Set tPrevious = $Get(..Path(i+1))
		} Else {
			Set tNext = $Case(tType,
				"element":"/"_tVal1,
				:"")
		}
		Set tPath = tPath_tNext
		If (tPrevious '= "") {
			Set tPreviousType = $ListGet(tPrevious,1)
			Set tPrevious = tPath_
				$Case(tType,"document":"",:"/")_
				$ListGet(tPrevious,2)
		}
	}
	Quit $ListBuild($ListBuild(tType,tPath),$ListBuild(tPreviousType,tPrevious),i%Padding)
]]></Implementation>
</Method>

<Method name="startDocument">
<Description><![CDATA[
Receive notification of the beginning of the document.

<p>
By default, do nothing.  Application writers may override this
method in a subclass to take specific actions at the beginning
of a document (such as allocating the root node of a tree or 
creating an output file)
<p>]]></Description>
<Implementation><![CDATA[
	Kill i%Comments
	Kill i%CommentMap
	Set i%Padding = ""
	Set i%Path($i(i%Path)) = $lb("document")
]]></Implementation>
</Method>

<Method name="startElement">
<Description><![CDATA[
Receive notification of the start of an element.

<p>
By default, do nothing.  Application writers may override this
method in a subclass to take specific actions at the start of
each element (such as allocating a new tree node or writin
output to a file).
</p>
<p>
<ul>
<li>uri: The URI of the associated namespace for this element</li>
<li>localname: the local part of the element name</li>
<li>qname: the QName of this element</li>
<li>attrs: a list in $List format consisting of a repeating group of attributes.</li>
</ul>
<p>
The format of the repeating group is as follows:
<ul>
<li>+0 - uri: The URI of the associated namespace for this attribute</li>
<li>+1 - localname: The local part of the name of this attribute</li>
<li>+2 - qname: The QName of this attribute</li>
<li>+3 - type: The type of this attribute ("CDATA", NMTOKEN", "ENTITY", etc.)</li>
<li>+4 - value: The value of this attribute</li>
</ul>
</p>]]></Description>
<FormalSpec>uri:%Library.String,localname:%Library.String,qname:%Library.String,attrs:%Library.List</FormalSpec>
<Implementation><![CDATA[
	// Extract just qname/value from attrs, build $lb($lb(qname,value),$lb(qname,value),...)
	Set tModArgs = ""
	Set tPointer = 0
	Set tQName = ""
	Set tPosition = 0
	While $ListNext(attrs,tPointer,tAttrValue) {
		If (tPosition#5) = 2 {
			Set tQName = tAttrValue
		} ElseIf (tPosition#5) = 4 {
			Set tModArgs = tModArgs_$ListBuild($ListBuild(tQName,tAttrValue))
			Set tQName = ""
		}
		Set tPosition = tPosition + 1
	}
	
	Set tFilter = ..BuildAttributeFilter(tModArgs)
	
	// Update path info
	Set i%Path($Increment(i%Path)) = $lb("element",localname_tFilter)
	Set tNext = i%Path
	For {
		Set tNext = $Order(i%Path(tNext))
		Quit:tNext=""
		Kill i%Path(tNext)
	}
	Set i%Padding = ""
]]></Implementation>
</Method>

<Method name="endElement">
<Description><![CDATA[
Receive notification of the end of an element.

<p>
By default, do nothing.  Application writers may override this
method in a subclass to take specific actions at the end of
each element (such as finalising a tree node or writing
output to a file).
</p>

<p>
<ul>
<li>uri: The URI of the associated namespace for this element</li>
<li>localname: The local part of the element name</li>
<li>qname: The QName of this element</li>
</ul>
</p>]]></Description>
<FormalSpec>uri:%Library.String,localname:%Library.String,qname:%Library.String</FormalSpec>
<Implementation><![CDATA[
	Set i%Path = i%Path - 1
	Set i%Padding = ""
]]></Implementation>
</Method>

<Method name="characters">
<Description><![CDATA[
Receive notification of character data inside an element.

<p>
By default, do nothing.  Application writers may override this
method to take specific actions for each chunk of character data
(such as adding the data to a node or buffer, or printing it to
a file).
</P>
<p>
<ul>
<li>chars: The characters.</li>
<li>length: The number of characters to use from the character
array.</li>
</ul>]]></Description>
<FormalSpec>chars:%Library.String,length:%Library.Integer</FormalSpec>
<Implementation><![CDATA[	Set i%Padding = chars
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Server.AbstractService">
<Abstract>1</Abstract>
<IncludeCode>%ZPM.PackageManager.Common</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>65797,80972.541896</TimeCreated>

<Method name="IsEnabled">
<Description><![CDATA[
Returns 1 if and only if the service is enabled for <var>pApplication</var>; if <var>pApplication</var> is unspecified,
returns 1 if and only if the service is enabled for any web application in the current namespace.
In the latter case, also returns an array of web applications for which the namespace is enabled.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pApplication:%String="",*pAppArray</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Kill pAppArray
	Set tEnabled = 0
	If (pApplication = "") {
		Merge pAppArray = $$$ZPMConfig("SOAPService", $classname())
		Set tEnabled = ''$Data(pAppArray)
	} Else {
		// Strip off trailing / if it's coming from %session.Application
		// to match the format of Security.Applications
		If ($Extract(pApplication,*) = "/") {
			Set pApplication = $Extract(pApplication,1,*-1)
		}
		Set tEnabled = $Get($$$ZPMConfig("SOAPService", $classname(), pApplication), 0)
	}
	Quit tEnabled
]]></Implementation>
</Method>

<Method name="Enable">
<Description>
Enables the specified web application for a given SOAP service</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pApplication:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $$$ZPMConfig("SOAPService", $classname(), pApplication) = 1
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Disable">
<Description>
Enables the specified web application for a given SOAP service</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pApplication:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If (pApplication = "") {
		Kill $$$ZPMConfig("SOAPService", $classname())
	} Else {
		Kill $$$ZPMConfig("SOAPService", $classname(), pApplication)
	}
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Server.Application">
<Super>%Persistent,%ZPM.PackageManager.Core.Application</Super>
<TimeCreated>65797,80972.587535</TimeCreated>

<Parameter name="XMLTYPE">
<Default>ServerApplication</Default>
</Parameter>

<Index name="NameVersion">
<Properties>Name,VersionString</Properties>
<Unique>1</Unique>
</Index>

<Index name="NameBitmap">
<Type>bitmap</Type>
<Properties>Name</Properties>
</Index>

<Index name="SemVer">
<Properties>Name,Version</Properties>
<TypeClass>%ZPM.PackageManager.Server.SemVerIndex</TypeClass>
</Index>

<Index name="ManifestSearchIndex">
<Data>Manifest(ELEMENTS)</Data>
<Properties>Manifest(KEYS)</Properties>
</Index>

<Property name="SemVer">
<Description>
Property associated with the index to allow quick $Query'ing over SemVer order based on ID</Description>
<Type>%String</Type>
<SqlComputeCode>set {*} = ##class(%ZPM.PackageManager.Server.Module).SemVerNode({Name},{Version})</SqlComputeCode>
<SqlComputed>1</SqlComputed>
<SqlComputeOnChange>%%INSERT,%%UPDATE</SqlComputeOnChange>
<Parameter name="MAXLEN" value="512"/>
</Property>

<Method name="%OnBeforeBuildIndices">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&indexlist:%String(MAXLEN="")=""]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If (indexlist [ "SemVer") || (indexlist = "") {
		// Force recomputation of SemVer property if index needs to be rebuilt (i.e., because structure has changed)
		Set tRes = ##class(%SQL.Statement).%ExecDirect(,"update %ZPM_PackageManager_Server.Application set SemVer = ''")
		If tRes.%SQLCODE < 0 {
			Quit $$$ERROR($$$SQLCode,tRes.%SQLCODE,tRes.%Message)
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="OrderedMatches">
<Type>%Query</Type>
<FormalSpec>pName:%String="",pVersionExpression:%String="*",pParameters:%String=""</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Name:%String,VersionString:%String"/>
</Query>

<Method name="OrderedMatchesExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,pName:%String="",pVersionExpression:%String="*",pParameters:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ##class(%ZPM.PackageManager.Server.SemVerFind).MatchesExecute(.qHandle,$classname(),"SemVer",..SemVerIndexLocation(),pName,pVersionExpression,pParameters)
]]></Implementation>
</Method>

<Method name="OrderedMatchesClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>OrderedMatchesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ##class(%ZPM.PackageManager.Server.SemVerFind).MatchesClose(.qHandle)
]]></Implementation>
</Method>

<Method name="OrderedMatchesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>OrderedMatchesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ##class(%ZPM.PackageManager.Server.SemVerFind).MatchesFetch(.qHandle,.tRow,.AtEnd)
	If $$$ISERR(tSC) {
		Quit tSC
	}
	If 'AtEnd {
		Set Row = $ListBuild(..NameGetStored($ListGet(tRow)),..VersionStringGetStored($ListGet(tRow)))
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^%ZPM.Server.ApplicationD</DataLocation>
<DefaultData>ApplicationDefaultData</DefaultData>
<IdLocation>^%ZPM.Server.ApplicationD</IdLocation>
<IndexLocation>^%ZPM.Server.ApplicationI</IndexLocation>
<StreamLocation>^%ZPM.Server.ApplicationS</StreamLocation>
<Data name="ApplicationDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>Version</Value>
</Value>
<Value name="4">
<Value>IsLatest</Value>
</Value>
<Value name="5">
<Value>Payload</Value>
</Value>
<Value name="6">
<Value>VersionString</Value>
</Value>
<Value name="7">
<Value>Manifest</Value>
</Value>
<Value name="8">
<Value>SemVer</Value>
</Value>
<Value name="9">
<Value>Installer</Value>
</Value>
<Value name="10">
<Value>Description</Value>
</Value>
<Value name="11">
<Value>Repo</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Server.Module">
<SqlTableName>_MODULE</SqlTableName>
<Super>%Persistent,%ZPM.PackageManager.Core.Module</Super>
<TimeCreated>65797,80972.596894</TimeCreated>

<Parameter name="XMLTYPE">
<Default>ServerModule</Default>
</Parameter>

<Index name="NameVersion">
<Properties>Name,VersionString</Properties>
<Unique>1</Unique>
</Index>

<Index name="NameBitmap">
<Type>bitmap</Type>
<Properties>Name</Properties>
</Index>

<Index name="SemVer">
<Properties>Name,Version</Properties>
<TypeClass>%ZPM.PackageManager.Server.SemVerIndex</TypeClass>
</Index>

<Index name="ManifestSearchIndex">
<Data>Manifest(ELEMENTS)</Data>
<Properties>Manifest(KEYS)</Properties>
</Index>

<Property name="SemVer">
<Description>
Property associated with the index to allow quick $Query'ing over SemVer order based on ID</Description>
<Type>%String</Type>
<SqlComputeCode>set {*} = ##class(%ZPM.PackageManager.Server.Module).SemVerNode({Name},{Version})</SqlComputeCode>
<SqlComputed>1</SqlComputed>
<SqlComputeOnChange>%%INSERT,%%UPDATE</SqlComputeOnChange>
<Parameter name="MAXLEN" value="512"/>
</Property>

<Method name="%OnBeforeBuildIndices">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&indexlist:%String(MAXLEN="")=""]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	If (indexlist [ "SemVer") || (indexlist = "") {
		// Force recomputation of SemVer property if index needs to be rebuilt (i.e., because structure has changed)
		Set tRes = ##class(%SQL.Statement).%ExecDirect(,"update %ZPM_PackageManager_Server._MODULE set SemVer = ''")
		If tRes.%SQLCODE < 0 {
			Quit $$$ERROR($$$SQLCode,tRes.%SQLCODE,tRes.%Message)
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Query name="OrderedMatches">
<Type>%Query</Type>
<FormalSpec>pName:%String="",pVersionExpression:%String="*",pParameters:%String=""</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="ROWSPEC" value="Name:%String,VersionString:%String"/>
</Query>

<Method name="OrderedMatchesExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,pName:%String="",pVersionExpression:%String="*",pParameters:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ##class(%ZPM.PackageManager.Server.SemVerFind).MatchesExecute(.qHandle,$classname(),"SemVer",..SemVerIndexLocation(),pName,pVersionExpression,pParameters)
]]></Implementation>
</Method>

<Method name="OrderedMatchesClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>OrderedMatchesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ##class(%ZPM.PackageManager.Server.SemVerFind).MatchesClose(.qHandle)
]]></Implementation>
</Method>

<Method name="OrderedMatchesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>OrderedMatchesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ##class(%ZPM.PackageManager.Server.SemVerFind).MatchesFetch(.qHandle,.tRow,.AtEnd)
	If $$$ISERR(tSC) {
		Quit tSC
	}
	If 'AtEnd {
		Set Row = $ListBuild(..NameGetStored($ListGet(tRow)),..VersionStringGetStored($ListGet(tRow)))
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^ZPM.Server.ModuleD</DataLocation>
<DefaultData>PackageDefaultData</DefaultData>
<IdLocation>^ZPM.Server.ModuleD</IdLocation>
<IndexLocation>^ZPM.Server.ModuleI</IndexLocation>
<StreamLocation>^ZPM.Server.ModuleS</StreamLocation>
<Data name="PackageDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>Version</Value>
</Value>
<Value name="4">
<Value>IsLatest</Value>
</Value>
<Value name="5">
<Value>Payload</Value>
</Value>
<Value name="6">
<Value>VersionString</Value>
</Value>
<Value name="7">
<Value>Manifest</Value>
</Value>
<Value name="8">
<Value>SemVer</Value>
</Value>
<Value name="9">
<Value>Installer</Value>
</Value>
<Value name="10">
<Value>Description</Value>
</Value>
<Value name="11">
<Value>Repo</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZPM.PackageManager.Server.PackageService">
<ProcedureBlock>1</ProcedureBlock>
<Super>%ZPM.PackageManager.Server.AbstractService,%ZPM.PackageManager.Core.IPackageService,%ZPM.PackageManager.Core.ModuleInfo.QueryUtils</Super>
<TimeCreated>65797,80972.588496</TimeCreated>

<Parameter name="SERVICENAME">
<Description>
Name of the WebService.</Description>
<Default>PackageManagerService</Default>
</Parameter>

<Parameter name="NAMESPACE">
<Description>
SOAP Namespace for the WebService</Description>
<Default>http://www.intersystems.com/PackageManager</Default>
</Parameter>

<Parameter name="USECLASSNAMESPACES">
<Description>
Namespaces of referenced classes will be used in the WSDL.</Description>
<Default>1</Default>
</Parameter>

<Method name="ListApplications">
<FormalSpec>pSearchCriteria:%ZPM.PackageManager.Core.SearchCriteria</FormalSpec>
<ReturnType>%Library.ListOfObjects</ReturnType>
<WebMethod>1</WebMethod>
<ReturnTypeParams>ELEMENTTYPE="%ZPM.PackageManager.Core.ResolvedModuleReference"</ReturnTypeParams>
<Implementation><![CDATA[
	Set tList = ##class(%Library.ListOfObjects).%New()
	Set tQuery = "select m.Name,m.VersionString from %ZPM_PackageManager_Server.Application_OrderedMatches(?,?,?) m "_
		"join %ZPM_PackageManager_Server.Application sm on sm.Name = m.Name and sm.VersionString = m.VersionString"
	Quit ..moduleSqlToList(tQuery,.pSearchCriteria)
]]></Implementation>
</Method>

<Method name="ListModules">
<FormalSpec>pSearchCriteria:%ZPM.PackageManager.Core.SearchCriteria</FormalSpec>
<ReturnType>%Library.ListOfObjects</ReturnType>
<WebMethod>1</WebMethod>
<ReturnTypeParams>ELEMENTTYPE="%ZPM.PackageManager.Core.ResolvedModuleReference"</ReturnTypeParams>
<Implementation><![CDATA[
	Set tList = ##class(%Library.ListOfObjects).%New()
	Set tQuery = "select m.Name,m.VersionString from %ZPM_PackageManager_Server.Module_OrderedMatches(?,?,?) m "_
		"join %ZPM_PackageManager_Server._Module sm on sm.Name = m.Name and sm.VersionString = m.VersionString"
	Quit ..moduleSqlToList(tQuery,.pSearchCriteria)
]]></Implementation>
</Method>

<Method name="HasApplication">
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<WebMethod>1</WebMethod>
<Implementation><![CDATA[
	Set tName = pModuleReference.Name
	Set tVersion = pModuleReference.VersionString
	Quit ##class(%ZPM.PackageManager.Server.Application).NameVersionExists(tName,tVersion)
]]></Implementation>
</Method>

<Method name="HasModule">
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<WebMethod>1</WebMethod>
<Implementation><![CDATA[
	Set tName = pModuleReference.Name
	Set tVersion = pModuleReference.VersionString
	Quit ##class(%ZPM.PackageManager.Server.Module).NameVersionExists(tName,tVersion)
]]></Implementation>
</Method>

<Method name="GetApplicationManifest">
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<WebMethod>1</WebMethod>
<Implementation><![CDATA[
	Set tName = pModuleReference.Name
	Set tVersion = pModuleReference.VersionString
	Set tApplication = ##class(%ZPM.PackageManager.Server.Application).NameVersionOpen(tName,tVersion,,.tStatus)
	$$$ThrowOnError(tStatus)
	Quit tApplication.Manifest
]]></Implementation>
</Method>

<Method name="GetModuleManifest">
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Stream.GlobalCharacter</ReturnType>
<WebMethod>1</WebMethod>
<Implementation><![CDATA[
	Set tName = pModuleReference.Name
	Set tVersion = pModuleReference.VersionString
	Set tPackage = ##class(%ZPM.PackageManager.Server.Module).NameVersionOpen(tName,tVersion,,.tStatus)
	$$$ThrowOnError(tStatus)
	Quit tPackage.Manifest
]]></Implementation>
</Method>

<Method name="GetApplication">
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Stream.GlobalBinary</ReturnType>
<WebMethod>1</WebMethod>
<Implementation><![CDATA[
	Set tName = pModuleReference.Name
	Set tVersion = pModuleReference.VersionString
	Set tApplication = ##class(%ZPM.PackageManager.Server.Application).NameVersionOpen(tName,tVersion,,.tStatus)
	$$$ThrowOnError(tStatus)
	Quit tApplication.Payload
]]></Implementation>
</Method>

<Method name="GetModule">
<FormalSpec>pModuleReference:%ZPM.PackageManager.Core.ResolvedModuleReference</FormalSpec>
<ReturnType>%Stream.GlobalBinary</ReturnType>
<WebMethod>1</WebMethod>
<Implementation><![CDATA[
	Set tName = pModuleReference.Name
	Set tVersion = pModuleReference.VersionString
	Set tPackage = ##class(%ZPM.PackageManager.Server.Module).NameVersionOpen(tName,tVersion,,.tStatus)
	$$$ThrowOnError(tStatus)
	Quit tPackage.Payload
]]></Implementation>
</Method>

<Method name="Supports">
<Description>
Returns 1 if the service supports a particular method.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMethod:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Only supports retrieval of module artifacts as single-file archives.
	Quit '(pMethod [ "Directory")
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Server.PublishService">
<ProcedureBlock>1</ProcedureBlock>
<Super>%ZPM.PackageManager.Server.AbstractService,%ZPM.PackageManager.Core.IPublishService</Super>
<TimeCreated>65797,80972.572876</TimeCreated>

<Parameter name="SERVICENAME">
<Description>
Name of the WebService.</Description>
<Default>PackagePublishService</Default>
</Parameter>

<Parameter name="NAMESPACE">
<Description>
SOAP Namespace for the WebService</Description>
<Default>http://www.intersystems.com/PackageManager</Default>
</Parameter>

<Parameter name="USECLASSNAMESPACES">
<Description>
Namespaces of referenced classes will be used in the WSDL.</Description>
<Default>1</Default>
</Parameter>

<Method name="PublishModule">
<FormalSpec>pModule:%ZPM.PackageManager.Core.Module</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<WebMethod>1</WebMethod>
<Implementation><![CDATA[
	If (pModule.Version.Build = "snapshot") {
		// Allow update of snapshot versions with the same full version string.
		Set tModule = ##class(%ZPM.PackageManager.Server.Module).NameVersionOpen(pModule.Name,pModule.VersionString)
	}
	If '$IsObject($Get(tModule)) {
		Set tModule = ##class(%ZPM.PackageManager.Server.Module).%New()
	}
	Set tModule.Name = pModule.Name
	Set tModule.VersionString = pModule.VersionString
	Do tModule.Manifest.CopyFrom(pModule.Manifest)
	Do tModule.Installer.CopyFrom(pModule.Installer)
	Do tModule.Payload.CopyFrom(pModule.Payload)
	$$$ThrowOnError(tModule.%Save())
	Quit 1
]]></Implementation>
</Method>

<Method name="PublishApplication">
<FormalSpec>pApplication:%ZPM.PackageManager.Core.Application</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<WebMethod>1</WebMethod>
<Implementation><![CDATA[
	If (pApplication.Version.Build = "snapshot") {
		// Allow update of snapshot versions with the same full version string.
		Set tApplication = ##class(%ZPM.PackageManager.Server.Application).NameVersionOpen(pApplication.Name,pApplication.VersionString)
	}
	If '$IsObject($Get(tApplication)) {
		Set tApplication = ##class(%ZPM.PackageManager.Server.Application).%New()
	}
	Set tApplication.Name = pApplication.Name
	Set tApplication.VersionString = pApplication.VersionString
	Do tApplication.Manifest.CopyFrom(pApplication.Manifest)
	Do tApplication.Payload.CopyFrom(pApplication.Payload)
	$$$ThrowOnError(tApplication.%Save())
	Quit 1
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Server.SemVerFind">
<Description><![CDATA[
Class to enable use of <class>%ZPM.PackageManager.Server.SemVerIndex</class> with %FIND.
For detailed documentation, see <class>%ZPM.PackageManager.Server.SemVerIndex</class>.
TODO: emulate bitmap index by overriding GetChunk/NextChunk/PreviousChunk?]]></Description>
<Super>%SQL.AbstractFind</Super>
<TimeCreated>65797,80972.628035</TimeCreated>

<Property name="BaseIndexGlobal">
<Type>%String</Type>
<Private>1</Private>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Class">
<Type>%String</Type>
<Private>1</Private>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="IndexName">
<Type>%String</Type>
<Private>1</Private>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Offset">
<Type>%String</Type>
<Private>1</Private>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Name">
<Type>%String</Type>
<Private>1</Private>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="Parameters">
<Type>%String</Type>
<Private>1</Private>
<ReadOnly>1</ReadOnly>
</Property>

<Property name="VersionExpression">
<Type>%ZPM.PackageManager.Core.SemanticVersionExpression</Type>
<Private>1</Private>
</Property>

<Property name="IncludePrerelease">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Private>1</Private>
</Property>

<Property name="IncludeSnapshot">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<Description><![CDATA[
<p>
This callback method is invoked by the <METHOD>%New</METHOD> method to 
provide notification that a new instance of an object is being created. 
</p>
<p>
If this method returns an error then the object will not be created. 
</p>
<p>
It is passed the arguments provided in the %New call. 
When customizing this method, override the arguments with whatever variables and types you expect to receive from %New(). 
For example, if you're going to call %New, passing 2 arguments, %OnNew's signature could be: 
<pre>
Method %OnNew(dob as %Date = "", name as %Name = "") as %Status 
</pre>
If instead of returning a %Status code this method returns an oref and this oref is a subclass of the current 
class, then this oref will be the one returned to the caller of the %New method. 
</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pClass:%String,pIndexName:%String,pBaseIndexGlobal:%String,pName:%String,pVersionExpression:%String="",pParameters:%String="",*pSC</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set pSC = $$$OK
	Try {
		Set i%Class = pClass
		Set i%IndexName = pIndexName
		Set i%BaseIndexGlobal = pBaseIndexGlobal
		Set i%Offset = $QLENGTH(pBaseIndexGlobal) // Number of index subscripts before the interesting stuff.
		Set i%Name = pName
		Set i%Parameters = $ZConvert(pParameters,"L")
		Set ..IncludePrerelease = (..Parameters [ "prerelease")
		Set ..IncludeSnapshot = (..Parameters [ "snapshot")
		If (pVersionExpression = "") {
			Set pVersionExpression = "*"
		}
		Set pSC = ##class(%ZPM.PackageManager.Core.SemanticVersionExpression).FromString(pVersionExpression,.tExpression)
		Set ..VersionExpression = tExpression
		If $$$ISERR(pSC) {
			Quit
		}
		Set pSC = ##super()
	} Catch e {
		Set pSC = e.AsStatus()
	}
	Quit pSC
]]></Implementation>
</Method>

<Method name="ContainsItem">
<Description><![CDATA[
At minimum, <METHOD>ContainsItem()</METHOD> must always be supported.
It returns 1 iff the given pItem is in the set S.]]></Description>
<FormalSpec>pItem:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Sample value of tRef:
	// ^ZPM.Client.FSCacheI("SemVer","ZPMMOD.VirusScanner.Common",0,1,0,1,"snapshot")
	// NOTE: pItem is a row ID.
	Set tRef = $ClassMethod(i%Class,i%IndexName_"GetStored",pItem)
	If (tRef = "") { Quit 0 }
	
	Set tLength = $QLength(tRef)
	Set tName = $QSubscript(tRef,i%Offset+1)
	If (tName '= ..Name) && (..Name '= "") {
		Quit 0
	}
	
	Set tIsPrerelease = '$QSubscript(tRef,i%Offset+5)
	
	If ..IncludePrerelease < tIsPrerelease {
		Quit 0
	}
	
	Set tIsSnapshot = ($ZConvert($QSubscript(tRef,tLength),"L") = "snapshot") &&
		('tIsPrerelease || ($QSubscript(tRef,tLength-1) = $c(0)))
	
	If ..IncludeSnapshot < tIsSnapshot {
		Quit 0
	}
	
	// The data of the index will be the semantic version.
	Set tVersion = ##class(%ZPM.PackageManager.Core.SemanticVersion).FromListBuild($Get(@tRef@(pItem)))
	Quit tVersion.Satisfies(..VersionExpression)
]]></Implementation>
</Method>

<Method name="NextItem">
<Description>
Supports %INSUB (eventually?) - for now called from class query.</Description>
<FormalSpec>pItem:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tNextItem = ""
	If (pItem '= "") {
		// NOTE: pItem is a row ID.
		Set tRef = $ClassMethod(i%Class,i%IndexName_"GetStored",pItem)
		Set tNextRef = $Query(@tRef@(pItem))
	} Else {
		Set tNextRef = $Query(@i%BaseIndexGlobal@(i%Name))
	}
	For {
		// Sample value of tNextRef:
		// ^ZPM.Client.FSCacheI("SemVer","ZPMMOD.VirusScanner.Common",0,1,0,1,"snapshot")
		If (tNextRef = "") {
			Quit
		}
		
		// Ensure we're still looking at the correct base global.
		If ($QSubscript(tNextRef,i%Offset) '= $QSubscript(i%BaseIndexGlobal,i%Offset)) {
			Quit
		}
		
		// Ensure we're still looking at a version for the correct name.
		Set tName = $QSubscript(tNextRef,i%Offset+1)
		If (tName '= i%Name) && (i%Name '= "") {
			Quit
		}
		
		// TODO: Clever skipping of chunks based on expression/ranges and prerelease/snapshot flags.
		Set tID = $QSubscript(tNextRef,$QLENGTH(tNextRef))
		If ..ContainsItem(tID) {
			Set tNextItem = tID
			Quit
		}
		Set tNextRef = $Query(@tNextRef)
	}
	Quit tNextItem
]]></Implementation>
</Method>

<Method name="PreviousItem">
<Description>
Supports %INSUB (eventually?) - for now called from class query.</Description>
<FormalSpec>pItem:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tPreviousItem = ""
	If (pItem '= "") {
		// NOTE: pItem is a row ID.
		Set tRef = $ClassMethod(i%Class,i%IndexName_"GetStored",pItem)
		Set tPreviousRef = $Query(@tRef@(pItem),-1)
	} Else {
		Set tNextName = $Case(i%Name,"":"",:$Order(@i%BaseIndexGlobal@(i%Name)))
		Set tPreviousRef = $Query(@i%BaseIndexGlobal@(tNextName),-1)
	}
	For {
		// Sample value of tPreviousRef:
		// ^ZPM.Client.FSCacheI("SemVer","ZPMMOD.VirusScanner.Common",0,1,0,1,"snapshot")
		If (tPreviousRef = "") {
			Quit
		}
		
		// Ensure we're still looking at the correct base global.
		If ($QSubscript(tPreviousRef,i%Offset) '= $QSubscript(i%BaseIndexGlobal,i%Offset)) {
			Quit
		}
		
		// Ensure we're still looking at a version for the correct name.
		Set tName = $QSubscript(tPreviousRef,i%Offset+1)
		If (tName '= i%Name) && (i%Name '= "") {
			Quit
		}
		
		// TODO: Clever skipping of chunks based on expression/ranges and prerelease/snapshot flags.
		Set tID = $QSubscript(tPreviousRef,$QLENGTH(tPreviousRef))
		If ..ContainsItem(tID) {
			Set tPreviousItem = tID
			Quit
		}
		Set tPreviousRef = $Query(@tPreviousRef,-1)
	}
	Quit tPreviousItem
]]></Implementation>
</Method>

<Query name="Matches">
<Description>
This is not inherited by classes defining an index of this type.</Description>
<Type>%Query</Type>
<FormalSpec>pClass:%String,pIndexName:%String,pBaseIndexGlobal:%String,pName:%String="",pVersionExpression:%String="*",pParameters:%String=""</FormalSpec>
<SqlProc>1</SqlProc>
<Parameter name="CONTAINID" value="1"/>
<Parameter name="ROWSPEC" value="ID:%String"/>
</Query>

<Method name="MatchesExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,pClass:%String,pIndexName:%String,pBaseIndexGlobal:%String,pName:%String="",pVersionExpression:%String="*",pParameters:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {
		Kill qHandle
		Set qHandle("searcher") = ..%New(pClass,pIndexName,pBaseIndexGlobal,pName,pVersionExpression,pParameters,.tSC)
		$$$ThrowOnError(tSC)
		Set qHandle("item") = qHandle("searcher").PreviousItem("")
	} Catch e {
		Kill qHandle
		Set tSC = e.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="MatchesFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary,&Row:%List,&AtEnd:%Integer=0]]></FormalSpec>
<PlaceAfter>MatchesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If (qHandle("item") = "") {
		Set AtEnd = 1
	} Else {
		Set Row = $ListBuild(qHandle("item"))
		Set qHandle("item") = qHandle("searcher").PreviousItem(qHandle("item"))
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="MatchesClose">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&qHandle:%Binary]]></FormalSpec>
<PlaceAfter>MatchesExecute</PlaceAfter>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Server.SemVerIndex">
<Description><![CDATA[
<p>Functional index on semantic versions. This serves two purposes:
<ol>
<li>Enable searching based on module name and semantic version expression without scanning the whole extent</li>
<li>Simplify ordering based on latest semantic version, properly handling major/minor/patch version numbers and prerelease designations.</li>
</ol>
</p>
<p>To use this index in a class, define an index on a string property (the module name) and a property of type <class>%ZPM.PackageManager.Core.SemanticVersion</class>.
<code>
Index SemVer On (Name, Version) As %ZPM.PackageManager.Server.SemVerIndex;
</code>
You must also define a property with the same name as that index, as follows:
<code>
Property SemVer As %String(MAXLEN = 512) [ SqlComputeCode = {set {*} = ##class(%ZPM.PackageManager.Server.Module).SemVerNode({Name},{Version})}, SqlComputed, SqlComputeOnChange = (%%INSERT, %%UPDATE) ];
</code>
</p>
<p>For an example, see <class>%ZPM.PackageManager.Server.Module</class>.</p>
<p>To use the generated Find method and the %ZPM.PackageManager.Server.SemVerFind (as in the example of %ZPM_PackageManager_Server._Module):
<code>
SELECT Name,VersionString FROM %ZPM_PackageManager_Server._Module WHERE ID %INSET %ZPM_PackageManager_Server.Module_SemVerFind('HS.JSON','0.x','snapshot')
</code>
To facilitate ordering by semantic version, classes that define such indices may also implement class queries to wrap %ZPM.PackageManager.Server.SemVerFind:Matches.
</p>]]></Description>
<ClassType>index</ClassType>
<Super>%Library.FunctionalIndex</Super>
<System>3</System>
<TimeCreated>65797,80972.61004</TimeCreated>

<Method name="Find">
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec>pName:%Binary,pVersionExpression:%String="",pParameters:%String=""</FormalSpec>
<ReturnType>%Library.Binary</ReturnType>
<SqlProc>1</SqlProc>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	// Above, pName needs to be %Binary due to inheritance.
	// Don't generate if %mode is "method" - this prevents generation for %ZPM.PackageManager.Server.SemVerIndex itself.
    If (%mode '= "method") {
        Set tIdxGlobal = ..IndexLocationForCompile(%class,%property)
        $$$GENERATE(" Quit ##class(%ZPM.PackageManager.Server.SemVerFind).%New("_$$$QUOTE(%class)_","_$$$QUOTE(%property)_",$Name("_tIdxGlobal_"),pName,pVersionExpression,pParameters)")
    }
]]></Implementation>
</Method>

<Method name="InsertIndex">
<Description>
This method is invoked when a new instance of a class is inserted into the database.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec>pID:%CacheString,pArg...:%Binary</FormalSpec>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
    If (%mode '= "method") {
        Set tIdxGlobal = ..IndexLocationForCompile(%class,%property)
        $$$GENERATE(" Do .."_%property_"Insert($Name("_tIdxGlobal_"),pID,pArg(1),pArg(2))")
    }
]]></Implementation>
</Method>

<Method name="UpdateIndex">
<Description>
This method is invoked when an existing instance of a class is updated.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec>pID:%CacheString,pArg...:%Binary</FormalSpec>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
    If (%mode '= "method") {
        Set tIdxGlobal = ..IndexLocationForCompile(%class,%property)
        $$$GENERATE(" Do .."_%property_"Delete($Name("_tIdxGlobal_"),pID,pArg(3),pArg(4))")
        $$$GENERATE(" Do .."_%property_"Insert($Name("_tIdxGlobal_"),pID,pArg(1),pArg(2))")
    }
]]></Implementation>
</Method>

<Method name="DeleteIndex">
<Description>
This method is invoked when an existing instance of a class is deleted.</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec>pID:%CacheString,pArg...:%Binary</FormalSpec>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
    If (%mode '= "method") {
        Set tIdxGlobal = ..IndexLocationForCompile(%class,%property)
        $$$GENERATE(" Do .."_%property_"Delete($Name("_tIdxGlobal_"),pID,pArg(1),pArg(2))")
    }
]]></Implementation>
</Method>

<Method name="IndexLocationForCompile">
<ClassMethod>1</ClassMethod>
<FormalSpec>pClassName:%String,pIndexName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    Set tStorage = ##class(%Dictionary.ClassDefinition).%OpenId(pClassName).Storages.GetAt(1).IndexLocation
    Quit $Name(@tStorage@(pIndexName))
]]></Implementation>
</Method>

<Method name="IndexLocation">
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
    If (%mode '= "method") {
        Set tIdxGlobal = ..IndexLocationForCompile(%class,%property)
        $$$GENERATE(" Quit "_$$$QUOTE(tIdxGlobal))
    }
]]></Implementation>
</Method>

<Method name="PurgeIndex">
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
    If (%mode '= "method") {
        Set tIdxGlobal = ..IndexLocationForCompile(%class,%property)
        $$$GENERATE(" Kill " _ tIdxGlobal)
    }
]]></Implementation>
</Method>

<Method name="SortBeginIndex">
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
    If (%mode '= "method") {
        Set tIdxGlobal = ..IndexLocationForCompile(%class,%property)
		// No-op?
        $$$GENERATE(" Quit")
    }
]]></Implementation>
</Method>

<Method name="SortEndIndex">
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
    If (%mode '= "method") {
        Set tIdxGlobal = ..IndexLocationForCompile(%class,%property)
		// No-op?
        $$$GENERATE(" Quit")
    }
]]></Implementation>
</Method>

<Method name="Insert">
<ClassMethod>1</ClassMethod>
<FormalSpec>pGlobal,pID,pName,pVersion</FormalSpec>
<Implementation><![CDATA[
	Set tGlobal = ##class(%ZPM.PackageManager.Server.SemVerIndex).GetIndexGlobalNode(pGlobal, pName, pVersion)
	Set @tGlobal@(pID) = pVersion
]]></Implementation>
</Method>

<Method name="Delete">
<ClassMethod>1</ClassMethod>
<FormalSpec>pGlobal,pID,pName,pVersion</FormalSpec>
<Implementation><![CDATA[
	Set tGlobal = ##class(%ZPM.PackageManager.Server.SemVerIndex).GetIndexGlobalNode(pGlobal, pName, pVersion)
	Kill @tGlobal@(pID)
]]></Implementation>
</Method>

<Method name="GetIndexGlobalNode">
<ClassMethod>1</ClassMethod>
<FormalSpec>pGlobal,pName,pVersion</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set $ListBuild(tMajor,tMinor,tPatch,tPreRelease,tBuild) = pVersion
	If (tBuild = "") && (tPreRelease = "") {
		// No build or prerelease - this is simple.
		Set tGlobal = $Name(@pGlobal@(pName,tMajor,tMinor,tPatch,2))
	} ElseIf (tPreRelease = "") {
		// No prerelease, but has a build - also simple.
		Set tGlobal = $Name(@pGlobal@(pName,tMajor,tMinor,tPatch,1+($ZConvert(tBuild,"L")'="snapshot"),tBuild))
	} Else {
		// Less simple...
		Set tPreRelease = $Get(tPreRelease),tBuild = $Get(tBuild)
		Set tPreReleaseParts = $ListFromString(tPreRelease,".")
		Set tPtr = 0
		Set tGlobal = $Name(@pGlobal@(pName,tMajor,tMinor,tPatch,0))
		While $ListNext(tPreReleaseParts,tPtr,tPart) {
			Set tGlobal = $Name(@tGlobal@(tPart))
		}
		If (tBuild '= "") {
			Set tGlobal = $Name(@tGlobal@(-1,tBuild))
		}
	}
	Quit tGlobal
]]></Implementation>
</Method>

<Method name="Node">
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec>pName,pVersion</FormalSpec>
<ReturnType>%String</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
    If (%mode '= "method") {
        Set tIdxGlobal = ..IndexLocationForCompile(%class,%property)
        $$$GENERATE(" Quit ##class(%ZPM.PackageManager.Server.SemVerIndex).GetIndexGlobalNode($Name("_tIdxGlobal_"),pName,pVersion)")
    }
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager.Server.Utils">
<TimeCreated>65797,80972.623907</TimeCreated>

<Method name="VersionSatisfiesExpression">
<ClassMethod>1</ClassMethod>
<FormalSpec>pVersion:%String,pExpression:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<SqlProc>1</SqlProc>
<Implementation><![CDATA[
	#dim tExpression As %ZPM.PackageManager.Core.SemanticVersionExpression
	#dim tVersion As %ZPM.PackageManager.Core.SemanticVersion
	
	Set tVersion = ##class(%ZPM.PackageManager.Core.SemanticVersion).FromString(pVersion)
	$$$ThrowOnError(##class(%ZPM.PackageManager.Core.SemanticVersionExpression).FromString(pExpression,.tExpression))
	Quit tVersion.Satisfies(tExpression)
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.PackageManager">
<IncludeCode>%syGluedef,%sySecurity,%syPrompt,%ZPM.PackageManager.Common</IncludeCode>
<Super>%ZPM.PackageManager.Developer.CLI</Super>
<TimeCreated>65797,80971.431043</TimeCreated>

<Parameter name="DOMAIN">
<Default>ZPM</Default>
</Parameter>

<Parameter name="STANDARDPHASES">
<Expression>$Listbuild("reload","compile","test","package","verify","publish")</Expression>
</Parameter>

<XData name="Commands">
<Description>
Description of commands to use for this CLI</Description>
<XMLNamespace>http://www.intersystems.com/PackageManager/CLI</XMLNamespace>
<Data><![CDATA[
<?xml version="1.0"?>
<commands>
<command name="help" aliases="?">
<description>Displays help information for the shell or a particular command</description>
<modifier name="verbose" aliases="v" description="Show full detail" />
<modifier name="markdown" aliases="m" description="Print detail in markdown format (for easy transfer to external documentation)" />
<parameter name="command" description="Command for which help information should be displayed" />
</command>

<command name="quit" aliases="q,exit">
<description>Exits the package manager shell</description>
</command>

<command name="module-action" default="true" dataPrefix="D" trailingModifiers="true">
<description>
Performs operations on modules - compiling, running tests, packaging/registering, etc.
You can use this by starting a command with the module name.
Note that flags appear *after* all actions.

The standard lifecycle phases are:
* clean: removes all dependencies that are not required by other installed modules and their resources. Dependencies required by other modules will also be removed if the -DClean.Force=1 flag is specified.
* reload: pulls module source code into the namespace from disk. Does not compile.
* validate: ensures that module API section is up to date, that module resource processor attributes are valid, and that the resources exported to the filesystem (and possible to source control) are consistent with what is in the database.
* compile: compiles all resources within the module.
* activate: performs post-compilation installation/configuration steps.
* test: runs any unit tests associated with the module, in the current namespace.
* package: exports the module's resources and bundles them into a module artifact (.tgz file).
* verify: installs that artifact in a separate namespace, then runs integration tests (if any).
* register: saves that artifact into the current namespace's module cache. This is accessible to other instances configured to look at the current namespace as a module repository.
* publish: saves that artifact to the repository for which deployment is enabled. Currently, there may only be one of these per namespace.
</description>
<example description="Compiles the module named &quot;MyModuleName&quot;">module-action MyModuleName compile</example>
<example description="Performs multiple actions on the module named &quot;MyModuleName&quot;; &quot;clean&quot; deletes all of its dependenices, and &quot;install&quot; will then re-download them, package the module, and register it in the current namespace's module cache.">MyModuleName clean register</example>
<example description="Compiles the module named MyUIModule with verbose output and pParams(&quot;UIFW&quot;,&quot;force&quot;) (passed to all lifecycle phases) set to 42.">MyUIModule compile -v -DUIFW.force=42</example>
<parameter name="module" required="true" description="Name of module on which to perform lifecycle actions" />
<parameter name="actions" required="true" description="Space-delimited list of module lifecycle phases to run" trailing="true" />
<modifier name="only" aliases="o" description="Only runs the specified phase(s), rather than also running predecessors." />
<modifier name="dev" dataAlias="DeveloperMode" dataValue="1" description="Sets the DeveloperMode flag for the module's lifecycle. Key consequences of this are that ^Sources will be configured for resources in the module, and installer methods will be called with the dev mode flag set." />
<modifier name="quiet" aliases="q" dataAlias="Verbose" dataValue="0" description="Produces minimal output from the command." />
<modifier name="verbose" aliases="v" dataAlias="Verbose" dataValue="1" description="Produces verbose output from the command." />
</command>

<command name="reload">
<description>
This command is an alias for `module-action module-name reload`
</description>
<parameter name="module" required="true" description="Name of module on which to perform reload action" />
<modifier name="only" aliases="o" description="Only runs the specified phase (reload), rather than also running predecessors." />
<modifier name="dev" dataAlias="DeveloperMode" dataValue="1" description="Sets the DeveloperMode flag for the module's lifecycle. Key consequences of this are that ^Sources will be configured for resources in the module, and installer methods will be called with the dev mode flag set." />
<modifier name="quiet" aliases="q" dataAlias="Verbose" dataValue="0" description="Produces minimal output from the command." />
<modifier name="verbose" aliases="v" dataAlias="Verbose" dataValue="1" description="Produces verbose output from the command." />
</command>

<command name="compile">
<description>
This command is an alias for `module-action module-name compile`
</description>
<parameter name="module" required="true" description="Name of module on which to perform compile action" />
<modifier name="only" aliases="o" description="Only runs the specified phase (compile), rather than also running predecessors." />
<modifier name="dev" dataAlias="DeveloperMode" dataValue="1" description="Sets the DeveloperMode flag for the module's lifecycle. Key consequences of this are that ^Sources will be configured for resources in the module, and installer methods will be called with the dev mode flag set." />
<modifier name="quiet" aliases="q" dataAlias="Verbose" dataValue="0" description="Produces minimal output from the command." />
<modifier name="verbose" aliases="v" dataAlias="Verbose" dataValue="1" description="Produces verbose output from the command." />
</command>

<command name="test">
<description>
This command is an alias for `module-action module-name test`
</description>
<parameter name="module" required="true" description="Name of module on which to perform test action" />
<modifier name="only" aliases="o" description="Only runs the specified phase (reload), rather than also running predecessors." />
<modifier name="dev" dataAlias="DeveloperMode" dataValue="1" description="Sets the DeveloperMode flag for the module's lifecycle. Key consequences of this are that ^Sources will be configured for resources in the module, and installer methods will be called with the dev mode flag set." />
<modifier name="quiet" aliases="q" dataAlias="Verbose" dataValue="0" description="Produces minimal output from the command." />
<modifier name="verbose" aliases="v" dataAlias="Verbose" dataValue="1" description="Produces verbose output from the command." />
</command>

<command name="package">
<description>
This command is an alias for `module-action module-name package`
</description>
<parameter name="module" required="true" description="Name of module on which to perform package actions" />
<modifier name="only" aliases="o" description="Only runs the specified phase (package), rather than also running predecessors." />
<modifier name="dev" dataAlias="DeveloperMode" dataValue="1" description="Sets the DeveloperMode flag for the module's lifecycle. Key consequences of this are that ^Sources will be configured for resources in the module, and installer methods will be called with the dev mode flag set." />
<modifier name="quiet" aliases="q" dataAlias="Verbose" dataValue="0" description="Produces minimal output from the command." />
<modifier name="verbose" aliases="v" dataAlias="Verbose" dataValue="1" description="Produces verbose output from the command." />
<modifier name="path" aliases="p" dataAlias="Path" value="true" description="Use specified path to export package." />
</command>

<command name="verify">
<description>
This command is an alias for `module-action module-name verify`
</description>
<parameter name="module" required="true" description="Name of module on which to perform verify action" />
<modifier name="only" aliases="o" description="Only runs the specified phase (verify), rather than also running predecessors." />
<modifier name="dev" dataAlias="DeveloperMode" dataValue="1" description="Sets the DeveloperMode flag for the module's lifecycle. Key consequences of this are that ^Sources will be configured for resources in the module, and installer methods will be called with the dev mode flag set." />
<modifier name="quiet" aliases="q" dataAlias="Verbose" dataValue="0" description="Produces minimal output from the command." />
<modifier name="verbose" aliases="v" dataAlias="Verbose" dataValue="1" description="Produces verbose output from the command." />
</command>

<command name="publish">
<description>
This command is an alias for `module-action module-name publish`
</description>
<parameter name="module" required="true" description="Name of module on which to perform publish actions" />
<modifier name="only" aliases="o" description="Only runs the specified phase (publish), rather than also running predecessors." />
<modifier name="dev" dataAlias="DeveloperMode" dataValue="1" description="Sets the DeveloperMode flag for the module's lifecycle. Key consequences of this are that ^Sources will be configured for resources in the module, and installer methods will be called with the dev mode flag set." />
<modifier name="quiet" aliases="q" dataAlias="Verbose" dataValue="0" description="Produces minimal output from the command." />
<modifier name="verbose" aliases="v" dataAlias="Verbose" dataValue="1" description="Produces verbose output from the command." />
</command>

<command name="config">
<description>Update ZPM settings. Setting is a key-value pair.</description>
<example description="Disable collecting analytics data">config set analytics 0</example>
<example description="Enable collecting analytics data">config set analytics 1</example>
<example description="list all settings">config list</example>
<example description="get value for analytics key">config get analytics</example>
<example description="reset to default value for analytics key">config delete analytics</example>
<parameter name="action" required="true" description="One of settings actions: list, get, set, delete" />
<parameter name="key" required="false" description="Setting key" />
<parameter name="value" required="false" description="Setting value" />
</command>


<command name="repo" aliases="repository" dataPrefix="D">
<description>Configures the current namespace to search for modules on a remote server or on the local filesystem.</description>
<example description="List all repositories">
repo -list
</example>
<example description="Delete all repositories">
repo -delete-all
</example>
<example description="Create a repository pointing to the filesystem with name LocalFiles, accepting snapshots, looking for files named module.xml up to 2 directories deep in C:\MyWorkspace\RootModuleDir\">
repo -name LocalFiles -snapshots 1 -fs -depth 2 -path C:\MyWorkspace\RootModuleDir\
</example>
<example description="Delete the repository named &quot;LocalFiles&quot;">
repo -n LocalFiles -delete
</example>
<example description="Lists all modules (and versions) available from the repository named &quot;AppModules&quot;">
repo -n AppModules -list-modules
</example>

<example description="Switch to test registery">
repo -r -n registry -url https://test.pm.community.intersystems.com/registry/ -user "test" -pass "test"
</example>

<example description="Reset to default registry (pm.community.intersystems.com) and it is equivalent to a command">
repo -r -n registry -reset-defaults
</example>
<example description=" ">
repo -r -n registry -url https://pm.community.intersystems.com/ -user "" -pass ""
</example>

<!-- Universal Actions -->
<modifier name="delete-all" description="Deletes all repositories (possibly subject to a type filter: -f, -r, -l)" />
<modifier name="list" description="Lists all repositories (possibly subject to a type filter: -f, -r, -l)" />
<modifier name="list-modules" description="List modules available in the specified repository (-n\[ame]), or in all configured repositories if no repository was specified." />

<!-- General/shared modifiers -->
<modifier name="name" aliases="n" value="true" description="Namespace-unique name for the module" />
<modifier name="delete" description="Deletes the current namespace's reference to the named repository" />
<modifier name="publish" value="true" valueList="0,1" description="When configuring a remote repository, specifies that publishing of packages to the repository is allowed. When configuring the current namespace with -enable, specifies that publishing is also enabled. "/>

<!-- General properties -->
<modifier name="snapshots" aliases="s" value="true" valueList="0,1" description="For any repository, specifies that it should be used to look for snapshot builds (i.e., those with a semantic version ending in '+snapshot', indicating a 'latest' build of a particular version)." />
<modifier name="prereleases" aliases="pre" value="true" valueList="0,1" description="For any repository, specifies that it should be used to look for prerelease software" />

<!-- Repository types  -->
<modifier name="filesystem" aliases="f,fs" description="Create/update a filesystem repository" />
<modifier name="remote" aliases="r" description="Create/update a remote server repository" />
<modifier name="local" aliases="l" description="Create/update the local namespace cache" />
<modifier name="type" value="true" aliases="t" description="Subclass of %ZPM.PackageManager.Client.ServerDefinition to create/modify/delete or implementation of %ZPM.PackageManager.Core.IPackageService or %ZPM.PackageManager.Core.IPublishService to enable/disable" />

<!-- File repository modifiers -->
<modifier name="depth" aliases="d" value="true" description="For filesystem repositories, specifies the depth (number of folders underneath the root) to search for files named module.xml" />
<modifier name="path" aliases="p" value="true" description="For filesystem repositories, specifies the path to the root directory" />

<!-- Remote repository modifiers -->
<modifier name="url" value="true" description="For remote repositories, specifies the URL for package retrieval web services." />
<modifier name="username" aliases="user" value="true" description="For remote repositories, specifies the username to use when connecting." />
<modifier name="password" aliases="pass" value="true" description="For remote repositories, specifies the password to use when connecting." />
<modifier name="reset-defaults" value="false" description="Reset to default repository" />


<!-- Modifiers specific to -enable -->
<modifier name="app" value="true" description="When enabling a namespace to serve as a remote repository, specifies the web application to allow web service access." />
</command>

<command name="load" dataPrefix="D">
<description>Loads a module from the specified directory or archive into the current namespace. Dependencies are also loaded automatically, provided that they can be found in repositories configured with the 'repo' command.</description>
<example description="Loads the module described in C:\module\root\path\module.xml">
load C:\module\root\path\
load C:\module\root\path\module-0.0.1.tgz
</example>
<example description="Loads the module described in C:\module\root\path\module.xml in developer mode and with verbose output.">
load -dev -verbose C:\module\root\path\
load -dev -verbose C:\module\root\path\module-0.0.1.tgz
</example>
<modifier name="dev" dataAlias="DeveloperMode" dataValue="1" description="Sets the DeveloperMode flag for the module's lifecycle. Key consequences of this are that ^Sources will be configured for resources in the module, and installer methods will be called with the dev mode flag set." />
<modifier name="quiet" aliases="q" dataAlias="Verbose" dataValue="0" description="Produces minimal output from the command." />
<modifier name="verbose" aliases="v" dataAlias="Verbose" dataValue="1" description="Produces verbose output from the command." />
<parameter name="path" required="true" description="Directory on the local filesystem, containing a file named module.xml" />
</command>

<command name="install" dataPrefix="D">
<description>Installs a module available in a configured repository</description>
<example description="Installs the most recent 1.x version of HS.JSON available in any configured repository in the current namespace.">install HS.JSON 1.x</example>
<parameter name="module" description="Name of module to install" />
<parameter name="version" description="Version (or version expression) of module to install; defaults to the latest available if unspecified." />
<modifier name="dev" dataAlias="DeveloperMode" dataValue="1" description="Sets the DeveloperMode flag for the module's lifecycle. Key consequences of this are that ^Sources will be configured for resources in the module, and installer methods will be called with the dev mode flag set." />
<modifier name="quiet" aliases="q" dataAlias="Verbose" dataValue="0" description="Produces minimal output from the command." />
<modifier name="verbose" aliases="v" dataAlias="Verbose" dataValue="1" description="Produces verbose output from the command." />
<modifier name="keywords" aliases="k" value="true" description="Searches for modules matching some set of keywords." />
</command>

<command name="uninstall" dataPrefix="D">
<description>Uninstalls a module currently installed locally. This will be prevented if other modules depend on the named module, unless the -force flag is specified.</description>
<example description="Uninstalls HS.JSON from the current namespace.">uninstall HS.JSON</example>
<modifier name="force" aliases="f" description="If specified, the module will be uninstalled even if other modules depend on it." />
<modifier name="recurse" aliases="r" description="Also recursively uninstall dependencies. By default, will not uninstall dependencies that are also required by other installed modules; the -force flag overrides this." />
<modifier name="quiet" aliases="q" dataAlias="Verbose" dataValue="0" description="Produces minimal output from the command." />
<modifier name="verbose" aliases="v" dataAlias="Verbose" dataValue="1" description="Produces verbose output from the command." />
<modifier name="purge" dataAlias="Purge" dataValue="1" description="Purge data from tables during uninstall." />
<parameter name="module" required="true" description="Name of module to uninstall" />
</command>

<command name="orphans">
<description>Lists resources in the current namespace's default code database that are not part of any module.</description>
<example>orphans -type CLS</example>
<modifier name="type" aliases="t" value="true" description="Type (e.g., extension) of resource to show; if unspecified, all types are included." />
</command>

<command name="manage" aliases="manager">
<description>Manages applications installed on this instance (interactive)</description>
<example>manage -ns MYAPPNS</example>
<modifier name="namespace" aliases="ns" value="true" description="Namespace to start the manager in" />
</command>

<command name="list-installed" aliases="list">
<description>Lists modules installed in the current namespace</description>
<example description="Shows all installed modules in tree format.">list-installed -tree</example>
<example description="Shows a description of all modules installed in the namespace by context">list -zn sql*</example>
<modifier name="tree" aliases="t" description="If specified, show dependency tree for installed modules" />
<modifier name="znamespace" aliases="zn" value="true" description="Find modules in namespaces and go to it." />
<modifier name="description" aliases="d" dataAlias="Desc" dataValue="1" description="Shows description for each module." />
</command>

<command name="list-dependents" aliases="dependents">
<description>Lists modules dependent on the specified module</description>
<example description="Lists all currently-installed modules dependent on the currently-installed 'HS.JSON' version">list-dependents HS.JSON</example>
<example description="Lists all modules in the 'AppModules' repository dependent on all 'HS.JSON' versions.">list-dependents -repos AppModules HS.JSON</example>
<example description="Lists all modules in the 'AppModules' repository dependent on 'HS.JSON' version '0.0.1+snapshot', as a tree.">dependents -t -r AppModules HS.JSON 0.0.1+snapshot</example>
<modifier name="tree" aliases="t" description="If specified, show as a tree (rather than a flattened list)" />
<modifier name="repos" aliases="r" value="true" description="Comma-separated list of repository names to search in. If unspecified, the version of the module in the current namespace will be used instead." />
<parameter name="module" required="true" description="Name of module for which dependent modules will be found" />
<parameter name="version" description="Version of the module for which dependent modules will be found (in all configured repositories)" />
</command>

<command name="version" aliases="ver">
<description>Shows version client and registry</description>
<example description="Shows version client and registry">
version
</example>
</command>

<command name="generate" aliases="gen"> 
<description>Generates module.xml</description>
<example description="Generates module.xml for your module in interactive mode ">generate</example>
<example description="Generates template in the specified folder /my/path">generate -t /my/path</example>
<example description="Export CLS,MAC,INC,DFI in the specified folder /my/path/src">
generate /my/path -export 00000,PacketName2,IgnorePacket2^00000,PacketName3,IgnorePacket3
 byte=1 isGenerated
 byte=2 isSystem
 byte=3 isPercented
 byte=4 isMapped
 byte=5 isDFI
</example>
<modifier name="template" aliases="t" description="Generates module.xml template in the specified folder" />
<modifier name="author" aliases="a" description="Request information about the author" />
<parameter name="path" description="Directory on the local filesystem, containing a file named module.xml" />
<modifier name="export" aliases="e" value="true" description="Export resource in path" />
</command>

<command name="search" aliases="find">
<description>Shows all modules in current registry or namespaces</description>
<example description="Shows all modules in current registry">search -r</example>
<modifier name="show-repo" aliases="r" dataAlias="Repo" dataValue="1" description="Shows github repository only for each module." />
<modifier name="description" aliases="d" dataAlias="Description" dataValue="1" description="Shows description for each module." />
<parameter name="searchString" description="Search string, * can be used" />
<example description="Shows a description of all modules in the name of which there is a context">find -d *tools*</example>
</command>

<command name="namespace" aliases="zn"> 
<description>See list modules in namespace and go to the namespace</description>
<example description="Show all modules in all namespaces">zn *</example>
<example description="Show all modules in namespaces by context">zn sql*</example>
<parameter name="name" description="Name namespace, * or context name*" />
</command>

</commands>
]]></Data>
</XData>

<Method name="Shell">
<Description>
@PublicAPI</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCommand:%String,pTerminateOnError:%Boolean=0,pHaltOnComplete:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Do ..ShellInternal(.pCommand,.tException)
	If $IsObject(tException) {
		If pTerminateOnError {
			Do $System.Process.Terminate($Job,1)
		}
		Set tSC = tException.AsStatus()
	}
	If pHaltOnComplete {
		Halt
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ShellInternal">
<Description>
For use in unit tests that need to test if a command threw any exceptions.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCommand:%String,*pException:%Exception.AbstractException</FormalSpec>
<Implementation><![CDATA[
	Set pException = $$$NULLOREF
	Set tOneCommand = 0
	Set tCommand = $Get(pCommand)
	If (tCommand '= "") {
		Set tOneCommand = 1
	}
	For {
		Try {
			If (tCommand = "") {
				Write "zpm: ",$Namespace,">"
				Read tCommand
				Write !
			}
			
			If (tCommand = "") {
				#; Do ..%Help()
				Quit
			}
			
			Kill tCommandInfo
      $$$ThrowOnError(..%ParseCommandInput(tCommand,.tCommandInfo))
			If (tCommandInfo = "quit") {
				Return
			} ElseIf (tCommandInfo = "help") {
				Do ..%Help(.tCommandInfo)
			} ElseIf (tCommandInfo = "init") {
				Do ..Init(.tCommandInfo)
			} ElseIf (tCommandInfo = "search") {
				Do ..Search(.tCommandInfo)
			} ElseIf (tCommandInfo = "repo") {
				Do ..Repository(.tCommandInfo)
			} ElseIf (tCommandInfo = "load") {
				Do ..Load(.tCommandInfo)
			} ElseIf (tCommandInfo = "install") {
				Do ..Install(.tCommandInfo)
			} ElseIf (tCommandInfo = "uninstall") {
				Do ..Uninstall(.tCommandInfo)
			} ElseIf (tCommandInfo = "manage") {
				Do ..Manage(.tCommandInfo)
			} ElseIf (tCommandInfo = "list-installed") {
				Do ..ListInstalled(.tCommandInfo)
			} ElseIf (tCommandInfo = "list-dependents") {
				Do ..ListDependents(.tCommandInfo)
			} ElseIf (tCommandInfo = "orphans") {
				Do ..ListOrphans(.tCommandInfo)
			} ElseIf (tCommandInfo = "config") {
				Do ..Config(.tCommandInfo)
			} ElseIf ($Listfind(..#STANDARDPHASES,tCommandInfo)) {
				Do ..RunOnePhase(.tCommandInfo)
			} ElseIf (tCommandInfo = "generate") {
				Do ..GenerateModuleXML(.tCommandInfo)
			} ElseIf (tCommandInfo = "module-action") {
				Do ..ModuleAction(.tCommandInfo)
			} ElseIf (tCommandInfo = "version") {
				Do ..Version(.tCommandInfo)
			} ElseIf (tCommandInfo = "namespace") {
				Do ..Namespace(.tCommandInfo)			}
			} Catch pException {
			#dim e As %Exception.AbstractException
			If (pException.Code = $$$ERCTRLC) {
				Set pException = $$$NULLOREF
				Return
			}
			Write !,pException.DisplayString()
		}
		
		Set tCommand = ""
		Quit:tOneCommand
		Write !
	}
]]></Implementation>
</Method>

<Method name="Namespace">
<Description>
Show modules in Namespace and to go namespace</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pCommandInfo]]></FormalSpec>
<Implementation><![CDATA[
	Set currentns=$Namespace
	Set name = $Translate($Get(pCommandInfo("parameters","name")),$c(34))
	Set tDesc=$Get(pCommandInfo("data","Desc"))
	If name["*" {
		Do ..GetListNamespace(.namespace)
		Set ns="",num=0
		For { set ns=$Order(namespace(ns)) Quit:ns=""
			Set $Namespace=ns
			Kill list
			If ("@"_ns)[("@"_$Zconvert($tr(name,"*"),"U")) {
				Set num=num+1
					,num(num)=ns
				Do ..GetListModules("",.list)
				If $D(list) {
					Set module="",write=0
					For { set module=$Order(list(module)) Quit:module=""
						Write !
						,$Select('write:num_".",1:$j("",$L(num)+1))
						,$$$escDefault(ns)_">"_$j("",namespace-$l(ns_">"))
						," "_$$$escGreen(module)_$j("",list-$l(module))
						," "_$LG(list(module),1)
						If tDesc {
							Write !?(4+$L(ns_">"_$Justify("",namespace-$Length(ns_">"))))
							Do ..DrawColumn($$$escYellow("Description: ")_" "_$Listget(list(module),2))
						}
						Set write=1
					}
				} Else {
					Write !
					,num_"."
					,$$$escViolet(ns)_">"_$Justify("",namespace-$Length(ns_">"))
					
				}
			}
		}
		Set $Namespace=currentns
		Do ##class(%Library.Prompt).GetString("Enter the namespace number where to go: ", .goto)	
		If goto,$D(num(goto)) Set $Namespace=num(goto)
	} Else {
		Set $Namespace=name
	}
]]></Implementation>
</Method>

<Method name="GetListNamespace">
<Description>
Get list Namespace, example do ##(%ZPM.PackageManager).GetListNamespace(.ns)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&namespace]]></FormalSpec>
<Implementation><![CDATA[
	New $Namespace
	Set $Namespace="%SYS"
	
	Set tQuery = "select Nsp from %SYS.Namespace_List(0,0) where Status = 1"
	Set tRes = ##class(%SQL.Statement).%ExecDirect(,tQuery)
	
	If (tRes.%SQLCODE < 0) {
		Throw ##class(%Exception.SQL).CreateFromSQLCODE(tRes.%SQLCODE,tRes.%Message)
	}
	While tRes.%Next(.tSC) {
		$$$ThrowOnError(tSC)
		Set namespace(tRes.%Get("Nsp"))=""
		Set:$Get(maxlen)<$Length(tRes.%Get("Nsp")) maxlen=$Length(tRes.%Get("Nsp"))
	}
	Set:$Data(namespace) namespace=$G(maxlen)
]]></Implementation>
</Method>

<Method name="DrawColumn">
<Description>
draw description</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>desc</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set dx=$x
	For d=1:1:$Length(desc," ") {
 		Set wd=$Piece(desc," ",d) 
		If $x+$l(wd)>80 Write !,?dx
		Write wd," " 
	}
 	Quit ""
]]></Implementation>
</Method>

<Method name="GetListModules">
<Description>
Get List Modules
example d ##class(%ZPM.PackageManager).GetListModules("zpm",.list)</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[StartsWith:%String="",&pList]]></FormalSpec>
<Implementation><![CDATA[
	Set tQuery = "select Name,VersionString,Description,ExternalName from %ZPM_PackageManager_Developer.""MODULE"""
	If StartsWith'="" { Set tRes = ##class(%SQL.Statement).%ExecDirect(,tQuery_ " where name %StartsWith ?",StartsWith) }
	Else { Set tRes = ##class(%SQL.Statement).%ExecDirect(,tQuery)}
	If (tRes.%SQLCODE < 0) {
		Throw ##class(%Exception.SQL).CreateFromSQLCODE(tRes.%SQLCODE,tRes.%Message)
	}
	While tRes.%Next(.tSC) {
		$$$ThrowOnError(tSC)
		Set pList(tRes.%Get("Name"))=$lb(tRes.%Get("VersionString"),tRes.%Get("Description"),tRes.%Get("ExternalName"))
		Set:$G(maxlen)<$L(tRes.%Get("Name")) maxlen=$L(tRes.%Get("Name"))
	}
	Set:$D(pList) pList=$G(maxlen)
]]></Implementation>
</Method>

<Method name="GenerateModuleXML">
<Description>
generates module.xml</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pCommandInfo]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tPath = $Get(pCommandInfo("parameters","path"))
	If (tPath="") {
		Set tHelp(1) = "Enter path to the module folder (where module.xml will be generated)"
		Set tHelp(2) = "Enter "" null string to quit"
		Do ##class(%Library.Prompt).GetString("Enter module folder:", .tPath, , ,.tHelp)
		Return:(tPath="") $$$OK
	}
	Set tPath = ##class(%File).NormalizeDirectory(tPath)

	Set tExp = $$$GetModifier(pCommandInfo,"export")
	If tExp'="" {
		Do ##class(%ZPM.PackageManager.Developer.ModuleTemplate).ExportResources(tPath,tExp)
	}	
	If ($$$HasModifier(pCommandInfo,"template")) {
		Return ##class(%ZPM.PackageManager.Developer.ModuleTemplate).GenerateTemplate(tPath)
	} 
	While (1) {
		Set tHelp(1) = "Enter module name"
		Set tHelp(2) = "Enter "" null string to quit"
		Do ##class(%Library.Prompt).GetString("Enter module name:", .tName, , ,.tHelp)
		Return:(tName="") $$$OK
		If ('##class(%ZPM.PackageManager.Developer.ModuleTemplate).NameIsValid(tName)) {
			Write !,"Module name """_tName_""" is invalid" 
			Set tName=""
			Continue 
		}
		Quit 
	}

	While (1) {
		Set tVersion = "1.0.0"
		Do ##class(%Library.Prompt).GetString("Enter module version:", .tVersion)
		Return:(tVersion="") $$$OK
		If ('##class(%ZPM.PackageManager.Core.SemanticVersion).IsValid(tVersion)) {
			Write !,"Module version """_tVersion_""" is invalid" 
			Set tVersion=""
			Continue 
		}
		Quit
	}

	Do ##class(%Library.Prompt).GetString("Enter module description:", .tDescription)

	Do ##class(%Library.Prompt).GetString("Enter module keywords:", .tKeywords)	

	Set tTemplate = ##class(%ZPM.PackageManager.Developer.ModuleTemplate).NewTemplate(tPath, tName, tVersion, tDescription, tKeywords)
	Return:'$IsObject(tTemplate) 

	If ($$$HasModifier(pCommandInfo,"author")) {
		Write !,"Author:"
		Do ##class(%Library.Prompt).GetString("    Enter Author name:", .tAuthorPerson)	
		Do ##class(%Library.Prompt).GetString("    Enter Organization name:", .tAuthorOrg)
		Do ##class(%Library.Prompt).GetString("    Enter License:", .tAuthorLicense)
		Do ##class(%Library.Prompt).GetString("    Enter Copyright Date:", .tAuthorCopy)
		Do ##class(%Library.Prompt).GetString("    Enter Notes:", .tAuthorNotes)
		Do tTemplate.SetAuthorProps(tAuthorPerson, tAuthorOrg, tAuthorLicense, tAuthorCopy, tAuthorNotes)
		Write !
	}
	
	Set tSrc = "src"
	Do ##class(%Library.Prompt).GetString("Enter module source folder:", .tSrc)	
	Do tTemplate.ReadResorces(tSrc)

	// web applications
	Do ##class(%ZPM.PackageManager.Developer.ModuleTemplate).GetCSPApplications(.apps)
	If ($Listlength(apps)>0 ) {
		Write !!,"Existing Web Applications:"
		For i=1:1:$Listlength(apps) {
			Write !,"    "_$Listget(apps,i)
		}
		Do ##class(%Library.Prompt).GetString("    Enter a comma separated list of web applications or * for all:", .tWebAppList)

		Do tTemplate.AddWebApps(tWebAppList,.tCSPapps) // tCSP - list of CSP (not REST apps) 
		For i=1:1:$Listlength(tCSPapps) {
			Set tCSPPath = ""
			Do ##class(%Library.Prompt).GetString("    Enter path to csp files for "_$Listget(tCSPapps,i)_": ", .tCSPPath)
			If (tCSPPath'="") {
				Do tTemplate.SetSourcePathForCSPApp($Listget(tCSPapps,i),tCSPPath)
			}
		}
	}

	// dependencies
	Write !,"Dependencies:"
	While 1 {
		Set tDependant = ""
		Set tResponse = ##class(%Library.Prompt).GetString("    Enter module:version or empty string to continue:", .tDependant)
		Set tDependant = $ZStrip(tDependant,"<>W")
		Quit:(tDependant="")
		Do tTemplate.AddDependant(tDependant)
	}

	Do tTemplate.ProcessResources()
	Return tTemplate.SaveFile(tPath)
]]></Implementation>
</Method>

<Method name="GetDefaultCommandRegistry">
<Description>
Get Default Command of Registry
example d ##class(%ZPM.PackageManager).GetDefaultCommandRegistry()</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	New $Namespace
	Set $Namespace="%SYS"
	Set Status=##Class(Config.Startup).Get(.Properties)
	If Status {
		Set ServerPort="http://"_$zu(110)_":"_$Get(Properties("WebServerPort"),52773)
		Write !,"Default commands for the registry"
		Write !,"View all packets in the browser:",!,"  ",ServerPort_"/registry/packages/-/all"
		Write !,"Switch to the current registry:",!,"   repo -r -n registry -url "_ServerPort_"/registry/ -user ""_system"" -pass ""SYS""",!
		
	}
]]></Implementation>
</Method>

<Method name="Version">
<Description>
Version client and registry</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pCommandInfo]]></FormalSpec>
<Implementation><![CDATA[
	New $Namespace
  	Do ..GetListNamespace(.namespace)
  
	Set $Namespace="%SYS"

	Do ..GetListModules("zpm",.list)
	If $Data(list("zpm")) {
			Write !,$$$escDefault($namespace)_"> "_$$$escGreen("zpm ")_$ListGet(list("zpm"),1)
	}
	Set ns=""
	For { Set ns=$Order(namespace(ns)) Quit:ns=""
		Kill list
		Set $namespace=ns
		Do ..GetListModules("zpm",.list)
		If $Data(list("zpm-registry")) {
			Write !,$$$escDefault(ns)_"> "_$$$escGreen("zpm-registry ")_$ListGet(list("zpm-registry"),1)
			Set Found=ns
			Do ..GetDefaultCommandRegistry()
		}
	}
	Set $namespace="%SYS"
	If '$Data(Found) Write !," Locally installed zpm-registry not found" 
	
	// Get URL current registry
	Set tRes = ##class(%ZPM.PackageManager.Client.RemoteServerDefinition).ExtentFunc()
	While tRes.%Next(.tSC) {
		$$$ThrowOnError(tSC)

		#dim tRepository As %ZPM.PackageManager.Client.RemoteServerDefinition
		Set tRepository = ##class(%ZPM.PackageManager.Client.RemoteServerDefinition).%OpenId(tRes.ID,,.tSC)
		$$$ThrowOnError(tSC)
		Set tService = tRepository.GetPackageService()
		Set tInfo = tService.GetInfo()
		Write !,$$$escBlue(tRepository.URL)," - ",tInfo.version
	}
	q $$$OK
]]></Implementation>
</Method>

<Method name="Init">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pCommandInfo]]></FormalSpec>
<Implementation><![CDATA[
	// In quiet mode, no prompts should be shown.
	Set tQuiet = $$$HasModifier(pCommandInfo,"noprompt")
	
	// Local artifact cache
	$$$ThrowOnError(##class(%ZPM.PackageManager.Client.Utils).InitializeLocalCache(.tCreated))
	If (tCreated) {
		Write !,"Initialized local cache."
	} Else {
		Write !,"Local cache already exists."
	}
	
	// Reindex tables with semantic version indices
	For tClass = "%ZPM.PackageManager.Server.Module","%ZPM.PackageManager.Server.Application","%ZPM.PackageManager.Client.Filesystem.Cache" {
		Write !,"Reindexing ",tClass,"... "
		$$$ThrowOnError($ClassMethod(tClass,"%BuildIndices",,1,1))
		Write "done."
	}
	
	// Package Manager Settings
	If tQuiet {
		Set tResult = 0
	} Else {
		Write !
		Set tResult = 0
		Set tHelp = "Enter ""Yes"" to configure settings for third-party tools that the package manager needs. These are all optional, "_
			"with the possible exception of JAVA_HOME, which must be configured to enable packaging of modules or extraction of packages."
		Set tResponse = ##class(%Library.Prompt).GetYesNo("Do you want to configure general package manager settings?",.tResult,.tHelp)
		If (tResponse '= $$$SuccessResponse) {
			$$$ThrowStatus($$$ERROR($$$GeneralError,"Operation cancelled."))
		}
	}
	If (tResult) {
		Set tRes = ##class(%SQL.Statement).%ExecDirect(,"call %ZPM_PackageManager_Developer.IConfigurable_ListSettings()")
		If (tRes.%SQLCODE < 0) {
			$$$ThrowStatus($$$ERROR($$$SQLCode,tRes.%SQLCODE,tRes.%Message))
		}
		Set tLastSource = ""
		While tRes.%Next(.tSC) {
			$$$ThrowOnError(tSC)
			
			Set tSource = tRes.%Get("Source")
			If (tSource '= tLastSource) {
				Set tLastSource = tSource
				Set tSourceDesc = tRes.%Get("SourceDescription")
				Write !!,tSourceDesc
			}
			Set tSetting = tRes.%Get("Name")
			Set tSettingDesc = tRes.%Get("Description")
			Set tSettingValue = tRes.%Get("Value")
			
			Write !,tSetting,": ",tSettingDesc
			Set tResponse = ##class(%Library.Prompt).GetString("Value:",.tSettingValue,,,tSettingDesc)
			If (tResponse '= $$$SuccessResponse) {
				$$$ThrowStatus($$$ERROR($$$GeneralError,"Operation cancelled."))
			}
			
			If (tSettingValue '= tRes.%Get("Value")) {
				$$$ThrowOnError($ClassMethod(tSource,"SetSettingValue",tSetting,tSettingValue))
				Write !,tSetting," updated."
			}
		}
		$$$ThrowOnError(tSC)
	}
	
	
	If tQuiet {
		Set tConfigureZPM = $$$HasModifier(pCommandInfo,"zpm")
	} Else {
		// Update of language extension - see if one is already configured.
		$$$ThrowOnError(..UpdateLanguageExtensions(0,1,.tHasZPM))
		Set tConfigureZPM = 'tHasZPM // Default to "yes" if command is missing.
		
		Write !
		Set tHelp = "The 'ZPM' command allows quick command line access to many features of the package manager. Extensive documentation is available via:"_$c(13,10,9)_" zpm ""help""."
		Set tResponse = ##class(%Library.Prompt).GetYesNo("Do you want to enable/update the 'ZPM' command?",.tConfigureZPM,.tHelp)
		If (tResponse '= $$$SuccessResponse) {
			$$$ThrowStatus($$$ERROR($$$GeneralError,"Operation cancelled."))
		}
	}
	If tConfigureZPM {
		$$$ThrowOnError(..UpdateLanguageExtensions())
	}
]]></Implementation>
</Method>

<Method name="Search">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pCommandInfo]]></FormalSpec>
<Implementation><![CDATA[
	Set tRepo = $Get(pCommandInfo("data","Repo"),0)
	Set tDesc= $Get(pCommandInfo("data","Description"),0)
	Set tSearchString = $Get(pCommandInfo("parameters","searchString"),"")
	Set tName = $$$GetModifier(pCommandInfo,"name")
	If (tName '= "") {
		Do ..ShowModulesForRepository(tName, tRepo, tDesc, tSearchString)
	} Else {
		Set tRes = ##class(%SQL.Statement).%ExecDirect(,"select Name, Details from %ZPM_PackageManager_Client.ServerDefinition")
		If (tRes.%SQLCODE < 0) {
			Throw ##class(%Exception.SQL).CreateFromSQLCODE(tRes.%SQLCODE,tRes.%Message)
		}
		While tRes.%Next(.tSC) {
			$$$ThrowOnError(tSC)
			If ($I(tCount) > 1) {
				Write !!
			}
			Write tRes.%Get("Name")," ", tRes.%Get("Details"),":"
			Do ..ShowModulesForRepository(tRes.%Get("Name"), tRepo, tDesc, tSearchString)
		}
		$$$ThrowOnError(tSC)
	}
]]></Implementation>
</Method>

<Method name="Config">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pCommandInfo]]></FormalSpec>
<Implementation><![CDATA[
	Set action = $Get(pCommandInfo("parameters","action"))
	Set key = $Get(pCommandInfo("parameters","key"))
	Set value = $Get(pCommandInfo("parameters","value"))

	If (action="") { 
		Set action = "list"	
	}
	If (action="list") {
		Do ##class(%ZPM.PackageManager.Client.Settings).PrintList()
	} ElseIf (action="set") {
		If ( (key = "") || (value="") ) {
			Write "Key and Value required. Use config set <key> <value>",!
			Quit
		} 
		Do ##class(%ZPM.PackageManager.Client.Settings).UpdateOne(key,value)
	} ElseIf (action="get") {
		If (key = "") {
			Do ##class(%ZPM.PackageManager.Client.Settings).PrintList()
		} Else {
			Do ##class(%ZPM.PackageManager.Client.Settings).PrintOne(key)
		}
	} ElseIf (action="delete") {
		If (key = "") {
			Write "Key required. Use config delete <key>",!
			Quit
		}
		Do ##class(%ZPM.PackageManager.Client.Settings).ResetToDefault(key)
	}
]]></Implementation>
</Method>

<Method name="Repository">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pCommandInfo]]></FormalSpec>
<Implementation><![CDATA[
	Set tFileSystem = $$$HasModifier(pCommandInfo,"filesystem")
	Set tRemote = $$$HasModifier(pCommandInfo,"remote")
	Set tLocal = $$$HasModifier(pCommandInfo,"local")
	
	If $$$HasModifier(pCommandInfo,"list") {
		Write !
		If (tFileSystem + tRemote + tLocal '= 1) {
			Set tRes = ##class(%SQL.Statement).%ExecDirect(,
				"select Name "_
				"from %ZPM_PackageManager_Client.ServerDefinition "_
				"order by %ZPM_PackageManager_Client.ServerDefinition_SortOrder(ID) desc")
			If (tRes.%SQLCODE < 0) {
				Throw ##class(%Exception.SQL).CreateFromSQLCODE(tRes.%SQLCODE,tRes.%Message)
			}
			While tRes.%Next(.tSC) {
				$$$ThrowOnError(tSC)
				
				#dim tDefn As %ZPM.PackageManager.Client.ServerDefinition
				Set tRepository = ##class(%ZPM.PackageManager.Client.ServerDefinition).ServerDefinitionKeyOpen(tRes.%Get("Name"),,.tSC)
				$$$ThrowOnError(tSC)
				Do tRepository.Display()
				Write !
			}
			$$$ThrowOnError(tSC)
		}
		Quit
	} ElseIf $$$HasModifier(pCommandInfo,"enable") {
	} ElseIf $$$HasModifier(pCommandInfo,"disable") {
	} ElseIf $$$HasModifier(pCommandInfo,"info") {
	} ElseIf $$$HasModifier(pCommandInfo,"list-modules") {
		Do ..Search(.pCommandInfo)
		Quit
	} ElseIf $$$HasModifier(pCommandInfo,"delete-all") {
		Set tDeleteFS = tFileSystem || 'tRemote
		Set tDeleteRemote = tRemote || 'tFileSystem
		If tDeleteFS {
			$$$ThrowOnError(##class(%ZPM.PackageManager.Client.FilesystemServerDefinition).%DeleteExtent())
		}
		If tDeleteRemote {
			$$$ThrowOnError(##class(%ZPM.PackageManager.Client.RemoteServerDefinition).%DeleteExtent())
		}
	} ElseIf $$$HasModifier(pCommandInfo,"delete") {
		$$$ThrowOnError(##class(%ZPM.PackageManager.Client.ServerDefinition).ServerDefinitionKeyDelete($$$GetModifier(pCommandInfo,"name")))
		Quit
	} Elseif $$$HasModifier(pCommandInfo,"reset-defaults") {
        Set tName = $$$GetModifier(pCommandInfo,"name")
        If ((tRemote'=1)||(tName="")) {
            Write "Specify type (-remote) and repository name (-name registry)"
            Quit
        }
        Merge tModifiers = pCommandInfo("modifiers")
        Set tModifiers("url") = ##class(%ZPM.PackageManager.Client.Settings).GetDefaultRegistry()
        If (tModifiers("url")="") {
            Write "Error retrieving default registry URL"
            Quit
        }
        Set tModifiers("username") = "", tModifiers("password") = ""
    	Set tType = "%ZPM.PackageManager.Client.RemoteServerDefinition"
        $$$ThrowOnError($ClassMethod(tType,"Configure",1,.tModifiers,.tData))
    } Else {
		Set tName = $$$GetModifier(pCommandInfo,"name")
		Set tType = $$$GetModifier(pCommandInfo,"type")
		
		#dim tRepoTypeResult As %SQL.StatementResult
		Set tStatement = ##class(%SQL.Statement).%New()
		Set tSC = tStatement.%PrepareClassQuery("%ZPM.PackageManager.Client.ServerDefinition","Catalog")
		$$$ThrowOnError(tSC)
		Set tRepoTypeResult = tStatement.%Execute()
		If tRepoTypeResult.%SQLCODE < 0 {
			Throw ##class(%Exception.SQL).CreateFromSQLCODE(tRepoTypeResult.%SQLCODE, tRepoTypeResult.%Message)
		}
		While tRepoTypeResult.%Next(.tSC) {
			$$$ThrowOnError(tSC)
			Set tMonikers($ZConvert(tRepoTypeResult.%Get("Moniker"),"L")) = tRepoTypeResult.%Get("Classname")
			Set tClassList($Increment(tClassList)) = tRepoTypeResult.%Get("Classname")
			Set tDescList($Increment(tDescList)) = tRepoTypeResult.%Get("Description")
		}
		$$$ThrowOnError(tSC)
	
		If (tType = "") {
			Set tType = $Select(
				tFileSystem:"%ZPM.PackageManager.Client.FilesystemServerDefinition",
				tRemote:"%ZPM.PackageManager.Client.RemoteServerDefinition",
				tLocal:"%ZPM.PackageManager.Client.LocalServerDefinition",
				1:"")
			
			If (tType = "") {
				Set tResponse = ##class(%Library.Prompt).GetMenu("Which sort of repository do you wish to configure?",.tDescIndex,.tDescList,,$$$InitialDisplayMask)
				If (tResponse '= $$$SuccessResponse) {
					$$$ThrowStatus($$$ERROR($$$GeneralError,"Operation cancelled."))
				}
			
				If (tDescIndex = "") {
					$$$ThrowStatus($$$ERROR($$$GeneralError,"A repository type must be specified."))
				}
				
				Set tType = tClassList(tDescIndex)
			}
		} ElseIf $Data(tMonikers($ZConvert(tType,"L")),tClassName) {
			Set tType = tClassName
		}
		
		Set tBaseClass = "%ZPM.PackageManager.Client.ServerDefinition"
		If '$ClassMethod(tType,"%Extends",tBaseClass) {
			Set tSC = $$$ERROR($$$GeneralError,$$$FormatText("Invalid type '%1' - must extend %2",tType,tBaseClass))
		}
		
		Merge tModifiers = pCommandInfo("modifiers")
		Merge tData = pCommandInfo("data")
		$$$ThrowOnError($ClassMethod(tType,"Configure",1,.tModifiers,.tData))
	}
]]></Implementation>
</Method>

<Method name="ShowModulesForRepository">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRepoName:%String,pShowRepo:%Boolean=0,pShowDesc:%Boolean=0,pSearchString:%String=""</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	#define gn "^||tmpDesc"
	Kill @$$$gn
	Set maxlenname = 0, where = ""
	If pSearchString["*" {
		Set where=" WHERE name like ?"
	} Elseif pSearchString'="" { 
		Set where=" WHERE name = ?"
	}
	Set tQuery = "SELECT Name,Version,Repo,Description FROM %ZPM_PackageManager_Developer.Utils_GetModuleList(?) "_where
	If (pSearchString = "") {
		Set tRes = ##class(%SQL.Statement).%ExecDirect(,tQuery,pRepoName)
	} Else {
		Set tRes = ##class(%SQL.Statement).%ExecDirect(,tQuery,pRepoName, $Replace(pSearchString,"*","%"))
	}
	If (tRes.%SQLCODE < 0) {
		Throw ##class(%Exception.SQL).CreateFromSQLCODE(tRes.%SQLCODE,tRes.%Message)
	}
	While tRes.%Next(.tSC) {
		$$$ThrowOnError(tSC)
		Set name = tRes.%Get("Name")
		Set:($Length(name)>maxlenname) maxlenname = $Length(name)
		Set @$$$gn@(name)=$Listbuild(tRes.%Get("Version"),tRes.%Get("Repo"),tRes.%Get("Description"))
	}
	Set name=""
	For { 
		Set name = $Order(@$$$gn@(name)) 
		Quit:name=""
		Write !,$$$escGreen(name)
		Write ?(maxlenname+1), $Listget(@$$$gn@(name),1)
		If ( ($Listget(@$$$gn@(name),3)'="") && (pShowDesc=1) ) {
			Write ?(maxlenname+7),..DrawColumn($$$escYellow("Description: ")_$Listget(@$$$gn@(name),3))
		}
		If ( ($Listget(@$$$gn@(name),3)'="") && ($Listget(@$$$gn@(name),2)'="") && (pShowDesc=1) && (pShowRepo=1) ) {
			Write !
		}
		If ( ($Listget(@$$$gn@(name),2)'="") && (pShowRepo=1) ) {
			Write ?(maxlenname+7),$$$escBlue("Repo: "_$Listget(@$$$gn@(name),2))
		}	
	}
]]></Implementation>
</Method>

<Method name="Load">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pCommandInfo]]></FormalSpec>
<Implementation><![CDATA[
#define FileTempDir ##class(%SYS.System).TempDirectory()_"/"_##class(%PopulateUtils).StringMin(8,8)

	Set tDirectoryName = $Get(pCommandInfo("parameters","path"))
	Merge tParams = pCommandInfo("data")
	If ##class(%File).DirectoryExists(tDirectoryName) {
		$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.Utils).LoadNewModule(tDirectoryName,.tParams))
	} ElseIf ##class(%File).Exists(tDirectoryName),$$$lcase($PIECE(tDirectoryName, ".", *)) = "tgz" {
		Set tTargetDirectory = $$$FileTempDir
		Set tSC = ##class(%ZPM.PackageManager.Developer.Archive).Extract(tDirectoryName, tTargetDirectory)
		$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.Utils).LoadNewModule(tTargetDirectory, .tParams))
	}
]]></Implementation>
</Method>

<Method name="Install">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pCommandInfo]]></FormalSpec>
<Implementation><![CDATA[
	Set tRegistry = ""
	Set tModuleName = $Get(pCommandInfo("parameters","module"))
	If (tModuleName["/") {
		set $lb(tRegistry, tModuleName) = $lfs(tModuleName, "/")
	}
	If tRegistry = "" {
		Set tServer = ##class(%ZPM.PackageManager.Client.RemoteServerDefinition).DeploymentServerOpen(1,,.tSC)
		If $isobject(tServer) {
			Set tRegistry = tServer.Name
		}
	}

	Set tVersion = $Get(pCommandInfo("parameters","version"))
	Set tKeywords = $$$GetModifier(pCommandInfo,"keywords")
	
	Set tSearchCriteria = ##class(%ZPM.PackageManager.Core.SearchCriteria).%New()
	Set tSearchCriteria.Registry = tRegistry
	Set tSearchCriteria.Name = tModuleName
	Set tSearchCriteria.VersionExpression = tVersion
	Set tSearchCriteria.Keywords = tKeywords
	$$$ThrowOnError(##class(%ZPM.PackageManager.Client.Utils).SearchRepositoriesForModule(tSearchCriteria,.tResults))
	
	If (tResults.Count() > 0) {
		Set tResult = ""
		#dim tResult As %ZPM.PackageManager.Core.QualifiedModuleReference
		If (tKeywords = "") {
			// Install latest version by default
			Set tResult = tResults.GetAt(1) // latest version is in the first list item 
		} ElseIf (tResults.Count() > 0) {
			For i=1:1:tResults.Count() {
				Set tResultInfo = tResults.GetAt(i)
				Set tOptArray(i) = tResultInfo.Name_" "_tResultInfo.VersionString_" @ "_tResultInfo.ServerName
			}
			
			Set tValue = ""
			Do ##class(%Library.Prompt).GetMenu("Which version?",.tValue,.tOptArray,,$$$InitialDisplayMask)
			
			If (tValue '= "") {
				Set tResult = tResults.GetAt(tValue)
			}
		}
		
		If (tResult '= "") {
			Do ##class(%ZPM.PackageManager.Developer.Lifecycle.Abstract).GetDefaultParameters(.tParams)
			Merge tParams = pCommandInfo("data")
			Set tParams("Install") = 1
			$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.Utils).LoadModuleReference(tResult.ServerName,tResult.Name,tResult.VersionString,.tParams))
		}
	} Else {
		Set tPrefix = ""
		If (tModuleName '= "") {
			If (tVersion '= "") {
        $$$ThrowStatus($$$ERROR($$$GeneralError, tModuleName_" "_tVersion_" not found in any repository."))
			} Else {
        $$$ThrowStatus($$$ERROR($$$GeneralError, "'"_tModuleName_"' not found in any repository."))
			}
		} ElseIf (tKeywords '= "") {
      $$$ThrowStatus($$$ERROR($$$GeneralError,"No modules found matching keywords: '"_tKeywords_"'"))
		} Else {
			
		}
	}
]]></Implementation>
</Method>

<Method name="Uninstall">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pCommandInfo]]></FormalSpec>
<Implementation><![CDATA[
	Set tModuleName = pCommandInfo("parameters","module")
	Set tForce = $$$HasModifier(pCommandInfo,"force") // Force uninstallation even if things depend on this module
	Set tRecurse = $$$HasModifier(pCommandInfo,"recurse") // Recursively uninstall unneeded dependencies
	Merge tParams = pCommandInfo("data")
	$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.Module).Uninstall(tModuleName,tForce,tRecurse,.tParams))
]]></Implementation>
</Method>

<Method name="RunOnePhase">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pCommandInfo]]></FormalSpec>
<Implementation><![CDATA[
	Set tModName = $Get(pCommandInfo("parameters","module"))
	Set tPhases = $Listbuild($zcvt(pCommandInfo, "w"))
	Set tIsComplete = '$$$HasModifier(pCommandInfo,"only")
	Merge tParams = pCommandInfo("data")
	$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.Module).ExecutePhases(tModName,tPhases,tIsComplete,.tParams))
]]></Implementation>
</Method>

<Method name="ModuleAction">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pCommandInfo]]></FormalSpec>
<Implementation><![CDATA[
	Set tModName = $Get(pCommandInfo("parameters","module"))
	Set tPhases = $ListFromString($Get(pCommandInfo("parameters","actions"))," ")
	Set tIsComplete = '$$$HasModifier(pCommandInfo,"only")
	If $ListLength(tPhases) {
		// Accept lower-case phase names in the command.
		Set tPtr = 0
		Set tActualPhases = ""
		While $ListNext(tPhases,tPtr,tPhase) {
			Set tActualPhases = tActualPhases_$ListBuild($zcvt(tPhase, "w"))
		}
		Merge tParams = pCommandInfo("data")
		$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.Module).ExecutePhases(tModName,tActualPhases,tIsComplete,.tParams))
	} Else {
		If (tModName '= "") && ##class(%ZPM.PackageManager.Developer.Module).NameExists(tModName) {
			// TODO: list phases if a valid module name was specified.
		} Else {
			Do ..%Help()
		}
	}
]]></Implementation>
</Method>

<Query name="ActiveNamespaces">
<Type>%SQLQuery</Type>
<SqlProc>1</SqlProc>
<SqlQuery>	select Nsp,Nsp from %SYS.Namespace_List(0,0) where Status = 1</SqlQuery>
<Parameter name="ROWSPEC" value="ID:%String,Name:%String"/>
</Query>

<Method name="Manage">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pCommandInfo]]></FormalSpec>
<Implementation><![CDATA[
	New $Namespace
	Set tNSArg = $Get(pCommandInfo("modifiers","namespace"))
	Set tNamespace = ""
	If (tNSArg '= "") {
		// See if this is the name of a particular namespace.
		If ##class(%SYS.Namespace).Exists(tNSArg) {
			Set tNamespace = tNSArg
		}
	} Else {
		// TODO: see if there is anything installed in this namespace.
	}
	
	Set tNSMenu($i(tNSMenu)) = "Install an application"
	Set tNSMenu($i(tNSMenu)) = "Upgrade/repair an application"
	Set tNSMenu($i(tNSMenu)) = "Uninstall an application"
	Set tNSMenu($i(tNSMenu)) = "Switch namespace"
	Set tNSMenu($i(tNSMenu)) = "Quit"
	
	For {
		Set tValue = ""
		Write !,"Namespace: ",$Namespace
		Set tResponse = ##class(%Library.Prompt).GetMenu("Select an option:",.tValue,.tNSMenu,,$$$InitialDisplayMask)
		If (tResponse '= $$$SuccessResponse) {
			$$$ThrowStatus($$$ERROR($$$GeneralError,"Operation cancelled."))
		}
		
		If (tValue '= 1) && (tValue '= 5) {
			While (tNamespace = "") {
				Set tNSValue = ""
				Set tResponse = ##class(%Library.Prompt).GetArray("Select a namespace:",.tNSValue,$ListBuild($classname()_":ActiveNamespaces"),,,,$$$InitialDisplayMask)
				If (tResponse '= $$$SuccessResponse) {
					$$$ThrowStatus($$$ERROR($$$GeneralError,"Operation cancelled."))
				}
				Set tNamespace = tNSValue
			}
			
			Set $Namespace = tNamespace
		}
		
		If (tValue = 1) {
			// Construct an instance of %ZPM.PackageManager.Core.InstallationInfo
			Set tInfo = ##class(%ZPM.PackageManager.Core.InstallationInfo).%New()
			
			Set tNamespace = ""
			While (tNamespace = "") {
				Set tResponse = ##class(%Library.Prompt).GetString("Namespace:",.tNamespace)
				If (tResponse '= $$$SuccessResponse) {
					$$$ThrowStatus($$$ERROR($$$GeneralError,"Operation cancelled."))
				}
				If ##class(%SYS.Namespace).Exists(tNamespace) {
					Write !,"Namespace '",tNamespace,"' already selects. Please enter a new namespace name."
					Set tNamespace = ""
				}
			}
			Set tInfo.Namespace = tNamespace
			
			Set tModName = ""
			Set tResponse = ##class(%Library.Prompt).GetString("Application name:",.tModName)
			If (tResponse '= $$$SuccessResponse) {
				$$$ThrowStatus($$$ERROR($$$GeneralError,"Operation cancelled."))
			}
			
			Set tModVersion = ""
			Set tResponse = ##class(%Library.Prompt).GetString("Application version/range:",.tModVersion)
			If (tResponse '= $$$SuccessResponse) {
				$$$ThrowStatus($$$ERROR($$$GeneralError,"Operation cancelled."))
			}
			
			Set tSearchCriteria = ##class(%ZPM.PackageManager.Core.SearchCriteria).%New()
			Set tSearchCriteria.Name = tModName
			Set tSearchCriteria.VersionExpression = tModVersion
			Set tSearchCriteria.IncludeSnapshots = 1
			Set tSearchCriteria.IncludePrerelease = 1
			$$$ThrowOnError(##class(%ZPM.PackageManager.Client.Utils).SearchRepositoriesForApplication(tSearchCriteria,.tResults))
			
			If (tResults.Count() > 0) {
				#dim tResult As %ZPM.PackageManager.Core.QualifiedModuleReference
				If (tResults.Count() = 1) {
					Set tInfo.ModuleReference = tResults.GetAt(1)
				} ElseIf (tResults.Count() > 1) {
					For i=1:1:tResults.Count() {
						Set tResult = tResults.GetAt(i)
						Set tOptArray(i) = tResult.Name_" "_tResult.VersionString_" @ "_tResult.ServerName
					}
					
					Set tResponse = ##class(%Library.Prompt).GetMenu("Which version?",.tValue,.tOptArray,,$$$InitialDisplayMask)
					If (tResponse '= $$$SuccessResponse) {
						$$$ThrowStatus($$$ERROR($$$GeneralError,"Operation cancelled."))
					}
					
					Set tInfo.ModuleReference = tResults.GetAt(tValue)
				}
			} Else {
				Write !,tModName_" "_tModVersion_" not found in any repository."
				Continue
			}
			
			// TODO: Parameters
			
			$$$ThrowOnError(##class(%ZPM.PackageManager.Client.Utils).InstallApplication(tInfo))
			
			Set $Namespace = tNamespace
		} ElseIf (tValue = 2) {
			// TODO: Implement, based on things installed in the current namespace.
			Write !,"This feature is not yet implemented."
		} ElseIf (tValue = 3) {
			// List installed modules with application packaging.
			
			Kill tModuleList
			Set tModuleList = 0
			
			#dim tRes As %SQL.StatementResult
			Set tRes = ##class(%SQL.Statement).%ExecDirect(,"select Name,LifecycleClass from %ZPM_PackageManager_Developer.""Module""")
			If (tRes.%SQLCODE < 0) {
				$$$ThrowStatus($$$ERROR($$$SQLCode,tRes.%SQLCODE,tRes.%Message))
			}
			While (tRes.%Next(.tSC)) {
				$$$ThrowOnError(tSC)
				set tLifecycleClass = tRes.LifecycleClass
				if (tLifecycleClass '= "") && ($Length(tLifecycleClass,".") = 1) {
					set tLifecycleClass = $$$DefaultLifecyclePackageDot_tLifecycleClass
				}
				If $ClassMethod(tLifecycleClass,"%Extends","%ZPM.PackageManager.Developer.Lifecycle.Application") {
					Set tModuleList($i(tModuleList)) = tRes.%Get("Name")
				}
			}
			$$$ThrowOnError(tSC)
			
			Set tUninstallAppIdx = ""
			While (tUninstallAppIdx = "") {
				Set tResponse = ##class(%Library.Prompt).GetMenu("Which application?",.tUninstallAppIdx,.tModuleList,,$$$InitialDisplayMask)
				If (tResponse '= $$$SuccessResponse) {
					$$$ThrowStatus($$$ERROR($$$GeneralError,"Operation cancelled."))
				}
			}
			
			// Construct an instance of %ZPM.PackageManager.Core.InstallationInfo
			Set tInfo = ##class(%ZPM.PackageManager.Core.InstallationInfo).%New()
			Set tInfo.Namespace = $Namespace
			Set tInfo.ModuleReference.Name = tModuleList(tUninstallAppIdx)
			$$$ThrowOnError(##class(%ZPM.PackageManager.Client.Utils).UninstallApplication(tInfo))
		} ElseIf (tValue = 4) {
			Set tNamespace = ""
		} ElseIf (tValue = 5) {
			Return
		}
	}
]]></Implementation>
</Method>

<Method name="ListInstalled">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pCommandInfo]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Set tNS = $Get(pCommandInfo("modifiers","znamespace"))
	set tDesc=$g(pCommandInfo("data","Desc"))
	If tNS'="" {
		Kill pCommandInfo 
		Set pCommandInfo("parameters","name")=tNS 
		Set pCommandInfo("data","Desc")=tDesc
		Do ..Namespace(.pCommandInfo) 
	}
	If tDesc {
		Set gn="^||tmpDesc"		
		Set sql="select Name, Description, Keywords, Root, VersionString, Author_CopyrightDate, Author_License, Author_Notes, Author_Organization, Author_Person from %ZPM_PackageManager_Developer.""Module"" "
			,rs=##class(%ResultSet).%New()
			,sc=rs.Prepare(sql)
		Set:sc sc=rs.Execute()
		If sc {
			For i=1:1 {
				Quit:'rs.%Next()  
				Set name=rs.Get("Name")
				Set:$Length(name)>$Get(maxlenname) maxlenname=$Length(name)
				If '$Data(@gn@(name,"Locale","Description")) {
					Set @gn@(name,"Locale")=$Listbuild(rs.Get("VersionString"),rs.Get("Root"))
					Set root=rs.Get("Root")
					Set desc=rs.Get("Description")
					For a="Author_CopyrightDate", "Author_License", "Author_Notes", "Author_Organization", "Author_Person" {
						Set @gn@(name,"Locale","Description",a)=rs.Get(a)
					}
					Set @gn@(name,"Locale","Description")=desc
				}
		 	}
			Set:$Get(name)'="" @gn@(name,"Locale")=$Get(maxlenname) 
		} 
	}
		
	Set tRes = ##class(%SQL.Statement).%ExecDirect(,
		"select Name,VersionString from %ZPM_PackageManager_Developer.""MODULE""")
	If (tRes.%SQLCODE < 0) {
		Throw ##class(%Exception.SQL).CreateFromSQLCODE(tRes.%SQLCODE,tRes.%Message)
	}
	While tRes.%Next(.tSC) {
		$$$ThrowOnError(tSC)
		Set tModMap(tRes.%Get("Name")) = tRes.%Get("VersionString")
	}
	$$$ThrowOnError(tSC)
	
	Set tTree = ''$Data(pCommandInfo("modifiers","tree"))
	
	If (tTree) {
		// Show tree of dependencies as well.
		// Modules that are dependencies for no other are shown at the top level.
		// TODO: deal with cyclic dependencies?
		
		Set tDepRes = ##class(%SQL.Statement).%ExecDirect(,
			"select ""Module""->Name ModName,Dependencies_Name DepName,Dependencies_VersionString DepVer "_
			"from %ZPM_PackageManager_Developer.Module_Dependencies")
		If (tDepRes.%SQLCODE < 0) {
			Throw ##class(%Exception.SQL).CreateFromSQLCODE(tRes.%SQLCODE,tRes.%Message)
		}
		While tDepRes.%Next(.tSC) {
			$$$ThrowOnError(tSC)
			Set tModMap(tDepRes.%Get("ModName"),tDepRes.%Get("DepName")) = tDepRes.%Get("DepVer")
			Set tVisitedMap(tDepRes.%Get("DepName")) = 1
		}
		$$$ThrowOnError(tSC)
		
		Set tMod = ""
		For {
			Set tMod = $Order(tModMap(tMod),1,tVersion)
			Quit:(tMod="")
			Do:'$Data(tVisitedMap(tMod)) ..AccumulateTreeRecursive(tMod,.tModMap,.tOrderedTree)
		}
		
		Do ..PrintTree(.tOrderedTree)
	} Else {
		Set tMod = ""
		For {
			Set tMod = $Order(tModMap(tMod),1,tVersion)
			Quit:(tMod="")
			Write !,$$$escGreen(tMod)," ",tVersion_" "
			If $Data(gn),$Data(@gn@(tMod,"Locale")) {
				Set maxlenname=$L(tMod_" "_tVersion_" ")
				Do ..DrawColumn($$$escYellow("Description: ")_$Get(@gn@(tMod,"Locale","Description")))
				If $Data(@gn@(tMod,"Locale","Description"))>9 {
					Set au="" For { 
						Set au=$Order(@gn@(tMod,"Locale","Description",au),1,audata) Quit:au=""
						Write:audata'="" !
						,?(maxlenname)
						,..DrawColumn($$$escViolet(au_": ")_audata)
					}
				}
			}
		}
	}
]]></Implementation>
</Method>

<Method name="AccumulateTreeRecursive">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pModName:%String,&pModMap,&pTree,pLevel:%Integer=0]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	If (pLevel = 0) && $Data(pVisitedMap(pModName)) {
		Quit
	}
	
	Set tParentIndex = $i(pTree)
	Set pTree(tParentIndex) = $ListBuild(pModName_" "_$Get(pModMap(pModName),"[missing]"))
	Set tDep = ""
	Set tPrevSibling = ""
	For {
		Set tDep = $Order(pModMap(pModName,tDep),1,tDepVerExpr)
		Quit:(tDep="")
		
		// Set first child for parent node to this index (if there is no first child yet)
		Set tSiblingIndex = pTree + 1
		If ($ListGet(pTree(tParentIndex),2) = "") {
			Set $List(pTree(tParentIndex),2) = tSiblingIndex
		}
		
		// Set next sibling for previous node to this index.
		If (tPrevSibling '= "") {
			Set $List(pTree(tPrevSibling),3) = tSiblingIndex
		}
		Set tPrevSibling = tSiblingIndex
		
		Do ..AccumulateTreeRecursive(tDep,.pModMap,.pTree,pLevel+1)
	}
]]></Implementation>
</Method>

<Method name="ListDependents">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pCommandInfo]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Set tTree = ''$Data(pCommandInfo("modifiers","tree"))
	Set tRepos = $ListFromString($Get(pCommandInfo("modifiers","repos")))
	Set tModName = $Get(pCommandInfo("parameters","module"))
	Set tVersion = $Get(pCommandInfo("parameters","version"))
	
	If tTree {
		New %tree
		Set tSC = ##class(%ZPM.PackageManager.Developer.Utils).GetDependentsAsTree(.%tree,.tErrorList,tModName,tVersion,tRepos)
		$$$ThrowOnError(tSC)
	} Else {
		Set tSC = ##class(%ZPM.PackageManager.Developer.Utils).GetDependentsList(.tList,.tErrorList,tModName,tVersion,tRepos)
		$$$ThrowOnError(tSC)
	}
	
	If $Data(tErrorList) {
		Write !,"Warning: some errors occurred."
		For i=1:1:tErrorList {
			Set $ListBuild(tServer,tModName,tVersion,tErrorSC) = tErrorList(i)
			Set tServer = $Case(tServer,"":" (installed)",:" @ "_tServer)
			Write !,tModName," ",tVersion,tServer,": ",$System.Status.GetErrorText(tErrorSC)
		}
		Write !
	}
	
	If tTree {
		Set tRef = "%tree"
		Set tState = 0
		
		For {
			Set tRef = $Query(@tRef)
			Quit:tRef=""
			
			For i=1:1:$QLength(tRef) {
				Set tSub = $QSubscript(tRef,i)
				If ($Get(tState(i)) = tSub) {
					Continue
				} Else {
					Set tNodeIndex = $i(tDependentTree)
			
					Set tState(i) = tSub
					For j=i+1:1:tState {
						Kill tState(j)
						Kill tPreviousNode
					}
					If $Data(tState(i,"node"),tPreviousNode)
					
					Set tState = i
					Set tState(i,"node") = tNodeIndex
					
					Set $ListBuild(tModName,tVersion,tServer) = tSub
					Set tServer = $Case(tServer,"":" (installed)",:" @ "_tServer)
					
					Set tValue = tModName_" "_tVersion_tServer
					
					Set tDependentTree(tNodeIndex) = $ListBuild(tValue)
					
					// Set first child
					If $Data(tState(i-1,"node"),tParent) && ($ListGet(tDependentTree(tParent),2) = "") {
						Set $List(tDependentTree(tParent),2) = tNodeIndex
					}
					
					// Set next sibling of previous node
					If $Data(tPreviousNode,tPreviousNode) && (tPreviousNode '= $Get(tParent)) {
						Set $List(tDependentTree(tPreviousNode),3) = tNodeIndex
					}
					
					Set tPreviousNode = tNodeIndex
				}
			}
		}
		
		Do ..PrintTree(.tDependentTree)
	} Else {
		For i=1:1:tList.Count() {
			#dim tItem As %ZPM.PackageManager.Core.QualifiedModuleReference
			Set tItem = tList.GetAt(i)
			Set tServer = $Case(tItem.ServerName,"":" (installed)",:" @ "_tItem.ServerName)
			Write !,tItem.Name," ",tItem.VersionString,tServer
		}
	}
]]></Implementation>
</Method>

<Method name="PrintTree">
<Description><![CDATA[
Prints a tree with unicode box art
Tree representation should be:
pTree(<node no.>) = $listbuild(<value>, <first child node no.>, <next sibling node no.>)
With the first node in node #1 (no root - it can have siblings), and the subscripts are sequential
according to pre-order (which is how the tree will be displayed, one node per line).]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pTree]]></FormalSpec>
<Implementation><![CDATA[
	Set tFrontPadding = ""
	Set tChildDepth = 0
	For i=1:1:$Order(pTree(""),-1) {
		Set tFirstChild = ""
		Set tNextSibling = ""
		Set $ListBuild(tValue, tFirstChild, tNextSibling) = pTree(i)
		
		Set tFrontPadding = $Get(tPadding(i))
		
		If (tNextSibling = "") {
			Set $Extract(tFrontPadding,*-2) = $c($zh("2514H"))
		}
		If (tFirstChild '= "") {
			Set $Extract(tFrontPadding,*) = $c($zh("252CH"))
		}
		
		Write tFrontPadding,$$$escGreen($p(tValue," ",1))," ",$p(tValue," ",2),!
		
		If (tNextSibling '= "") {
			Set tPadding(tNextSibling) = $Get(tPadding(i))
		}
		If (tFirstChild '= "") {
			Set tModPadding = ""
			If $Get(tPadding(i)) '= "" {
				Set tModPadding = $Extract(tPadding(i),1,*-3)_$Case(tNextSibling,"":" ",:$c($zh("2502H")))_"  "
			}
			Set tPadding(tFirstChild) = $Extract(tModPadding,1,*-1)_$c($zh("251CH"),$zh("2500H"),$zh("2500H"))
		}
	}
]]></Implementation>
</Method>

<Method name="ListOrphans">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pCommandInfo]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	Set tType = $$$GetModifier(pCommandInfo,"type")
	Set tResult = ##class(%ZPM.PackageManager.Developer.Utils).OrphanedResourcesFunc($Namespace,tType)
	While tResult.%Next(.tSC) {
		$$$ThrowOnError(tSC)
		Write tResult.%Get("Name"),!
	}
]]></Implementation>
</Method>

<Method name="UpdateLanguageExtensionsOne">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[RoutineName:%String,pTestOnly:%Boolean=0,*pFound:%Boolean=0,&tGenLines]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#def1arg STARTTAGQ " ;Generated by %ZPM.PackageManager: Start"
	#def1arg ENDTAGQ " ;Generated by %ZPM.PackageManager: End"
	#def1arg STARTTAG ##Expression($$$STARTTAGQ)
	#def1arg ENDTAG ##Expression($$$ENDTAGQ)
	Set tRtn = ##class(%Routine).%New(RoutineName)
	If ##class(%Routine).Exists(RoutineName) {
		Set tEnded = 1
		While 'tRtn.AtEnd {
			Set tLine = tRtn.ReadLine()
			If (tLine = $$$STARTTAGQ) {
				// Read through the ending tag.
				While ('tRtn.AtEnd) && (tRtn.ReadLine() '= $$$ENDTAGQ) {}
				
				// Generate the lines.
				Set pFound = 1
				For i=1:1:tGenLines {
					Set tRtnLines($i(tRtnLines)) = tGenLines(i)
				}
			} Else {
				// Before %ZLANGC00 was generated: there's an old version with ZPM defined.
				Set tIsZPM = ($ZConvert($Extract(tLine,1,4),"U") = "ZPM(")
				If tIsZPM {
					Set pFound = 1
					Set tEnded = 0
					Set tRtnLines($i(tRtnLines)) = $$$STARTTAGQ
				}
				If '(tIsZPM || tEnded) {
					If ($ZStrip($Extract(tLine),"*W") '= "") {
						Set tRtnLines($i(tRtnLines)) = $$$ENDTAGQ
						Set tEnded = 1
					}
				}
				Set tRtnLines($i(tRtnLines)) = tLine
			}
		}
		If 'tEnded {
			Set tRtnLines($i(tRtnLines)) = $$$ENDTAGQ
		} ElseIf 'pFound {
			For i=1:1:tGenLines {
				Set tRtnLines($i(tRtnLines)) = tGenLines(i)
			}
		}
	} Else {
		Merge tRtnLines = tGenLines
	}
	If (pTestOnly) {
		Quit
	}
	Do tRtn.Clear()
	For i=1:1:tRtnLines {
		Do tRtn.WriteLine(tRtnLines(i))
	}
	$$$ThrowOnError(tRtn.Save())
	$$$ThrowOnError(tRtn.Compile())
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="UpdateLanguageExtensions">
<ClassMethod>1</ClassMethod>
<FormalSpec>pVerbose:%Boolean=0,pTestOnly:%Boolean=0,*pFound:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#def1arg STARTTAGQ " ;Generated by %ZPM.PackageManager: Start"
	#def1arg ENDTAGQ " ;Generated by %ZPM.PackageManager: End"
	#def1arg STARTTAG ##Expression($$$STARTTAGQ)
	#def1arg ENDTAG ##Expression($$$ENDTAGQ)

	Set tSC = $$$OK
	Set tInitTLevel = $TLevel
	Try {
		TSTART
		// Get routine lines to generate
		Set tOffset = 0
		Set tStarted = 0
		For {
			Set tLineName = "zUpdateLanguageExtensions"_"+"_$i(tOffset)_"^"_$ZName
			Set tExtLine = $Text(@(tLineName))
			If (tExtLine=$$$STARTTAGQ) {
				Set tStarted = 1
			}
			If (tStarted) {
				Set tGenLines($i(tGenLines)) = tExtLine
			}
			Quit:(tExtLine=$$$ENDTAGQ)
			Quit:(tExtLine="")
		}

		If '$Data(tGenLines) {
			$$$ThrowStatus($$$ERROR($$$GeneralError,"Could not find %ZLANGC00 routine contents in "_$classname()))
		}
		Do ..UpdateLanguageExtensionsOne("%ZLANGC00.MAC", pTestOnly,.pFound,.tGenLines)
		Quit:pTestOnly
		Set i="" 
		For { set i=$Order(tGenLines(i),1,tStr) Quit:i=""
			If tStr[" Do ##class" Set tGenLines(i)=$Replace($Replace(tStr," Quit","")," Do "," Quit ") Quit
		}
		Do ..UpdateLanguageExtensionsOne("%ZLANGF00.MAC", pTestOnly,.pFound,.tGenLines)
		TCOMMIT
	} Catch e {
		Set tSC = e.AsStatus()
	}
	While ($TLevel > tInitTLevel) {
		TROLLBACK 1
	}
	Quit tSC
#; These are the actual contents of %ZLANGC00 (to be added/updated)
$$$STARTTAG
ZPM(pArgs...) Do ##class(%ZPM.PackageManager).Shell(pArgs...) Quit
$$$ENDTAG
#; Need an extra line down here to avoid the end bracket being on the same line as $$$ENDTAG - a comment is just fine.
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.Utils.FileBinaryTar">
<Super>%RegisteredObject,%ArrayOfDataTypes</Super>
<TimeCreated>65797,80136.644796</TimeCreated>

<Parameter name="BLOCKSIZE">
<Type>%Integer</Type>
<Default>512</Default>
</Parameter>

<Property name="name">
<Description>
name of file</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="100"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="mode">
<Description>
file mode</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="8"/>
</Property>

<Property name="uid">
<Description>
owner user ID</Description>
<Type>%String</Type>
<InitialExpression>..Dec2Oct(0, 6)</InitialExpression>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="8"/>
</Property>

<Property name="gid">
<Description>
owner group ID</Description>
<Type>%String</Type>
<InitialExpression>..Dec2Oct(0, 6)</InitialExpression>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="8"/>
</Property>

<Property name="size">
<Description>
length of file in bytes</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="12"/>
</Property>

<Property name="mtime">
<Description>
modify time of file</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="12"/>
</Property>

<Property name="chksum">
<Description>
checksum for header</Description>
<Type>%String</Type>
<InitialExpression>$JUSTIFY("", 8)</InitialExpression>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="8"/>
</Property>

<Property name="typeflag">
<Description>
type of file</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="DISPLAYLIST" value=",REGULAR,LINK,RESERVED,CHARACTER SPECIAL,BLOCK SPECIAL,DIRECTORY,FIFO SPECIAL,RESERVED"/>
<Parameter name="MAXLEN" value="1"/>
<Parameter name="VALUELIST" value=",0,1,2,3,4,5,6,7,x,g,L,K"/>
</Property>

<Property name="linkname">
<Description>
name of linked file</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="100"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="magic">
<Description>
USTAR indicator</Description>
<Type>%String</Type>
<InitialExpression>"ustar"</InitialExpression>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="6"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="version">
<Description>
USTAR version</Description>
<Type>%String</Type>
<InitialExpression>"00"</InitialExpression>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="2"/>
</Property>

<Property name="uname">
<Description>
owner user name</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="32"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="gname">
<Description>
owner group name</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="32"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="devmajor">
<Description>
device major number</Description>
<Type>%String</Type>
<InitialExpression>..Dec2Oct(0, 6)</InitialExpression>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="8"/>
</Property>

<Property name="devminor">
<Description>
device minor number</Description>
<Type>%String</Type>
<InitialExpression>..Dec2Oct(0, 6)</InitialExpression>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="8"/>
</Property>

<Property name="prefix">
<Description>
prefix for file name</Description>
<Type>%String</Type>
<Parameter name="CAPTION" value="Header"/>
<Parameter name="MAXLEN" value="155"/>
<Parameter name="TRUNCATE" value="1"/>
</Property>

<Property name="fileData">
<Description>
file data</Description>
<Type>%Stream.Object</Type>
</Property>

<Method name="nameGet">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  Return i%prefix_i%name
]]></Implementation>
</Method>

<Method name="sizeGet">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[  Return $$oct2dec^%Wmdc(i%size)
]]></Implementation>
</Method>

<Method name="sizeSet">
<FormalSpec>pSize:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set i%size = ..Dec2Oct(pSize, 11)
  if ($length(i%size)>11) {
    return $$$ERROR(5001, "Size too big")
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="modeSet">
<FormalSpec>pMode:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if $$$isWINDOWS {
    set mode = 0
    set mask = 0
  } else {
    set mode = pMode
    set mask = 4095
  }
  set i%mode = ..Dec2Oct(mode, 6, mask)
  return $$$OK
]]></Implementation>
</Method>

<Method name="mtimeSet">
<FormalSpec>pTime:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set mtime =..Dec2Oct(pTime, 11)
  set i%mtime = mtime
  return $$$OK
]]></Implementation>
</Method>

<Method name="chksumSet">
<FormalSpec>pVal:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set tVal =..Dec2Oct(pVal, 6)
  set i%chksum = tVal
  return $$$OK
]]></Implementation>
</Method>

<Method name="Dec2Oct">
<ClassMethod>1</ClassMethod>
<FormalSpec>pVal:%Integer,pLen:%Integer,pMask:%Integer=0</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set val = pVal
  if (pMask>0) {
    set val = $ZBOOLEAN(val, pMask, 1)
  }
  set val = $$dec2oct^%Wmdc(val)
  set val = $JUSTIFY(val, pLen)
  set val = $TRANSLATE(val, " ", 0)
  set val = val _ $c(32)
  return val
]]></Implementation>
</Method>

<Method name="FindPath">
<FormalSpec>pPath:%String="",*found:FileBinaryTar</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set found = $$$NULLOREF
  set pPath = $tr(pPath, "\", "/")
  set tmp = ..GetAt($p(pPath, "/"))
  if '$isobject(tmp) {
    return $$$ERROR($$$GeneralError, "Path '"_pPath_"' not found")
  }
  if $l(pPath, "/")>1 {
    return tmp.FindPath($p(pPath, "/", 2, *), .found)
  }
  set found = tmp
  Return $$$OK
]]></Implementation>
</Method>

<Method name="ExtractFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>aFileName:%String="",Gzip:%Boolean=1,pTargetDirectory:%String</FormalSpec>
<ReturnType>FileBinaryTar</ReturnType>
<Implementation><![CDATA[
  if aFileName = "" {
    Return $$$ERROR($$$GeneralError, "Filename not specified")
  }
  if Gzip {
    set fileStream=##class(%Stream.FileBinaryGzip).%New()
  } else {
    set fileStream=##class(%Stream.FileBinary).%New()
  }
  set fileStream.Filename=aFileName
  Return ..ExtractStream(fileStream, pTargetDirectory)
]]></Implementation>
</Method>

<Method name="ExtractTo">
<FormalSpec>pDest:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if ..name'="" {
    if ..typeflag=5 {
      set fullPath = ##class(%File).NormalizeDirectory(..name, pDest)
      set sc = ##class(%File).CreateDirectoryChain(fullPath)
      if $$$ISERR(sc) {
        return sc
      }
    } else {
      set fullPath = ##class(%File).NormalizeFilename(..name, pDest)
      set fs = ##class(%Stream.FileBinary).%New()
      set fs.Filename = fullPath
      do fs.CopyFromAndSave(..fileData)
      do fs.%Close()
    }
  }
]]></Implementation>
</Method>

<Method name="ExtractStream">
<ClassMethod>1</ClassMethod>
<FormalSpec>aFileStream:%Stream.Object,pTargetDirectory:%String</FormalSpec>
<ReturnType>FileBinaryTar</ReturnType>
<Implementation><![CDATA[
  #dim tFile As FileBinaryTar
  set blockSize = ..#BLOCKSIZE
  set result=..%New()
  while 'aFileStream.AtEnd {
    set tFile=..%New()
    set longLink4Name=""
    set longLink4Link=""
    do {
      set repeat=0
      set tHeader=aFileStream.Read(blockSize)
      do tFile.ParseHeader(tHeader)
      if tFile.name="./" {
        set repeat=1
        continue
      }
      If ($EXTRACT(tFile.name, 1, 2) = "./") {
        Set tFile.name = $EXTRACT(tFile.name, 3, *)
      }
      quit:tFile.name=""
      set $EXTRACT(tHeader, 149, 156) = $JUSTIFY("", 8)
      set chksumExpected = $zcrc(tHeader, 0)
      set chksum = $$oct2dec^%Wmdc(+tFile.chksum)
      if (chksumExpected'=chksum) {
        throw ##class(%Exception.General).%New("Checksum mismatch: "_chksumExpected_":"_chksum)
      }
      set fileSize=tFile.size
      set typeFlag=tFile.typeflag
      if (typeFlag="L") || (typeFlag="K") {
        set readBlocks=fileSize \ blockSize
        set:fileSize#blockSize>0 readBlocks=readBlocks + 1
        set longLink=aFileStream.Read(readBlocks * blockSize)
        set longLink=$zstrip(longLink,"<>",$char(0,32))
        set:(typeFlag="L") longLink4Name=longLink
        set:(typeFlag="K") longLink4Link=longLink
        set repeat=1
        continue
      }
      set repeat=0
      set:longLink4Name'="" tFile.name=longLink4Name
      set:longLink4Link'="" tFile.linkname=longLink4Link
    } while repeat
    set fileName=tFile.name
    quit:fileName=""
    if ( (tFile.typeflag'="g") && (tFile.typeflag=5) ) { 
      // save directory
      do tFile.ExtractTo(pTargetDirectory)
      //      do ..AddToArray(tFile, result)
    }
    
    continue:fileSize=0
    set readBlocks=fileSize \ blockSize
    set:fileSize#blockSize>0 readBlocks=readBlocks + 1
    set tFile.fileData=##class(%Stream.FileBinary).%New()
    for tPos=1:1:readBlocks {
      set tData=aFileStream.Read(blockSize)
      if (tPos=readBlocks)&&(fileSize#blockSize>0) {
        set tData=$extract(tData, 1, fileSize#blockSize)
      }
      do tFile.fileData.Write(tData)
    }
    if (fileSize'=tFile.fileData.Size) {
      throw ##class(%Exception.General).%New("File size mismatch: "_fileSize_":"_tFile.fileData.Size)
    }
    if tFile.typeflag'="g" { 
      // save file
      do tFile.ExtractTo(pTargetDirectory)
    }
  }
  Return result
]]></Implementation>
</Method>

<Method name="AddToArray">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFile:FileBinaryTar,pArray:FileBinaryTar</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
  if ('$isobject(pFile)) || ('$isobject(pArray)) {
    return
  }
  
  set tFileName= $zstrip(pFile.name,"<>", "/")
  set tItem=pArray
  for i=1:1:$length(tFileName, "/")-1 {
    set tPathItem=$piece(tFileName, "/", i)
    if 'tItem.IsDefined(tPathItem) {
      do tItem.SetAt(..%New(), tPathItem)
    }
    set tItem=tItem.GetAt(tPathItem)
  }
  do tItem.SetAt(pFile, $piece(tFileName, "/", $length(tFileName, "/")))
]]></Implementation>
</Method>

<Method name="ParseHeader">
<Internal>1</Internal>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec>aHeaderData:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set tProps=%class.Properties
  Set tPropKey = ""
  For {
    Set tProp = %class.Properties.GetNext(.tPropKey)
    Quit:(tPropKey = "")
    CONTINUE:"Header"'=tProp.Parameters.GetAt("CAPTION")
    set tProps(tProp.SequenceNumber)=tProp
  }	
  Set tPropKey = "", tPos = 0
  For {
    Set tPropKey = $Order(tProps(tPropKey),1,tProp)
    Quit:tPropKey=""
    Set tLen = tProp.Parameters.GetAt("MAXLEN")
    Do %code.WriteLine($char(9)_"Set i%"_tProp.Name_" = $zstrip($extract(aHeaderData, "_$increment(tPos)_", "_$increment(tPos, tLen - 1)_"), ""<>"", $c(0,32))")
    Do:tProp.Name="typeflag" %code.WriteLine($char(9)_"Set:i%"_tProp.Name_"=$c(0) i%"_tProp.Name_" = 0")
  }
  Return $$$OK
]]></Implementation>
</Method>

<Method name="Compact">
<ClassMethod>1</ClassMethod>
<FormalSpec>Path:%String="",gzip:%Boolean=1,pFileName:%String="",relativeTo:%String=""</FormalSpec>
<ReturnType>%Stream.FileBinary</ReturnType>
<Implementation><![CDATA[
  if (gzip) {
    set archive = ##class(%Stream.FileBinaryGzip).%New()
  } ELSE {
    set archive = ##class(%Stream.FileBinary).%New()		
  }
  if (pFileName'="") {
    Set tSC = archive.LinkToFile(pFileName)
    $$$ThrowOnError(tSC)
  }
  
  if relativeTo="" {
    set relativeTo = ##class(%File).ParentDirectoryName(Path)
  }
  set relativeTo = ##class(%File).NormalizeDirectory(relativeTo)

  Do ..ConstructTar(Path, relativeTo, archive)
  Set tSC = archive.%Save()
  $$$ThrowOnError(tSC)
  Do archive.%Close()
  
  return archive
]]></Implementation>
</Method>

<Method name="ConstructTar">
<ClassMethod>1</ClassMethod>
<FormalSpec>Path:%String,RelativeTo:%String,archive:%Stream.GlobalBinary</FormalSpec>
<Implementation><![CDATA[
  QUIT:Path=archive.Filename // skip archive itself
  set blockSize = ..#BLOCKSIZE
  if ##class(%File).DirectoryExists(Path) {
    set Path = ##class(%File).NormalizeDirectory(Path)
    set flag = 5 // Directory
    set size = 0
  } else {
    set Path = ##class(%File).NormalizeFilename(Path)
    set flag = 0 // Ordinary File
    set size = ##class(%File).GetFileSize(Path)
  }
  set name = $PIECE(Path, RelativeTo, 2, *)

  set mtime = ##class(%File).GetFileDateModified(Path, 1)
  set mtime = $ZDATETIME(mtime, -2)

  set mode = ##class(%File).Attributes(Path)

  set header = ""
  if name'="" {
    set obj = ..%New()
    set obj.name = name
    set obj.size = size
    set obj.mode = mode
    set obj.mtime = mtime
    set obj.typeflag = flag	
  
    set obj.uid = ""
    set obj.gid = ""
    set obj.uname = ""
    set obj.gname = ""
    
    set header = obj.ConstructHeader()
    set obj.chksum = $ZCRC(header, 0)
    set header = obj.ConstructHeader()
  }

  if (size > 0) {
    do archive.Write(header)
    set fs = ##class(%Stream.FileBinary).%New()
    set fs.Filename = Path
    do archive.CopyFrom(fs)
    if (size # blockSize) > 0 {
      set paddingSize = blockSize - (size # blockSize)
      set padding = $TRANSLATE($JUSTIFY("", paddingSize), " ", $CHAR(0))
      do archive.Write(padding)
    }
  } else {
    do archive.Write(header)
    set rs = ##class(%File).FileSetFunc(Path, , "Type", 1)
    while rs.%Next() {
      do ..ConstructTar(rs.Name, RelativeTo, archive)
    }
  }
]]></Implementation>
</Method>

<Method name="ConstructHeader">
<Internal>1</Internal>
<CodeMode>objectgenerator</CodeMode>
<ReturnType>%Binary</ReturnType>
<Implementation><![CDATA[
  set blockSize = ..#BLOCKSIZE
  set tProps=%class.Properties
  Set tPropKey = ""
  For {
    Set tProp = %class.Properties.GetNext(.tPropKey)
    Quit:(tPropKey = "")
    CONTINUE:"Header"'=tProp.Parameters.GetAt("CAPTION")
    set tProps(tProp.SequenceNumber)=tProp
  }	
  Do %code.WriteLine($char(9)_"Set tHeader = $TRANSLATE($JUSTIFY("""", "_blockSize_"), "" "", $CHAR(0))")
  Set tPropKey = "", tPos = 1
  For {
    Set tPropKey = $Order(tProps(tPropKey),1,tProp)
    Quit:tPropKey=""
    Set tLen = tProp.Parameters.GetAt("MAXLEN")
    Do %code.WriteLine($char(9)_"Set tVal = i%"_tProp.Name)
    If (tProp.Parameters.GetAt("TRUNCATE")) {
      Do %code.WriteLine($char(9)_"Set tVal = $extract(tVal, 1, "_(tLen-1)_")")
      Do %code.WriteLine($char(9)_"Set tPadding = $justify("""", "_(tLen)_" - $length(tVal))")
      Do %code.WriteLine($char(9)_"Set tPadding = $translate(tPadding, $char(32), $char(0))")
      Do %code.WriteLine($char(9)_"Set tVal = tVal _ tPadding")
    } else {
      Do %code.WriteLine($char(9)_"Set tVal = tVal _ $translate($justify("""", "_(tLen)_" - $length(tVal)), $char(32), $char(0))")
    }
    Do %code.WriteLine($char(9)_"Set tVal = $extract(tVal, 1, "_(tLen)_")")
    Do %code.WriteLine($char(9)_"Set $extract(tHeader, "_tPos_", "_(tPos+tLen-1)_") = tVal")
    Set tPos = tPos + tLen
  }
  Do %code.WriteLine($char(9)_"Return tHeader")
  Return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.cache.Adaptor">
<Abstract>1</Abstract>
<IncludeCode>%occInclude,%callout,%ZPM.cache</IncludeCode>
<IncludeGenerator>%occInclude</IncludeGenerator>
<PropertyClass>%ZPM.cache.PropertyParameters</PropertyClass>
<System>3</System>
<TimeCreated>65797,80046.549808</TimeCreated>

<Parameter name="%JSONENABLED">
<Default>1</Default>
</Parameter>

<Parameter name="%JSONIGNOREINVALIDFIELD">
<Type>BOOLEAN</Type>
<Default>0</Default>
</Parameter>

<Parameter name="%JSONNULL">
<Type>BOOLEAN</Type>
<Default>0</Default>
</Parameter>

<Parameter name="%JSONIGNORENULL">
<Type>BOOLEAN</Type>
<Default>0</Default>
</Parameter>

<Parameter name="%JSONREFERENCE">
<Type>STRING</Type>
<Constraint>OBJECT,ID,OID,GUID</Constraint>
<Default>OBJECT</Default>
<Flags>ENUM</Flags>
</Parameter>

<Method name="%JSONImport">
<FormalSpec>input,%mappingName:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Try {
		Set sc=$$$OK
		New %JSONObject
		If $isobject(input),input.%IsA("%Library.DynamicAbstractObject") {
			Set %JSONObject=input
		} Else {
			Set %JSONObject=##class(%Library.DynamicAbstractObject).%FromJSON(input)
		}
		Set sc=..%JSONImportInternal()
		
	} Catch ex {
		Set sc=ex.AsStatus()
	}
	Quit sc
]]></Implementation>
</Method>

<Method name="%JSONNew">
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<FormalSpec>dynamicObject:%DynamicObject,containerOref:%RegisteredObject=""</FormalSpec>
<GenerateAfter>%JSONGenerate</GenerateAfter>
<ReturnType>%RegisteredObject</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit ##class(%ZPM.cache.Generator).JSONNew(.%mode,.%class,.%property,.%method,.%parameter,.%codemode,.%code,.%classmodify,.%context)
]]></Implementation>
</Method>

<Method name="%JSONExport">
<FormalSpec>%mappingName:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
	    Set sc=$$$OK
	    Set sc=..%JSONExportInternal()
	} Catch ex {
	    If ex.%IsA("%Exception.SystemException") {
		Set zerror=ex.AsSystemError()
		If $piece(zerror,">",1)="<METHOD DOES NOT EXIST" {
		    Return $$$ERROR($$$JSONRefNotEnabled,$piece(zerror,",",2))
		}
	    }
	    Set sc=ex.AsStatus()
	}
	Quit sc
]]></Implementation>
</Method>

<Method name="%JSONExportToStream">
<FormalSpec><![CDATA[&export:%Stream.Object,%mappingName:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set io=$io
	Try {
		If $get(export)="" {
			Set export=##class(%FileCharacterStream).%New()
			Set export.TranslateTable="UTF8"
			Set filestream=1
		} Else {
			Set filestream = ($zobjclass(export)="%Library.FileCharacterStream")
		}
		If filestream {
			Set stream=export
		} Else {
			Set stream=##class(%FileCharacterStream).%New()
			Set stream.TranslateTable="UTF8"
		}
		Set sc=stream.Write("")
		If $$$ISOK(sc) {
			Set file=stream.Filename 
			Use file:(/NOXY)
			Set sc=..%JSONExportInternal()
			Use io
		}
		If $$$ISOK(sc) Set stream.LineTerminator=$select($$$isUNIX:$char(10),1:$char(13,10))
		If 'filestream,$$$ISOK(sc) {	
			Set sc=export.CopyFrom(stream)
		}
	} Catch ex {
		Set sc=ex.AsStatus()
	}
	Quit sc
]]></Implementation>
</Method>

<Method name="%JSONExportToString">
<FormalSpec><![CDATA[&%export:%String,%mappingName:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set sc=$$$OK
		Set %export=""
		Set sc=..%JSONExportToStringInternal()
	} Catch ex {
		If ex.Name="<MAXSTRING>" {
			Set sc=$$$ERROR($$$JSONMaxString,$$$mappingNameDisplay(%mappingName))
		} Else {
			Set sc=ex.AsStatus()
		}
	}
	Quit sc
]]></Implementation>
</Method>

<Method name="%JSONX">
<Internal>1</Internal>
<Abstract>1</Abstract>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit
]]></Implementation>
</Method>

<Method name="%JSONGenerate">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>generator</CodeMode>
<GenerateAfter>%JSONX</GenerateAfter>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit ##class(%ZPM.cache.Generator).%JSONGenerate(.%mode,.%class,.%property,.%method,.%parameter,.%codemode,.%code,.%classmodify,.%context)
]]></Implementation>
</Method>

<Method name="%JSONImportInternal">
<Internal>1</Internal>
<CodeMode>generator</CodeMode>
<GenerateAfter>%JSONGenerate</GenerateAfter>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit ##class(%ZPM.cache.Generator).JSONImportInternal(.%mode,.%class,.%property,.%method,.%parameter,.%codemode,.%code,.%classmodify,.%context)
]]></Implementation>
</Method>

<Method name="%JSONExportInternal">
<Internal>1</Internal>
<CodeMode>generator</CodeMode>
<GenerateAfter>%JSONGenerate</GenerateAfter>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit ##class(%ZPM.cache.Generator).JSONExportInternal(.%mode,.%class,.%property,.%method,.%parameter,.%codemode,.%code,.%classmodify,.%context)
]]></Implementation>
</Method>

<Method name="%JSONExportToStringInternal">
<Internal>1</Internal>
<CodeMode>generator</CodeMode>
<GenerateAfter>%JSONGenerate</GenerateAfter>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[	Quit ##class(%ZPM.cache.Generator).JSONExportToStringInternal(.%mode,.%class,.%property,.%method,.%parameter,.%codemode,.%code,.%classmodify,.%context)
]]></Implementation>
</Method>
</Class>


<Class name="%ZPM.cache.Generator">
<Abstract>1</Abstract>
<IncludeCode>%occInclude,%ZPM.cache</IncludeCode>
<IncludeGenerator>%occInclude,%ZPM.cache</IncludeGenerator>
<System>2</System>
<TimeCreated>65797,80046.651002</TimeCreated>

<Method name="GenerateMapping">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,*mapping</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  Kill mapping
  Do ..LeftSequenceClass(class,.classSeq)
  Set jsonignoreinvalidfield=''$$$comMemberKeyGet(class,$$$cCLASSparameter,"%JSONIGNOREINVALIDFIELD",$$$cPARAMdefault)
  Set jsondefaultmapping=$$$comMemberKeyGet(class,$$$cCLASSparameter,"%JSONMAPPING",$$$cPARAMdefault)
  Set jsondefaultnull=''$$$comMemberKeyGet(class,$$$cCLASSparameter,"%JSONNULL",$$$cPARAMdefault)
  Set jsondefaultignorenull=''$$$comMemberKeyGet(class,$$$cCLASSparameter,"%JSONIGNORENULL",$$$cPARAMdefault)
  Set jsondefaultreference=$zcvt($$$comMemberKeyGet(class,$$$cCLASSparameter,"%JSONREFERENCE",$$$cPARAMdefault),"U")
  If jsondefaultreference="" Set jsondefaultreference="OBJECT"
  If $case(jsondefaultreference,"OBJECT":0,"ID":0,"OID":0,"GUID":0,:1) {
    Quit $$$ERROR($$$JSONInvalidDefaultParameter,"parameter %JSONREFERENCE","class base")
  }
  Set sc=$$$OK
  Set property=""
  For {
    Set property=$$$comMemberNext(class,$$$cCLASSproperty,property)
    If property="" Quit
    Set jsoninclude=$zcvt($$$comMemberArrayGet(class,$$$cCLASSproperty,property,$$$cPROPparameter,"%JSONINCLUDE"),"L")
    Set includeProperty=$case(jsoninclude,"":"","inout":1,"inputonly":1,"outputonly":1,"none":1,:-1)
    If includeProperty=-1 {
      Set sc=$$$ERROR($$$JSONInvalidPropertyParameter,"parameter %JSONINCLUDE",property,"class base")
      Quit
    }
    Do ..GetMemberInfo(class,property,.includeProperty,.type,.membercat)
    If includeProperty {
      If jsoninclude="" Set jsoninclude="inout"
      If membercat["STREAM",membercat["Array" {
        Set sc=$$$ERROR($$$JSONNoStreamArray,property,"class base")
        Quit
      }
      Set literaltype=""
      If membercat["CSTREAM" {
        Set literaltype="string"
      } ElseIf membercat["BSTREAM" {
        Set encoding=$$$comMemberArrayGet(class,$$$cCLASSproperty,property,$$$cPROPparameter,"ENCODING")
        Set literaltype=$case($zcvt(encoding,"L"),"":"base64","base64":"base64","hex":"hex",:"")
        If literaltype="" {
          Set sc=$$$ERROR($$$XMLInvalidEncoding,encoding,property)
          Quit
        }
      } ElseIf membercat["LITERAL" {
        Set literaltype=$$$comMemberKeyGet(type,$$$cCLASSparameter,"JSONTYPE",$$$cPARAMdefault)
        If literaltype="" Set literaltype="string"
        If literaltype="string",$$$comMemberKeyGet(type,$$$cCLASSparameter,"XSDTYPE",$$$cPARAMdefault)'="string" {
          Set literaltype="string/json"
        }      }
      Set defClass=$$$comMemberKeyGet(class,$$$cCLASSproperty,property,$$$cPROPorigin)
      Set required=$$$comMemberKeyGet(class,$$$cCLASSproperty,property,$$$cPROPrequired)
      Set jsonfieldname=$$$comMemberArrayGet(class,$$$cCLASSproperty,property,$$$cPROPparameter,"%JSONFIELDNAME")
      If jsonfieldname="" Set jsonfieldname=property
      Set jsonnull=$$$comMemberArrayGet(class,$$$cCLASSproperty,property,$$$cPROPparameter,"%JSONNULL")
      Set jsonnull=$select(jsonnull="":jsondefaultnull,1:''jsonnull)
      If literaltype="string" {
        Set jsonignorenull=$$$comMemberArrayGet(class,$$$cCLASSproperty,property,$$$cPROPparameter,"%JSONIGNORENULL")
        Set jsonignorenull=$select(jsonignorenull="":jsondefaultignorenull,1:''jsonignorenull)
      } Else {
        Set jsonignorenull=0      }
      If membercat["OBJ" {
        Set jsonreference=$zcvt($$$comMemberArrayGet(class,$$$cCLASSproperty,property,$$$cPROPparameter,"%JSONREFERENCE"),"U")
        If jsonreference="" Set jsonreference=jsondefaultreference
        Set jsonreference=$case(jsonreference,
                    "OBJECT":$$$jsonrefobject,
                    "ID":$$$jsonrefid,
                    "OID":$$$jsonrefoid,
                    "GUID":$$$jsonrefguid,
                    :"")
        If jsonreference="" {
          Set sc=$$$ERROR($$$JSONInvalidPropertyParameter,"parameter %JSONREFERENCE",property,"class base")
          Quit        }
        Set jsonmapping=$$$comMemberArrayGet(class,$$$cCLASSproperty,property,$$$cPROPparameter,"%JSONMAPPING")
        If jsonmapping="" Set jsonmapping=jsondefaultmapping
      } Else {
        Set jsonreference=""      }
      Set node=$lb(property,$$$QN(property),jsoninclude,jsonfieldname,jsonnull,jsonignorenull,jsonreference,required,literaltype,membercat,type,jsonmapping)
      Set item=$increment(tempmap)
      Set tempmap(
          +classSeq-classSeq(defClass)+1,
          +$$$defMemberKeyGet(defClass,$$$cCLASSproperty,property,$$$cPROPsequencenumber),
          item)=node
    }  }
  If $$$ISOK(sc) {
    Set mapping($c(1),0)=$lb(class,jsonignoreinvalidfield)
    Set mapping($c(1))=0
    Set cls=""
    For {
      Set cls=$order(tempmap(cls))
      If cls="" Quit
      Set prop=""
      For {
        Set prop=$order(tempmap(cls,prop))
        If prop="" Quit
        Set num=""
        For {
          Set num=$order(tempmap(cls,prop,num))
          If num="" Quit
          Set item=mapping($c(1))+1
          Set mapping($c(1))=item
          Set mapping($c(1),item)=tempmap(cls,prop,num)
        }   }    }   }
  Quit sc
]]></Implementation>
</Method>

<Method name="GetMemberInfo">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[class:%String,property:%String,&includeProperty:%Boolean,*type:%String,*membercat:%String]]></FormalSpec>
<Implementation><![CDATA[
  Set collection=$$$comMemberKeyGet(class,$$$cCLASSproperty,property,$$$cPROPcollection)
  Set relationship=$$$comMemberKeyGet(class,$$$cCLASSproperty,property,$$$cPROPrelationship)
  Set cardinality=$$$comMemberKeyGet(class,$$$cCLASSproperty,property,$$$cPROPcardinality)
  If includeProperty = "" {
    If $$$comMemberKeyGet(class,$$$cCLASSproperty,property,$$$cPROPmultidimensional) {
      Set includeProperty = 0
    } ElseIf $$$comMemberKeyGet(class,$$$cCLASSproperty,property,$$$cPROPprivate)||(property="%Concurrency") {
      Set includeProperty = 0
    } ElseIf relationship,cardinality'="children",cardinality'="many" {
      Set includeProperty = 0
    } Else {
      Set includeProperty = 1
    }  }
  If includeProperty {
    Set type=$$$comMemberKeyGet(class,$$$cCLASSproperty,property,$$$cPROPtype)
    If type="" Set type="%Library.String"
    Set typecat=$$$getClassType(type)
    Set membercat=##class(%Compiler.XML.Generator.Adaptor).TypeToMembercat(type,typecat,.mixed)
    If membercat="" Set includeProperty=0
  }
  If includeProperty {
    If relationship {
      If (cardinality = "many") || (cardinality = "children") {
        Set membercat = "ListCollection"_membercat
      }
    } Else {
      If collection="" {
        If (membercat'="LITERAL") {
          Kill typeSeq
          Do ##class(%Compiler.XML.Generator.Adaptor).SequenceClass(type,.typeSeq)
          If $data(typeSeq("%Library.ArrayOfDataTypes")) {
            Set membercat = "ArrayCollection"
          } ElseIf $data(typeSeq("%Library.ArrayOfObjects")) {
            Set membercat = "ArrayCollection"
          } ElseIf $data(typeSeq("%Library.ListOfDataTypes")) {
            Set membercat = "ListCollection"
          } ElseIf $data(typeSeq("%Library.ListOfObjects")) {
            Set membercat = "ListCollection"
          }
          If membercat["Collection" {
            Set type=$$$comMemberKeyGet(type,$$$cCLASSparameter,"ELEMENTTYPE",$$$cPARAMdefault)
            If membercat'["OBJ",type="" Set type="%Library.String"
            If type="" {
              Set sc=$$$ERROR($$$XMLNeedElementType,property)
              Quit
            }
            Set type=$$$NormalizeClassname(type)
            Set typecat=$$$getClassType(type)
            Set membercat=membercat_##class(%Compiler.XML.Generator.Adaptor).TypeToMembercat(type,typecat,.mixed)
          }
        }
      } Else {
        if collection = $$$cPROPCOLLECTIONLIST {
          Set membercat="ListCollection"_membercat
        } ElseIf collection = $$$cPROPCOLLECTIONARRAY {
          Set membercat="ArrayCollection"_membercat
        } } } }
]]></Implementation>
</Method>

<Method name="LeftSequenceClass">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[class:%String,&seqArray]]></FormalSpec>
<Implementation><![CDATA[
  If '$data(seqArray(class)) Set seqArray(class)=$increment(seqArray)
  Set superList=$$$comClassKeyGet(class,$$$cCLASSsuper)
  Set len=$length(superList,",")
  For i=len:-1:1 {
    Set super=$piece(superList,",",i)
    If super'="" {
      Do ..LeftSequenceClass(super,.seqArray)
    }  }
  Quit
]]></Implementation>
</Method>

<Method name="GenerateMappingFromXdata">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[class:%String,&mapping]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  Set compiledclass=##class(%Dictionary.CompiledClass).%OpenId(class,,.sc)
  If $$$ISERR(sc) Quit sc
  Set count=compiledclass.XDatas.Count()
  For i=1:1:count {
    Set xdata=compiledclass.XDatas.GetAt(i)
    Set configName=xdata.Name
    If configName="" Continue
 #dim reader As %XML.Reader=##class(%XML.Reader).%New()
    Set reader.KeepWhitespace=0
    Set sc=reader.OpenStream(xdata.Data)
    If $$$ISERR(sc) Quit
 #dim document As %XML.Document=reader.Document
 #dim node As %XML.Node=document.GetDocumentElement()
    If node="" Continue
    If node.LocalName'="Mapping" Continue
    If node.Namespace'="http://www.intersystems.com/jsonmapping" {
      Set sc=$$$ERROR($$$JSONUnexpectedNamespace,node.QName,$$$mappingNameDisplay(configName))
      Quit   }
    Do reader.CorrelateRoot("%ZPM.cache.Mapping")
    If 'reader.Next(.obj,.sc) Quit
    If reader.Next(.dummy) {
      Set sc=$$$ERROR($$$JSONExtraMapping,$$$mappingNameDisplay(configName))
      Quit    }
    Set sc=..GenerateMappingFromClass(class,configName,obj,.mapping)
    If $$$ISERR(sc) Quit  }
  Quit sc
]]></Implementation>
</Method>

<Method name="GenerateMappingFromClass">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[class:%String,name:%String,obj:%ZPM.cache.Mapping,&mapping]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  kill mapping(name)
  Set jsonignoreinvalidfield=obj.IgnoreInvalidField
  Set jsondefaultmapping=obj.Mapping
  Set jsondefaultnull=''obj.Null
  Set jsondefaultignorenull=''obj.IgnoreNull
  Set jsondefaultreference=$zcvt(obj.Reference,"U")
  If jsondefaultreference="" Set jsondefaultreference="OBJECT"
  If $case(jsondefaultreference,"OBJECT":0,"ID":0,"OID":0,"GUID":0,:1) {
    Quit $$$ERROR($$$JSONInvalidDefaultParameter,"attribute reference",$$$mappingNameDisplay(name))
  }
  Set mapping(name,0)=$lb(class,jsonignoreinvalidfield)
#dim property As %ZPM.cache.MappingProperty
  Set sc=$$$OK
  For i=1:1:obj.propertyList.Count() {
    Set property=obj.propertyList.GetAt(i)
    If property="" {
      Set sc=$$$ERROR($$$JSONNoPropertyName,$$$mappingNameDisplay(name))
      Quit    }
   Set propertyName=property.Name
    If '$$$comMemberDefined(class,$$$cCLASSproperty,propertyName) {
      Set sc=$$$ERROR($$$JSONUnexpectedPropertyName,propertyName,$$$mappingNameDisplay(name))
      Quit }
    Set jsoninclude=$zcvt(property.Include,"L")
    Set includeProperty=$case(jsoninclude,"":"","inout":1,"inputonly":1,"outputonly":1,"none":1,:-1)
    If includeProperty=-1 {
      Set sc=$$$ERROR($$$JSONInvalidPropertyParameter,"attribute Include",property,$$$mappingNameDisplay(name))
      Quit    }
    Do ..GetMemberInfo(class,propertyName,.includeProperty,.type,.membercat)
    If includeProperty {
      If jsoninclude="" Set jsoninclude="inout"
      If membercat["STREAM",membercat["Array" {
        Set sc=$$$ERROR($$$JSONNoStreamArray,property,$$$mappingNameDisplay(name))
        Quit      }
      Set literaltype=""
      If membercat["CSTREAM" {
        Set literaltype="string"
      } ElseIf membercat["BSTREAM" {
        Set encoding=$$$comMemberArrayGet(class,$$$cCLASSproperty,propertyName,$$$cPROPparameter,"ENCODING")
        Set literaltype=$case($zcvt(encoding,"L"),"":"base64","base64":"base64","hex":"hex",:"")
        If literaltype="" {
          Set sc=$$$ERROR($$$XMLInvalidEncoding,encoding,property)
          Quit        }
      } ElseIf membercat["LITERAL" {
        Set literaltype=$$$comMemberKeyGet(type,$$$cCLASSparameter,"JSONTYPE",$$$cPARAMdefault)
        If literaltype="" Set literaltype="string"
        If literaltype="string",$$$comMemberKeyGet(type,$$$cCLASSparameter,"XSDTYPE",$$$cPARAMdefault)'="string" {
          Set literaltype="string/json"
        }
      }
      Set required=$$$comMemberKeyGet(class,$$$cCLASSproperty,propertyName,$$$cPROPrequired)
      Set jsonfieldname=property.FieldName
      If jsonfieldname="" Set jsonfieldname=propertyName
      Set jsonnull=property.Null
      Set jsonnull=$select(jsonnull="":jsondefaultnull,1:''jsonnull)
      If literaltype="string" {
        Set jsonignorenull=property.IgnoreNull
        Set jsonignorenull=$select(jsonignorenull="":jsondefaultignorenull,1:''jsonignorenull)
      } Else {
        Set jsonignorenull=0      }
      If membercat["OBJ" {
        Set jsonreference=$zcvt(property.Reference,"U")
        If jsonreference="" Set jsonreference=jsondefaultreference
        Set jsonreference=$case(jsonreference,
                    "OBJECT":$$$jsonrefobject,
                    "ID":$$$jsonrefid,
                    "OID":$$$jsonrefoid,
                    "GUID":$$$jsonrefguid,
                    :"")
        If jsonreference="" {
          Set sc=$$$ERROR($$$JSONInvalidPropertyParameter,"attribute Reference",property)
          Quit        }
        Set jsonmapping=property.Mapping
        If jsonmapping="" Set jsonmapping=jsondefaultmapping
      } Else {
        Set jsonreference=""      }
      Set mapping(name,$increment(mapping(name)))=
         $lb(propertyName,$$$QN(propertyName),jsoninclude,jsonfieldname,jsonnull,jsonignorenull,jsonreference,required,literaltype,membercat,type,jsonmapping)
    }
  }
  Quit sc
]]></Implementation>
</Method>

<Method name="%JSONGenerate">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%mode,%class,%property,%method,%parameter,%codemode,%code,%classmodify,%context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  Set %code=0
  If '$$$comMemberKeyGet(%class,$$$cCLASSparameter,"%JSONENABLED",$$$cPARAMdefault) Quit $$$OK
  Set abstract=$$$comClassKeyGet(%class,$$$cCLASSabstract)
  Set sc=$$$OK
  Set sc=..GenerateMapping(%class,.mapping)
  If $$$ISERR(sc) Quit sc
  Set sc=..GenerateMappingFromXdata(%class,.mapping)
  If $$$ISERR(sc) Quit sc
  If 'abstract {
    If $$$ISOK(sc) {
      Set sc=..GenerateAllImportInternal(%class,.mapping)
    }
    If $$$ISOK(sc) {
      Set sc=..GenerateAllExportInternal(%class,.mapping,1)
    }
    If $$$ISOK(sc) {
      Set sc=..GenerateAllExportInternal(%class,.mapping,0)
    }  }
  Quit sc
]]></Implementation>
</Method>

<Method name="JSONImportInternal">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%mode,%class,%property,%method,%parameter,%codemode,%code,%classmodify,%context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  Set %code=0
  If $$$comMemberKeyGet(%class,$$$cCLASSparameter,"%JSONENABLED",$$$cPARAMdefault) {
    Merge %code=$$$tEXTcode("%JSONImportInternal")
  }
  Quit $$$OK
]]></Implementation>
</Method>

<Method name="JSONExportInternal">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%mode,%class,%property,%method,%parameter,%codemode,%code,%classmodify,%context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  Set %code=0
  If $$$comMemberKeyGet(%class,$$$cCLASSparameter,"%JSONENABLED",$$$cPARAMdefault) {
    Merge %code=$$$tEXTcode("%JSONExportInternal")
  }
  Quit $$$OK
]]></Implementation>
</Method>

<Method name="JSONExportToStringInternal">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>%mode,%class,%property,%method,%parameter,%codemode,%code,%classmodify,%context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  Set %code=0
  If $$$comMemberKeyGet(%class,$$$cCLASSparameter,"%JSONENABLED",$$$cPARAMdefault) {
    Merge %code=$$$tEXTcode("%JSONExportToStringInternal")
  }
  Quit $$$OK
]]></Implementation>
</Method>

<Method name="JSONNew">
<ClassMethod>1</ClassMethod>
<FormalSpec>%mode,%class,%property,%method,%parameter,%codemode,%code,%classmodify,%context</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  Set %code=0
  If $$$comMemberKeyGet(%class,$$$cCLASSparameter,"%JSONENABLED",$$$cPARAMdefault) {
    $$$GENERATE("  Quit ##class("_%class_").%New()")
  }
  Quit $$$OK
]]></Implementation>
</Method>

<Method name="GenerateAllImportInternal">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[class:%String,&mapping:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  New %code
  Set %code=0
  Set sc=$$$OK
  
  Try {
    $$$GENERATE("  Set sc=$$$OK")
    Set needTestInvalidField=0
    Set needRequired=0
    Set indent=""
    Set mappingName=$c(1)
    Set count=0
    For {
      Set mappingName=$order(mapping(mappingName))
      If mappingName="" Quit
      $$$GENERATE("  "_$select(count=0:"If",1:"} ElseIf")_" %mappingName="""_mappingName_""" {")
      Set count=count+1
      Set indent="  "
      Set sc=..GenerateImportInternal(class,indent,mappingName,.mapping,.needRequired,.needTestInvalidField)
      If $$$ISERR(sc) Quit
    }
    If $$$ISERR(sc) Quit
    If count>0 $$$GENERATE("  } Else {")
    Set sc=..GenerateImportInternal(class,indent,$c(1),.mapping,.needRequired,.needTestInvalidField)
    If $$$ISERR(sc) Quit
    If count>0 $$$GENERATE("  }")
    If needTestInvalidField {
      $$$GENERATE("  If $get(testInvalidField) {")
      $$$GENERATE("    Set invalid=0,iterator=%JSONObject.%GetIterator()")
      $$$GENERATE("    While iterator.%GetNext(.key,.value) { If $data(proplist(key))=0 Set invalid=1 Quit  }")
      $$$GENERATE("    If invalid Quit $$$ERROR($$$JSONImportBadField,key,$$$mappingNameDisplay(%mappingName))")
      $$$GENERATE("  }")
    }
    $$$GENERATE("%JSONImportExit Quit sc")
    $$$GENERATE("%JSONImportError Quit $$$ERROR($$$JSONImportError,field,$$$mappingNameDisplay(%mappingName))")
    If needRequired $$$GENERATE("%JSONImportRequired Quit $$$ERROR($$$JSONImportRequired,field,$$$mappingNameDisplay(%mappingName))")
    Merge $$$tEXTcode("%JSONImportInternal")=%code
  } Catch ex {
    Set sc=ex.AsStatus()
  }
  Quit sc
]]></Implementation>
</Method>

<Method name="GenerateImportInternal">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[class:%String,indent:%String,mappingName:%String,&mapping:%String,&needRequired:%Boolean,&needTestInvalidField:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  Set sc=$$$OK
  Set ignoreInvalidField=$$$jsonignoreinvalidfield(mapping,mappingName)
  If 'ignoreInvalidField {
    Set needTestInvalidField=1
    $$$GENERATE(indent_"  Set testInvalidField=1")
  }
  For index=1:1:$$$jsonpropertycount(mapping,mappingName) {
    Set propertyMap=$$$jsongetprop(mapping,mappingName,index)
    Set fieldname=$replace($$$jsonfieldname(propertyMap),"""","""""")
    If 'ignoreInvalidField {
      $$$GENERATE(indent_"  Set proplist("""_fieldname_""")=""""")
    }
    If $$$jsoninclude(propertyMap)'["in" Continue
    $$$GENERATE(indent_"  Set field="""_fieldname_""" Set jsontype=$$$JSONGetTypeOf(%JSONObject,field)")
    $$$GENERATE(indent_"  If jsontype'=""unassigned"" {")
    $$$GENERATE(indent_"    If jsontype=""null"" {")
    If $$$jsonrequired(propertyMap) {
      $$$GENERATE(indent_"      Goto %JSONImportRequired")
    } Else {
      $$$GENERATE(indent_"      Set .."_$$$jsonpropertyQN(propertyMap)_"=""""")
    }
    $$$GENERATE(indent_"    } Else {")
    Set membercat=$$$jsonmembercat(propertyMap)
    If membercat["Collection" {
      // Generate code to import collections
      If membercat["List" {
        // Generate code to import lists
        Do ..GenImportList(class,propertyMap,indent_"    ")
      } Else {
        // Generate code to import arrays
        Do ..GenImportArray(class,propertyMap,indent_"    ")
      }
    } Else {
      // Generate code to import this non-collection field
      Do ..GenImportField(class,propertyMap,indent_"    ",0)
    }
    If $$$jsonrequired(propertyMap) {
      $$$GENERATE(indent_"  } Else { Goto %JSONImportRequired }")
      Set needRequired=1
    } Else {
      $$$GENERATE(indent_"  }")
    }
  }
  Quit sc
]]></Implementation>
</Method>

<Method name="GenImportList">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  $$$GENERATE(indent_"  If jsontype'=""array"" Goto %JSONImportError")
  $$$GENERATE(indent_"  Set data=%JSONObject."_$$$QN($$$jsonfieldname(propertyMap)))
  $$$GENERATE(indent_"  For index=0:1:data.%Size()-1 {")
  $$$GENERATE(indent_"    Set jsontype=$$$JSONGetTypeOf(data,index)")
  $$$GENERATE(indent_"    If jsontype=""null"" {")
  $$$GENERATE(indent_"      Do .."_$$$jsonpropertyQN(propertyMap)_".Insert("""")")
  $$$GENERATE(indent_"    } Else {")
  $$$GENERATE(indent_"      Set value=data.%Get(index)")
  Do ..GenImportField(class,propertyMap,indent_"    ",$$$isCollectionList)
  $$$GENERATE(indent_"  }}")
]]></Implementation>
</Method>

<Method name="GenImportArray">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  $$$GENERATE(indent_"  If jsontype'=""object"" Goto %JSONImportError")
  $$$GENERATE(indent_"  Set data=%JSONObject."_$$$QN($$$jsonfieldname(propertyMap)))
  $$$GENERATE(indent_"  Set iterator=data.%GetIterator()")
  $$$GENERATE(indent_"  While iterator.%GetNext(.index,.value) {")
  $$$GENERATE(indent_"    Set jsontype=$$$JSONGetTypeOf(data,index)")
  $$$GENERATE(indent_"    If jsontype=""null"" {")
  $$$GENERATE(indent_"      Do .."_$$$jsonpropertyQN(propertyMap)_".SetAt("""",index)")
  $$$GENERATE(indent_"    } Else {")
  Do ..GenImportField(class,propertyMap,indent_"    ",$$$isCollectionArray)
  $$$GENERATE(indent_"  }}")
]]></Implementation>
</Method>

<Method name="GenImportField">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String,isCollectionValue:%Integer</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  Set membercat=$$$jsonmembercat(propertyMap)
  If membercat["OBJ" {
    Set reference=$$$jsonreference(propertyMap)
    If reference=$$$jsonrefid {
      Do ..GenImportID(class,propertyMap,indent,isCollectionValue)
    } ElseIf reference=$$$jsonrefoid {
      Do ..GenImportOID(class,propertyMap,indent,isCollectionValue)
    } ElseIf reference=$$$jsonrefguid {
      Do ..GenImportGUID(class,propertyMap,indent,isCollectionValue)
    } Else {
      Do ..GenImportObject(class,propertyMap,indent,isCollectionValue)
    }
  } ElseIf membercat["STREAM" {
    If membercat="BSTREAM" {
      Do ..GenImportBinaryStream(class,propertyMap,indent,isCollectionValue)
    } Else {
      Do ..GenImportCharacterStream(class,propertyMap,indent,isCollectionValue)
    }
  } Else {
    Do ..GenImportLiteral(class,propertyMap,indent,isCollectionValue)
  }
  $$$GENERATE(indent_"}")
]]></Implementation>
</Method>

<Method name="GenImportID">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
  $$$GENERATE(indent_"  If jsontype'=""string"",jsontype'=""number"" Goto %JSONImportError")
  If isCollectionValue {
    Set indexarg=$select(isCollectionValue=$$$isCollectionList:"index+1",1:"index")
    $$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".SetObjectIdAt(value,"_indexarg_")")
  } Else {
    $$$GENERATE(indent_"  Do .."_$$$QN($$$jsonproperty(propertyMap)_"SetObjectId")_"(%JSONObject."_$$$QN($$$jsonfieldname(propertyMap))_")")
  }
]]></Implementation>
</Method>

<Method name="GenImportOID">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
  $$$GENERATE(indent_"  If jsontype'=""string"" Goto %JSONImportError")
  Set var=$select(isCollectionValue:"value",1:"data")
  Set exp="$lb($piece("_var_","","",2,*),$piece("_var_","","",1))"
  If isCollectionValue {
    Set indexarg=$select(isCollectionValue=$$$isCollectionList:"index+1",1:"index")
    $$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".SetObjectAt("_exp_","_indexarg_")")
  } Else {
    $$$GENERATE(indent_"  Set data=%JSONObject."_$$$QN($$$jsonfieldname(propertyMap)))
    $$$GENERATE(indent_"  Do .."_$$$QN($$$jsonproperty(propertyMap)_"SetObject")_"("_exp_")")
  }
]]></Implementation>
</Method>

<Method name="GenImportGUID">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
  $$$GENERATE(indent_"  If jsontype'=""string"" Goto %JSONImportError")
  If isCollectionValue {
    Set indexarg=$select(isCollectionValue=$$$isCollectionList:"index+1",1:"index")
    $$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".SetObjectAt(##class(%Library.GUID).%GUIDFind(value),"_indexarg_")")
  } Else {
    $$$GENERATE(indent_"  Do .."_$$$QN($$$jsonproperty(propertyMap)_"SetObject")_"(##class(%Library.GUID).%GUIDFind(%JSONObject."_$$$QN($$$jsonfieldname(propertyMap))_"))")
  }
]]></Implementation>
</Method>

<Method name="GenImportObject">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
  Set mappingName=$$$jsonmapping(propertyMap)
  $$$GENERATE(indent_"  If jsontype=""object"" {")
  $$$GENERATE(indent_"    Set newobj=##class("_$$$jsontype(propertyMap)_").%JSONNew(%JSONObject,$this)")
  $$$GENERATE(indent_"    Set saveJSON=%JSONObject")
  If mappingName'="" {
    $$$GENERATE(indent_"    Set saveMapping=%mappingName,%mappingName="""_mappingName_"""")
  }
  $$$GENERATE(indent_"    Set %JSONObject="_$select(isCollectionValue:"value",1:"%JSONObject."_$$$QN($$$jsonfieldname(propertyMap))))
  $$$GENERATE(indent_"    Set sc=newobj.%JSONImportInternal()")
  $$$GENERATE(indent_"    Set %JSONObject=saveJSON")
  If mappingName'="" {
    $$$GENERATE(indent_"    Set %mappingName=saveMapping")
  }
  $$$GENERATE(indent_"    If $$$ISERR(sc) Goto %JSONImportExit")
  If isCollectionValue=$$$isCollectionList {
    $$$GENERATE(indent_"    Do .."_$$$jsonpropertyQN(propertyMap)_".Insert(newobj)")
  } ElseIf isCollectionValue=$$$isCollectionArray {
    $$$GENERATE(indent_"    Do .."_$$$jsonpropertyQN(propertyMap)_".SetAt(newobj,index)")
  } Else {
    $$$GENERATE(indent_"    Set .."_$$$jsonpropertyQN(propertyMap)_"=newobj")
  }
  $$$GENERATE(indent_"  } ElseIf jsontype=""oref"" {")
  If isCollectionValue=$$$isCollectionList {
    $$$GENERATE(indent_"    Do .."_$$$jsonpropertyQN(propertyMap)_".Insert(value)")
  } ElseIf isCollectionValue=$$$isCollectionArray {
    $$$GENERATE(indent_"    Do .."_$$$jsonpropertyQN(propertyMap)_".SetAt(value,index)")
  } Else {
    $$$GENERATE(indent_"    Set .."_$$$jsonpropertyQN(propertyMap)_"=%JSONObject."_$$$QN($$$jsonfieldname(propertyMap)))
  }
  $$$GENERATE(indent_"  } Else { Goto %JSONImportError }")
]]></Implementation>
</Method>

<Method name="GenImportBinaryStream">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
  Set property=$$$jsonproperty(propertyMap)
  $$$GENERATE(indent_"  If jsontype'=""string"" Goto %JSONImportError")
  If isCollectionValue {
    Set indexarg=$select(isCollectionValue=$$$isCollectionList:"index+1",1:"index")
    $$$GENERATE(indent_"  Set stream=..##class("_$$$jsontype(propertyMap)_").%New()")
    If $$$jsonliteraltype(propertyMap)["hex" {
      $$$GENERATE(indent_"  For i=1:2:$length(value) {")
      $$$GENERATE(indent_"    Set bin=bin_$char($zhex($extract(value,i,i+1)))")
      $$$GENERATE(indent_"  }")
      $$$GENERATE(indent_"  Set sc=stream.Write(value) If $$$ISERR(sc) Goto %JSONImportExit")
    } Else {
      $$$GENERATE(indent_"  Set sc=stream.Write($system.Encryption.Base64Decode(value)) If $$$ISERR(sc) Goto %JSONImportExit")
    }
    If isCollectionValue=$$$isCollectionList {
      $$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".Insert(stream)")
    } Else {
      $$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".SetAt(stream,index)")
    }
  } Else {
    $$$GENERATE(indent_"  Set stream=.."_$$$jsonpropertyQN(propertyMap)_" Do stream.Rewind()")
    If $$$jsonliteraltype(propertyMap)["hex" {
      $$$GENERATE(indent_"  Set value=%JSONObject."_$$$QN($$$jsonfieldname(propertyMap))_",bin=""""")
      $$$GENERATE(indent_"  For i=1:2:$length(value) {")
      $$$GENERATE(indent_"    Set bin=bin_$char($zhex($extract(value,i,i+1)))")
      $$$GENERATE(indent_"  }")
      $$$GENERATE(indent_"  Set sc=stream.Write(bin) If $$$ISERR(sc) Goto %JSONImportExit")
    } Else {
      $$$GENERATE(indent_"  Set sc=stream.Write($system.Encryption.Base64Decode(%JSONObject."_$$$QN($$$jsonfieldname(propertyMap))_")) If $$$ISERR(sc) Goto %JSONImportExit")
    }
  }
]]></Implementation>
</Method>

<Method name="GenImportCharacterStream">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
  Set property=$$$jsonproperty(propertyMap)
  $$$GENERATE(indent_"  If jsontype'=""string"" Goto %JSONImportError")
  If isCollectionValue {
    Set indexarg=$select(isCollectionValue=$$$isCollectionList:"index+1",1:"index")
    $$$GENERATE(indent_"  Set stream=..##class("_$$$jsontype(propertyMap)_").%New()")
    $$$GENERATE(indent_"  Set sc=stream.Write(value) If $$$ISERR(sc) Goto %JSONImportExit")
    If isCollectionValue=$$$isCollectionList {
      $$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".Insert(stream)")
    } Else {
      $$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".SetAt(stream,index)")
    }
  } Else {
    $$$GENERATE(indent_"  Set stream=.."_$$$jsonpropertyQN(propertyMap)_" Do stream.Rewind()")
    $$$GENERATE(indent_"  Set sc=stream.Write(%JSONObject."_$$$QN($$$jsonfieldname(propertyMap))_") If $$$ISERR(sc) Goto %JSONImportExit")
  }
]]></Implementation>
</Method>

<Method name="GenImportLiteral">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
  Set property=$$$jsonproperty(propertyMap)
  Set type=$$$jsontype(propertyMap)
  Set literaltype=$$$jsonliteraltype(propertyMap)
  If literaltype="double" {
    $$$GENERATE(indent_"  If jsontype'=""number"",jsontype'=""string"" Goto %JSONImportError")
  } Else {
    $$$GENERATE(indent_"  If jsontype'="""_$piece(literaltype,"/",1)_""" Goto %JSONImportError")
  }
  If isCollectionValue {
    Set var="value"
  } Else {
    Set var="data"
  }
  Set useProperty='isCollectionValue
  If literaltype'="boolean" { 
    Do ##class(%Compiler.XML.Generator.Adaptor).getPropertyParameters(class,property,.parms)
    Set haveJSONToLogical=##class(%Compiler.XML.Generator.Adaptor).getSingleLine(class,property,type,"JSONToLogical",.parms,var,.codeJSONToLogical)
    If 'haveJSONToLogical {
      Set haveJSONToLogical=##class(%Compiler.XML.Generator.Adaptor).getSingleLine(class,property,type,"XSDToLogical",.parms,var,.codeJSONToLogical)
    }
    Set haveIsValid=##class(%Compiler.XML.Generator.Adaptor).getSingleLine(class,property,type,"IsValid",.parms,var,.codeIsValid)
    Set line=""
    If haveJSONToLogical {
      Set line=line_" Set "_var_"="_codeJSONToLogical_" Goto:"_var_"="""" %JSONImportError"
    }
    If haveIsValid {
      Set line=line_" If $$$ISERR("_codeIsValid_") Goto %JSONImportError"
    }
    If line'="" {
      If useProperty {
        Set useProperty=0
        $$$GENERATE(indent_"  Set data=%JSONObject."_$$$QN($$$jsonfieldname(propertyMap)))
      }
      $$$GENERATE(indent_" "_line)
    }
    If literaltype="string",'$$$jsonignorenull(propertyMap) {
      If useProperty {
        Set useProperty=0
        $$$GENERATE(indent_"  Set data=%JSONObject."_$$$QN($$$jsonfieldname(propertyMap)))
      }
      $$$GENERATE(indent_"  If "_var_"="""" Set "_var_"=$c(0)")
    }
  }
  If isCollectionValue=$$$isCollectionList {
    $$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".Insert("_var_")")
  } ElseIf isCollectionValue=$$$isCollectionArray {
    $$$GENERATE(indent_"  Do .."_$$$jsonpropertyQN(propertyMap)_".SetAt("_var_",index)")
  } Else {
    If useProperty Set var="%JSONObject."_$$$QN($$$jsonfieldname(propertyMap))
    $$$GENERATE(indent_"  Set .."_$$$jsonpropertyQN(propertyMap)_"="_var)
  }
]]></Implementation>
</Method>

<Method name="GenerateAllExportInternal">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[class:%String,&mapping:%String,useWrite:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  New %code,%outputCode,%exitCode,%objectCode
  Set %code=0
  Set sc=$$$OK
  Try {
    If useWrite {
      Set %outputCode="Write "
      Set %exitCode="%JSONExportExit"
      Set %objectCode="%JSONExportInternal"
    } Else {
      Set %outputCode="Set %export=%export_"
      Set %exitCode="%JSONExportExitToString"
      Set %objectCode="%JSONExportToStringInternal"
    }
    $$$GENERATE("  Set sc=$$$OK")
    $$$GENERATE("  "_%outputCode_"""{"" Set sep=""""")
    Set indent=""
    Set mappingName=$c(1)
    Set count=0
    For {
      Set mappingName=$order(mapping(mappingName))
      If mappingName="" Quit
      $$$GENERATE("  "_$select(count=0:"If",1:"} ElseIf")_" %mappingName="""_mappingName_""" {")
      Set count=count+1
      Set indent="  "
      Set sc=..GenerateExportInternal(class,indent,mappingName,.mapping)
      If $$$ISERR(sc) Quit
    }
    If $$$ISERR(sc) Quit
    If count>0 $$$GENERATE("  } Else {")
    Set sc=..GenerateExportInternal(class,indent,$c(1),.mapping)
    If $$$ISERR(sc) Quit
    If count>0 $$$GENERATE("  }")
    $$$GENERATE("  "_%outputCode_"""}""")
    $$$GENERATE(%exitCode_" Quit sc")
    Merge $$$tEXTcode("%JSONExport"_$select(useWrite:"",1:"ToString")_"Internal")=%code
  } Catch ex {
    Set sc=ex.AsStatus()
  }
  Quit sc
]]></Implementation>
</Method>

<Method name="GenerateExportInternal">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[class:%String,indent:%String,mappingName:%String,&mapping:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  Set sc=$$$OK
  For index=1:1:$$$jsonpropertycount(mapping,mappingName) {
    Set propertyMap=$$$jsongetprop(mapping,mappingName,index)
    Set fieldname=$$$jsonfieldname(propertyMap)
    If $$$jsoninclude(propertyMap)'["out" Continue
    Set membercat=$$$jsonmembercat(propertyMap)
    If membercat["Collection" {
      $$$GENERATE("    Set aval=.."_$$$jsonpropertyQN(propertyMap))
      If membercat["List" {
        Do ..GenExportList(class,propertyMap,indent)
      } Else {
        Do ..GenExportArray(class,propertyMap,indent)
      }
    } Else {
      $$$GENERATE(indent_"  Set value=.."_$$$jsonpropertyQN(propertyMap))
      Do ..GenExportField(class,propertyMap,fieldname,indent,0)
    }  }
  Quit sc
]]></Implementation>
</Method>

<Method name="GenExportList">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  Set jsonreference=$$$jsonreference(propertyMap) 
  If jsonreference=$$$jsonrefoid {
    Set nextFunction="GetObjectNext"
  } ElseIf jsonreference=$$$jsonrefguid {
    Set nextFunction="GetNext"
  } ElseIf jsonreference=$$$jsonrefid {
    Set nextFunction="GetObjectIdNext"
  } Else {
    Set nextFunction="GetNext"
  }
  $$$GENERATE(indent_"  If aval.Count()>0 {")
  Do ..GenWriteField($$$jsonfieldname(propertyMap),indent_"  ","")
  $$$GENERATE(indent_"    Set sep=""[""")
  $$$GENERATE(indent_"    Set k="""" For {")
  $$$GENERATE(indent_"      Set value=aval."_nextFunction_"(.k) If k="""" Quit")
  Do ..GenExportField(class,propertyMap,"","      ",$$$isCollectionList)
  $$$GENERATE(indent_"    }")
    $$$GENERATE(indent_"    "_%outputCode_"""]""")
    $$$GENERATE(indent_"  }")
]]></Implementation>
</Method>

<Method name="GenExportArray">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,indent:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  Set jsonreference=$$$jsonreference(propertyMap)
  If jsonreference=$$$jsonrefoid {
    Set nextFunction="GetObjectNext"
  } ElseIf jsonreference=$$$jsonrefguid {
    Set nextFunction="GetNext"
  } ElseIf jsonreference=$$$jsonrefid {
    Set nextFunction="GetObjectIdNext"
  } Else {
    Set nextFunction="GetNext"
  }
  $$$GENERATE(indent_"  If aval.Count()>0 {")
  Do ..GenWriteField($$$jsonfieldname(propertyMap),indent_"  ","")
  $$$GENERATE(indent_"    Set sep=""{""")
  $$$GENERATE(indent_"    Set aval=.."_$$$jsonpropertyQN(propertyMap)_",k=""""")
  $$$GENERATE(indent_"    For {")
  $$$GENERATE(indent_"      Set value=aval."_nextFunction_"(.k) If k="""" Quit")
  Do ..GenExportField(class,propertyMap,$c(1)_"k",indent_"    ",$$$isCollectionArray)
  $$$GENERATE(indent_"    }")
    $$$GENERATE(indent_"    "_%outputCode_"""}""")
    $$$GENERATE(indent_"  }")
]]></Implementation>
</Method>

<Method name="GenExportField">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,fieldName:%String,indent:%String,isCollectionValue:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  Set needClosingBrace=1
  Set membercat=$$$jsonmembercat(propertyMap)
  If membercat["OBJ" {
    Set serialTest=$select(membercat["SERIAL":"&&'value.%IsNull()",1:"")
    $$$GENERATE(indent_"  If value'="""""_serialTest_" {")
    Set indent=indent_"  "
    Set reference=$$$jsonreference(propertyMap)
    If reference=$$$jsonrefid {
      Do ..GenExportID(class,propertyMap,fieldName,indent,isCollectionValue)
    } ElseIf reference=$$$jsonrefoid {
      Do ..GenExportOID(class,propertyMap,fieldName,indent,isCollectionValue)
    } ElseIf reference=$$$jsonrefguid {
      Do ..GenExportGUID(class,propertyMap,fieldName,indent,isCollectionValue)
    } Else {
      Do ..GenExportObject(class,propertyMap,fieldName,indent,isCollectionValue)
    }
  } ElseIf membercat["STREAM" {
    If $$$jsonliteraltype(propertyMap)="string",$$$jsonignorenull(propertyMap) {
      Set needClosingBrace=0
    } Else {
      $$$GENERATE(indent_"  If (value'="""")&&'value.IsNull() {")
      Set indent=indent_"  "
    }
    If membercat="BSTREAM" {
      Do ..GenExportBinaryStream(class,propertyMap,fieldName,indent,isCollectionValue)
    } Else {
      Do ..GenExportCharacterStream(class,propertyMap,fieldName,indent,isCollectionValue)
    }

  } Else {
    If $$$jsonliteraltype(propertyMap)="string",$$$jsonignorenull(propertyMap) {
      Set needClosingBrace=0
    } Else {
      $$$GENERATE(indent_"  If value'="""" {")
      Set indent=indent_"  "
    }
    Do ..GenExportLiteral(class,propertyMap,fieldName,indent,isCollectionValue)
  }
    If needClosingBrace {
    If isCollectionValue || ($$$jsonnull(propertyMap) && '$$$jsonignorenull(propertyMap)) {
      $$$GENERATE(indent_"} Else {")
      Do ..GenWriteField(fieldName,indent,"""null""")
        $$$GENERATE(indent_"}")
        $$$GENERATE(indent_"Set $extract(sep,1)="",""")
    } Else {
        $$$GENERATE(indent_"  Set $extract(sep,1)="",""")
        $$$GENERATE(indent_"}")
    }
  } Else {
      $$$GENERATE(indent_"  Set $extract(sep,1)="",""")
  }
]]></Implementation>
</Method>

<Method name="GenExportID">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,fieldName:%String,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
  If isCollectionValue {
    Do ..GenWriteField(fieldName,indent,"""""""""_$zcvt(value,""O"",""JSON"")_""""""""")
  } Else {
    Do ..GenWriteField(fieldName,indent,"""""""""_$zcvt(value.%Id(),""O"",""JSON"")_""""""""")
  }
]]></Implementation>
</Method>

<Method name="GenExportOID">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,fieldName:%String,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
 If isCollectionValue {
    Do ..GenWriteField(fieldName,indent,"""""""""_$select($listget(value,2)="""":$listget(aval.GetAt(k).%Oid(),2),1:$listget(value,2))_"",""_$listget(value)_""""""""")
  } Else {
    Do ..GenWriteField(fieldName,indent,"""""""""_$listget(value.%Oid(),2)_"",""_$listget(value.%Oid())_""""""""")
  }
]]></Implementation>
</Method>

<Method name="GenExportGUID">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,fieldName:%String,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[  Do ..GenWriteField(fieldName,indent,"""""""""_value.%GUID(value.%Oid())_""""""""")
]]></Implementation>
</Method>

<Method name="GenExportObject">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,fieldName:%String,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
  Set mappingName=$$$jsonmapping(propertyMap)
  If mappingName'="" {
    $$$GENERATE(indent_"  Set saveMapping=%mappingName,%mappingName="""_mappingName_"""")
  }
  Do ..GenWriteField(fieldName,indent,"")
  $$$GENERATE(indent_"  Set sc=value."_%objectCode_"() If $$$ISERR(sc) Goto "_%exitCode)
  If mappingName'="" {
    $$$GENERATE(indent_"  Set %mappingName=saveMapping")
  }
]]></Implementation>
</Method>

<Method name="GenExportBinaryStream">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,fieldName:%String,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
  Do ..GenWriteField(fieldName,indent,"")
  If $$$jsonliteraltype(propertyMap)["hex" {
    $$$GENERATE(indent_"  "_%outputCode_""""""""" Do value.Rewind() If value.Size>0 { While 'value.AtEnd { ")
    $$$GENERATE(indent_"    Set first=value.Read(.len,.sc) If $$$ISERR(sc) Goto "_%exitCode)
      $$$GENERATE(indent_"    For k=1:1:$length(first) {"_%outputCode_"$select($ascii(first,k)<16:""0"",1:"""")_$zhex($ascii(first,k)) }")
    $$$GENERATE(indent_"  }} "_%outputCode_"""""""""")
  } Else {
    $$$GENERATE(indent_"  "_%outputCode_""""""""" Do value.Rewind() If value.Size>0 { While 'value.AtEnd { "_%outputCode_"$system.Encryption.Base64Encode(value.Read(,.sc),1) If $$$ISERR(sc) Goto "_%exitCode_" }} "_%outputCode_"""""""""")
  }
]]></Implementation>
</Method>

<Method name="GenExportCharacterStream">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,fieldName:%String,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
  Do ..GenWriteField(fieldName,indent,"")
  $$$GENERATE(indent_"  "_%outputCode_""""""""" Do value.Rewind() If value.Size>0 { While 'value.AtEnd { "_%outputCode_"$zcvt(value.Read(,.sc),""O"",""JSON"") If $$$ISERR(sc) Goto "_%exitCode_" }} "_%outputCode_"""""""""")
]]></Implementation>
</Method>

<Method name="GenExportLiteral">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>class:%String,propertyMap:%List,fieldName:%String,indent:%String,isCollectionValue:%Integer</FormalSpec>
<Implementation><![CDATA[
  Set property=$$$jsonproperty(propertyMap)
  Set type=$$$jsontype(propertyMap)
  Do ##class(%Compiler.XML.Generator.Adaptor).getPropertyParameters(class,property,.parms)
  Set haveLogicalToJSON=##class(%Compiler.XML.Generator.Adaptor).getSingleLine(class,property,type,"LogicalToJSON",.parms,"value",.codeLogicalToJSON)
  If 'haveLogicalToJSON {
    Set haveLogicalToJSON=##class(%Compiler.XML.Generator.Adaptor).getSingleLine(class,property,type,"LogicalToXSD",.parms,"value",.codeLogicalToJSON)
  }
  If 'haveLogicalToJSON Set codeLogicalToJSON="value"
  Set literaltype=$$$jsonliteraltype(propertyMap)
  If $piece(literaltype,"/",1)="string" {
    If literaltype="string" {
      Set codeLogicalToJSON="$select("_$select($$$jsonignorenull(propertyMap):"(value="""""""")||",1:"")_"(value=$c(0)):"""",1:$zcvt("_codeLogicalToJSON_",""O"",""JSON""))"
    }
    Set codeLogicalToJSON="""""""""_"_codeLogicalToJSON_"_"""""""""
  } ElseIf literaltype="boolean" {
    Set codeLogicalToJSON="$select(value:""true"",1:""false"")"
  }
  Do ..GenWriteField(fieldName,indent,codeLogicalToJSON)
]]></Implementation>
</Method>

<Method name="GenWriteField">
<ClassMethod>1</ClassMethod>
<FormalSpec>fieldName:%String,indent:%String,valueText:%String</FormalSpec>
<Implementation><![CDATA[
  If fieldName'="" {
    If $extract(fieldName,1)=$c(1) {
      Set field="""_"_$replace($zcvt($extract(fieldName,2,*),"O","JSON"),"""","""""")_"_"""
    } Else {
      set field=$replace($zcvt(fieldName,"O","JSON"),"""","""""")
    }
    If valueText'="" {
      $$$GENERATE(indent_"  "_%outputCode_"sep_"_""""""""_field_""""""_$select($extract(valueText,1)="""":":"_$extract(valueText,2,*),1:":""_"_valueText))
    } Else {
      $$$GENERATE(indent_"  "_%outputCode_"sep_"_""""""""_field_""""":""")
    }
  } Else {
    $$$GENERATE(indent_"  "_%outputCode_"sep"_$select(valueText="":"",1:"_")_valueText)
  }
]]></Implementation>
</Method>
</Class>


<Routine name="%ZPM.cache" type="INC"><![CDATA[
#;  %ZPM.cache.inc   ; by rcc for Cach
#define FileTempDir ##class(%File).NormalizeDirectory(##class(%SYS.System).TempDirectory()_"/"_##class(%PopulateUtils).StringMin(8,8))
#define PVTYPEARRAY          157         
#define PVTYPEOBJECT         158
#define PVTYPECHAR           159
#define PVTYPEBINARY         160
#define PVTYPESTREAM         161
#define PVBUFCHAR            1
#define PVBUFBYTE            2
#define PVBUFBASE64          3
#define PVVALUENULL          0
#define PVVALUETRUE          1
#define PVVALUEFALSE         2
#define PVVALUEINTEGERPOS    3
#define PVVALUEINTEGERNEG    4
#define PVVALUEUNUSED1       5
#define PVVALUEARRAY         6
#define PVVALUEOBJECT        7
#define PVVALUETEXT          8
#define PVVALUENUMBER        9
#define PVVALUEOVERFLOW      10
#define PVVALUECACHENUMERIC  11
#define PVVALUEOREF          12
#define PVVALUEUNASSIGNED    13
#define PVVALUELONGPOS       14
#define PVVALUELONGNEG       15
#define PVVALUEBYTE          16
#define PVVALUEDATETIME      17
#define PVVALUEDOUBLE        18
#define PVVALUESINGLE        19
#define PVVALUEUTF8          20
#define PVVALUENESTED        21
#define PVVALUEEOF           31
#define JSONGetTypeOf(%object,%key) $CASE(%object.%GetTypeCodeOf(%key),$$$PVVALUENULL:"null",$$$PVVALUETRUE:"boolean",$$$PVVALUEFALSE:"boolean",$$$PVVALUEINTEGERPOS:"number",$$$PVVALUEINTEGERNEG:"number",$$$PVVALUEARRAY:"array",$$$PVVALUEOBJECT:"object",$$$PVVALUETEXT:"string",$$$PVVALUENUMBER:"number",$$$PVVALUEOVERFLOW:"illegalvalue",$$$PVVALUECACHENUMERIC:"number",$$$PVVALUEOREF:"oref",$$$PVVALUEUNASSIGNED:"unassigned",$$$PVVALUELONGPOS:"number",$$$PVVALUELONGNEG:"number",$$$PVVALUEBYTE:"string",$$$PVVALUEDOUBLE:"number",$$$PVVALUESINGLE:"number",$$$PVVALUEUTF8:"string",$$$PVVALUEEOF:"unassigned",:"UNKNOWN")
#define JSONERROROKAY           1
#define JSONERRORNOSTRING       2
#define JSONERRORPARSEFAIL      3
#define JSONERRORINTERNALERROR  4
#define JSONERRORNOMEMORY       5
#define JSONERRORINVALIDHEX     6
#define JSONERROROVERFLOWHEX    7
#define JSONERRORINVALIDESCAPE  8
#define JSONERRORMAXNUMBERC     9
#define JSONERRORREADERROR      10
#define JSONERRORMAXDEPTH       11
#define JSONERRORUNEXPECTEDEOF  12
#define JSONERRORDUPLICATEKEY   13
#define JSONERRORCACHEKERNEL    14
#define JSONERRORMETADATA       15
#define JSONERRORCORRUPTSTRUCTURE     16
#define JSONERRORINVALIDZUARGS        17
#define JSONERRORMAXSIZE        18
#define PVSSize     40
#define PVSReadBuf    41
#define PVSstreamPVO    42
#define PVSstringBuf    43
#define PVSWriteBuf   44
#define jsonclass(%map,%name)               $listget(%map(%name,0),1)
#define jsonignoreinvalidfield(%map,%name)  $listget(%map(%name,0),2)
#define jsonpropertycount(%map,%name)       $get(%map(%name))
#define jsongetprop(%map,%name,%idx)        $get(%map(%name,%idx))
#define jsonproperty(%node)     $list(%node,1)
#define jsonpropertyQN(%node)   $list(%node,2)
#define jsoninclude(%node)      $list(%node,3)
#define jsonfieldname(%node)    $list(%node,4)
#define jsonnull(%node)         $list(%node,5)
#define jsonignorenull(%node)   $list(%node,6)
#define jsonrefobject    1
#define jsonrefid        2
#define jsonrefoid       3
#define jsonrefguid      4
#define jsonreference(%node)    $list(%node,7)
#define jsonrequired(%node)     $list(%node,8)
#define jsonliteraltype(%node)  $list(%node,9)
#define jsonmembercat(%node)    $list(%node,10)
#define jsontype(%node)         $list(%node,11)
#define jsonmapping(%node)      $list(%node,12)
#define isCollectionList   1
#define isCollectionArray  2
#define mappingNameDisplay(%name)  $select(%name="":"class base",1:%name)
#define VolExists                                1
#define MapBlockReadFailed                       2
#define ErrWritingMapBlock                       3
#define CannotReadGloDirMapBlk                   4
#define CannotWriteGloDirMapBlk                  5
#define CannotWriteGloDirBlk                     6
#define CannotOpenNextVolume                     13
#define CannotReadNextVolMapBlk                  14
#define DirectoryNameTooLong                     15
#define NumMapsInvalid                           16
#define DatabaseSizeOutOfRange                   17
#define FailedToCreateNewVol                     18
#define AlreadyMounted                           19
#define FileExists                               20
#define FileCreateInProgress                     21
#define CurrentNumMapsTooSmall                   22
#define CannotExpandFile                         23
#define FileClusterMounted                       24
#define CannotAllocateCFN                        25
#define IncompatibleMountReq                     26
#define MgrCannotBeClusterMnt                    27
#define DatabaseInTransition                     28
#define SystemNotPartOfCluster                   30
#define CannotChangeModeOfMntDB                  31
#define NotSpaceForNewVol                        32
#define VolOverSysFileSizeLimit                  33
#define UnkErrWritingToNewVol                    34
#define DatabaseExpanding                        35
#define DatabaseNotMountable                     36
#define DBMountedElsewhere                       37
#define NoRoomInSecVolTable                      38
#define VolIsReadonly                            39
#define NoDeleteClusterMntDB                     40
#define DirectoryNotFound                        41
#define DatabaseNameInvalid                      42
#define WDFailedToSetRWFlag                      43
#define ExpansionFailedToStart                   44
#define SomeDBFilesNotDeleted                    45
#define UnkAndUnexpectedError                    51
#define InvalidArgument                          52
#define CannotOpenTarget                         53
#define CannotReadTarget                         54
#define CannotWriteToTarget                      55
#define DatabaseBeingRestored                    56
#define DatabaseNotThere                         57
#define ReqTooManyBitmapBlks                     58
#define AllocateBitmapBlksFail                   59
#define TaskNeedsDismount                        60
#define TaskNeedsPrivateMount                    61
#define GlobalDirMustBeEmpty                     62
#define CannotCluMntTemp                         63
#define CannotCluMntCacheTemp                    63
#define CannotDismountTemp                       64
#define CannotDismountCacheTemp                  64
#define CannotReinitMountedDatabase              65
#define UnknownResourceName                      66
#define DBEncryptionKeyNotFound                  67
#define DBCountExceedsLicenseLImit               68
#define DatabaseIsMirrored                       69
#define ErrorWhileFormatting                     70
#define NotOwner                                 71
#define NoSuchRawDevice                          72
#define NoSuchDirectory                          73
#define IOError                                  74
#define NoSuchDeviceOrAddress                    75
#define AccessToFileDenied                       76
#define DeviceOrResourceBusy                     77
#define UCFileExists                             78
#define NoSuchDeviceOrWrongUse                   79
#define FileTableOverflow                        80
#define TooManyOpenFiles                         81
#define ReadOnlyFileSystem                       82
#define ErrorCodeIs                              83
#define AuditMaxSize                             84
#define OperIllegalInSingleUserMode              85
#define CollationNotSupported                    86
#define DatabaseBlockSizeTooSmallForDIO          87
#define DIONotSupportedByNFS                     88
#define DIOOpenRequiredForAIO                    89
#define 2KDatabaseNotSupported                   90
#define CreateDBExtentNotAllow                   91
#define WrongDBEndian                            92
#define JournalRequiredForAuditDB                93
#define LicensedTotalDBSizeExceeded              94
#define FailedToLoadCompressionEngine            95
#define NoSparseFileSupportForCompression        96
#define CannotCompressEncryptedDBs               97
#define TopPointerLevelKB                        101
#define BottomPointerLevelKB                     102
#define PointerLevelKB                           103
#define TopBottomPointerLevelKB                  104
#define DataLevelKB                              105
#define TotalBlocksKB                            106
#define ElapsedTime                              107
#define ErrorTypeWithPtr                         108
#define ErrorWhile                               109
#define WrongLinkBlock                           110
#define NoView                                   111
#define WhichIsFirst                             112
#define WhichHasLeft                             113
#define PtrBlkDegraded                           114
#define LowerDegraded                            115
#define FirstNodeRefTooLong                      116
#define FirstNodePtrWrong                        117
#define FirstNodeDoesNot                         118
#define FollowLastRef                            119
#define EqualExpectedRef                         120
#define LastLowerBlk                             121
#define WhichPntLower                            122
#define GlobalNotOK                              123
#define GlobalOK                                 124
#define LowerWrongType                           125
#define ExpectedType                             126
#define PtrDidExpect                             127
#define PtrDidNotExpect                          128
#define BigButTypeInfo                           129
#define BigButBigCount                           130
#define SaysDoesNot                              131
#define SaysDoes                                 132
#define LowerBlkInfoWrong                        133
#define LenZeroButIsRightLink                    134
#define LenPosButNoRightLink                     135
#define RefTooLong                               136
#define RefDescribed                             137
#define DoesNotFollowLastNode                    138
#define DoesNotMatchNextLen                      139
#define LowerBlkHasNextLen                       140
#define LowerBlkHasNextOff                       141
#define ButNotData                               142
#define ButNotBigDB                              143
#define FoundSeekingBigStrings                   144
#define DataBlkBigCountIs                        145
#define ButBlkTypeSays                           146
#define ShouldBeBigStrings                       147
#define ShouldNotBeBigStrings                    148
#define DataBlkSyntaxError                       150
#define BigStringInfo                            151
#define MapBlkLabelError                         152
#define LowerBlkNotInMapBlk                      153
#define BigStringInBlk                           154
#define NotAllocInMapBlk                         155
#define PtrBlkEmpty                              156
#define LowerRtLinkRefDoesNot                    157
#define MatchExpectedNextRef                     158
#define ExpLastNodeCollateEarlier                159
#define ExpectEqual                              160
#define LowerRtLinkRefIs                         161
#define PtrBlkNextRefIs                          162
#define PtrNodeRefDoesNotMatch                   163
#define FirstNodeOfLowerBlk                      164
#define LowerBlkFirstNodeIs                      165
#define BigDBRefShouldMatch                      166
#define RefNotMatchFirstBytes                    167
#define NotMatchNextPtrNode                      168
#define PtrNodeSaysBlkNumberIs                   169
#define OutOfRangeOfDataBase                     170
#define PtrBlkHasRightLink                       171
#define NotPresentOnDisk                         172
#define NotPtrBlkType                            173
#define TopBlkHasNoTopPtrBlkType                 174
#define LowerPtrBlkHasTopPtrBlkType              175
#define BigStringsInBlkMB                        176
#define BigStringsInBlkKB                        177
#define DBNotAvailableBecause                    178
#define UnexpectedError                          179
#define ReportValue                              180
#define FurtherDirCheckAborted                   181
#define FurtherGloCheckAborted                   182
#define ContCheckWithNextPtrBlk                  183
#define DatabaseNotAvailable                     184
#define InsertedAtEnd                            185
#define ShouldNodeBeInThisBlock                  186
#define InsertedAtFront                          187
#define ChangeOtherBlocks                        188
#define InsertedAsNewNode                        189
#define OldNodesMovedUp                          190
#define NodeAlreadyExists                        191
#define NotEnoughRoomInBlock                     192
#define OldNodesMovedDown                        193
#define DeletedAtFront                           194
#define TypeInvalidForRepair                     195
#define OffsetImproper                           196
#define TopPointerLevelMB                        197
#define BottomPointerLevelMB                     198
#define PointerLevelMB                           199
#define TopBottomPointerLevelMB                  200
#define DataLevelMB                              201
#define TotalBlocksMB                            202
#define LowerBlkHasRightLink                     203
#define MapFreeCountOff                          204
#define IntegrityJobNotStarted                   205
#define StopIntegrityCheck                       206
#define StopDirectoryCheck                       207
#define StopGlobalCheck                          208
#define NotBigStringDataType                     209
#define BlankLine                                210
#define PtrBlkWrongGlobal                        211
#define NoLongStringInserts                      212
#define CannotCreate2KDB                         213
#define DuplicatePointers                        214
#define DuplicatePointer                         215
#define InvalidGlobalName                        216
#define GlobalNameTooLong                        217
#define ErrorParsingNodes                        218
#define ErrorParsingPointerRef                   219
#define ErrorParsingNextPointerRef               220
#define StoredNextPtrIsWrong                     250
#define NodeHasBadSubscriptLength                251
#define MismatchCollate                          252
#define BadOffsetInBigStringBlock                253
#define BadRightLinkInBigStringBlock             254
#define BlkChangedOK                             255
#define BlkChangedBad                            256
#define GloDirBlk                                257
#define GloDirName                               258
#define CorruptMapBlockType                      259
#define IncorrectMapBlockType                    260
#define IncorrectMapBlockLabel                   261
#define IncorrectMapBlockNumber                  262
#define IncorrectIncrementalFileNumber           263
#define IncorrectDatabaseCreationTime            264
#define BlockMarkedBad                           265
#define TopPointerBlkNotAllocated                266
#define IntegrityCheckErrors                     267
#define ExpectedPtrType                          268
#define GloDirLoop                               269
#define GloDirType                               270
#define GlobalBlkChange                          271
#define GlobalMaybeBad1                          272
#define GlobalMaybeBad2                          273
#define WhichDataBlk                             274
#define WhichPntLowerError                       275
#define TopPointerRightLink                      276
#define PossibleLoop                             277
#define PossibleLoopBlk                          278
#define NotMatchNextPtrNodeError                 279
#define GloDirParseError                         280
#define BadOffsetInPointerBlock                  281
#define BadOffsetInLowerBlock                    282
#define ErrorParsingPointerBlock                 283
#define BlkTypeNotAllocated                      284
#define TopPtrBlkFirstNode                       285
#define LeftEdgePtrBlkFirstNode                  286
#define ErrorRestartingLevel                     287
#define NumberOfLevelsChanged                    288
#define IntegrityLockFailure                     289
#define IntegrityJobExited                       290
#define PtrBlkTypeMismatch                       291
#define DatabaseNotMounted                       300
#define DatabaseHasDegradation                   301
#define DatabaseReadOnly                         302
#define PrimaryVolumeExists                      303
#define SecondaryVolumeExists                    304
#define ChooseDiffPrimaryLocation                305
#define ChooseDiffSecondaryLocation              306
#define CreatedButFailureToMountIs               307
#define GlobalNotFound                           308
#define GlobalAlreadyDefined                     309
#define TempCannotBeMgrDB                        310
#define CacheTempCannotBeMgrDB                   310
#define FailedToDesignateTemp                    311
#define FailedToDesignateCacheTemp               311
#define FailedTempSfnLookup                      312
#define FailedCacheTempSfnLookup                 312
#define ModifyFailedBecause                      313
#define NotADatabaseFile                         314
#define CreatedButNotFormatted                   315
#define CannotDeleteDatabaseBecause              316
#define CannotDeleteDatabase                     317
#define CannotDeleteMirrorDatabase               318
#define CompletedReclaimingRtnBlocks             319
#define CreateFailedBecause                      320
#define FailedToSetKeepType                      321
#define NoNetworkForClusterMount                 322
#define ClusterMountFailed                       323
#define CorruptGlobalDirectory                   324
#define FailedToSetJournalType                   325
#define FailedToSetProtectState                  326
#define NoBuffersOfRequiredSize                  327
#define FailedToSetCollationType                 328
#define DatabaseError                            329
#define BlockNotInUse                            330
#define BadBlockVariable                         331
#define BigStringBlockUseDump                    332
#define GlobalExists                             333
#define CannotCreateGlobal                       334
#define GlobalIsRemote                           335
#define NotALegalName                            336
#define CannotWriteConfigFile                    337
#define InputFileError                           338
#define CorruptConfigFile                        339
#define FileNotFound                             340
#define BlockNumberTooHigh                       341
#define NotAMapBlock                             342
#define MapBlockNumberIncorrect                  343
#define 2kNotSupported                           344
#define CannotDismountManagerDB                  345
#define CannotModifyProperty                     346
#define SizeMustBeGreaterOrEqual                 347
#define BadParameter                             348
#define CannotAddVolUnlessDBExists               349
#define FailureToMountIs                         350
#define ErrorReclaimingRtnBlocks                 351
#define CorruptMapBlock                          352
#define CreatedLowerThanRequested                353
#define CommDevInUse                             354
#define DBCreationNotAllowed                     355
#define DatabaseResourceUnknown                  356
#define InsufficientBuffers                      357
#define Compacting                               358
#define Freespace                                359
#define FreeExceedsFile                          360
#define MaxSpace                                 361
#define DefragSpace                              362
#define CannotAddSystemDBToMirror                363
#define CannotDisplayMirrorInfoBlk               364
#define NamespaceUnavailable                     365
#define DatabaseTooSmall                         366
#define InvalidGblCollation                      367
#define RetFreeBlkCacheFail                      368
#define MaintOperationInProgress                 369
#define SizeNeedInteger                          370
#define DatabaseIsDismounted                     371
#define DatabaseIsReadOnly                       372
#define DatabaseIsClusterMounted                 373
#define DatabaseIsNotJournaled                   374
#define JournalingIsNotEnabled                   375
#define GlobalCollationIncorrect                 376
#define NamespaceUnavailableECP                  377
#define TruncationInprogress                     378
#define BadBlkTypeErr                            379
#define CompactionSkippedBlks                    380
#define StoppedAtUnmoveableBlock                 381
#define UnableToGetDirInfo                       382
#define GblNamesMustBeTheSame                    383
#define GblEndNodeAfterBeginNode                 384
#define DBExpansionSizeMin                       385
#define NotValidForTemp                          386
#define NotValidForCacheTemp                     386
#define NotSupportedOnVMS                        387
#define UnknownErrorCode                         388
#define BackupInProgress                         389
#define ExpansionInProgress                      390
#define NoBuffersOfRequiredSizeFromPrimary       391
#define DBCreationNotAllowedFromPrimary          392
#define UnknownSystemName                        393
#define ModifiedLowerThanRequested               394
#define CPFAtLine                                400
#define CPFLine                                  401
#define CPFNotEnoughFields                       402
#define CPFInvalidLine                           403
#define CPFNoVersion                             404
#define CPFInvalidVersion                        405
#define CPFInvalidParameterName                  406
#define CPFInvalidParameterValue                 407
#define CPFMissingParameters                     408
#define CPFCannotDeleteSection                   409
#define CPFTooManyFields                         410
#define CPFFileModifiedCannotImport              411
#define CPFInvalidMapKeyword                     412
#define CPFInvalidOrDuplicateSection             415
#define CPFDuplicateLine                         416
#define CPFDuplicateEntry                        417
#define CPFSectionAlreadyExists                  418
#define CPFNameAlreadyExists                     419
#define CPFNameDoesNotExist                      420
#define CPFMapDoesNotExist                       421
#define CPFMapAlreadyExists                      422
#define CPFServerInUse                           423
#define CPFDeviceSameasAlias                     424
#define CPFDataServerNotDefined                  425
#define CPFDataServerNotAllowed                  426
#define CPFCannotDeleteSystemDatabase            427
#define CPFNamespaceAlreadyExists                428
#define CPFDatabaseInUse                         429
#define CPFNotAllowedForRemoteServer             430
#define CPFCannotClusterMountSystemDB            431
#define CPFMissingDatabase                       432
#define CPFNamespaceDoesNotExist                 433
#define CPFCannotDeleteSystemNamespace           434
#define CPFMissingNamespace                      435
#define CPFServersBeforeDatabases                436
#define CPFDatabasesBeforeNamespaces             437
#define CPFDeviceSubTypesBeforeDevices           438
#define CPFNamespacesBeforeMap                   439
#define CPFMissingSections                       440
#define CPFFurtherCheckingAborted                441
#define CPFNoClusteredDatabases                  442
#define CPFCommentTooLong                        444
#define CPFCommentMustStart                      445
#define CPFInvalidNestedComment                  446
#define CPFNoEndCommentFound                     447
#define CPFInvalidRoutineType                    448
#define CPFCannotMapRoutine                      449
#define CPFDataServerAlreadyDefined              450
#define CPFMustDeleteMapping                     451
#define CPFMappingAlreadyExists                  452
#define CPFReactivateCannotQuiesce               453
#define CPFMappingMustBeDefined                  454
#define CPFDatabaseCouldNotMount                 455
#define CPFIncreaseMaxServers                    456
#define CPFInvalidNamespaceName                  457
#define CPFInvalidServerName                     458
#define CPFDatabaseAlreadyExists                 459
#define CPFInvalidCollation                      460
#define CPFIPv6SupportUnavailable                461
#define CPFInvalidBlockSize                      462
#define CPFBadDBForMirrorConnection              463
#define CPFECPServerNotExist                     464
#define CPFECPServerNotMirror                    465
#define CPFNoLongStrings                         466
#define CPFAliasInUse                            467
#define CPFInvalidShadowName                     468
#define CPFShadowsBeforeMap                      469
#define CPFServerMatchLocal                      470
#define CPFSectionBeforeMap                      471
#define CPFnewWIJdirexists                       472
#define CPFLocalDirectoryNotListed               473
#define CPFUnableToLock                          474
#define CPFRequiredDatabaseMountedReadOnly       475
#define CPFInvalidMirrorConnection               476
#define CPFBadDBForNonMirrorConnection           477
#define CPFInvalidMagTapeName                    478
#define CPFCannotCompressSystemDatabase          479
#define CPFUnknownCompressionEngineName          480
#define CtrlCharsInData                          570
#define DatabaseCopyAlreadyRunning               571
#define CannotCopyClusterDatabase                572
#define CannotCopyMirroredDatabase               573
#define CSPApplication                           601
#define DataServer                               602
#define Database                                 603
#define Device                                   604
#define GloMap                                   605
#define GloRepl                                  606
#define LicenseServer                            607
#define Namespace                                608
#define SQLGateway                               609
#define RouMap                                   610
#define MagTape                                  611
#define SubType                                  612
#define EthernetConnection                       613
#define UDPConnection                            614
#define EthernetDevice                           615
#define VolSetUCI                                616
#define ShdwDestination                          617
#define ShdwSource                               618
#define LATService                               619
#define ComPort                                  620
#define SysDataType                              621
#define UserDataType                             622
#define SLMRepl                                  623
#define SLM                                      624
#define JrnHistory                               625
#define VolumeSet                                626
#define Namespaces                               627
#define Databases                                628
#define Devices                                  629
#define Configuration                            630
#define ProjectionType                           631
#define JavaApp                                  632
#define EJBApp                                   633
#define CPPApp                                   634
#define ClsMap                                   635
#define ElementNotDefined                        641
#define ElementInUse                             642
#define ElementAlreadyExists                     643
#define InvalidParameter                         644
#define ElementDoesNotExist                      645
#define RestartRequired                          646
#define BadActiveFile                            647
#define ConfigNotSaved                           648
#define ConfigInUse                              649
#define AppAlreadyExists                         650
#define SetStartupError                          651
#define ClusterRequires                          652
#define SLMInvTilde                              653
#define SLMOpenParen                             654
#define SLMCloseParen                            655
#define SLMOpenBeforeClose                       656
#define SLMInvSub1                               657
#define SLMInvSubN                               658
#define SLMInvRange                              659
#define SLMMoreThan2Ranges                       660
#define NameRequired                             661
#define KeyRequired                              662
#define NoInfoFound                              663
#define NoProperty                               664
#define CouldNotOpenConfig                       665
#define RemoteChangeFailed                       666
#define ConfigParseError                         667
#define ActivateError                            668
#define SLMCollation                             669
#define LDAPerror                                701
#define LDAPNotInited                            702
#define LDAPLoadFailed                           703
#define LDAPOverflow                             704
#define LDAPOutOfHeap                            705
#define LDAPNotParent                            706
#define LDAPUnknownObj                           707
#define LDAPInvalidLib                           708
#define LDAPSASLChallenge                        709
#define LDAPParamErr                             710
#define LDAPNotSupported                         711
#define LDAPAuthNotSupported                     712
#define LDAPInvalidGroupId                       713
#define LDAPInvalidInstanceId                    714
#define SSLVerifyPeerIncorrectForClient          725
#define ExpandedCipherNoValue                    726
#define SSLUnlicensed                            727
#define CertificateExpired                       728
#define InvalidClientCert                        729
#define InvalidServerCert                        730
#define PublicKeyEncryptionFailed                731
#define PrivateKeyFileDecryptionFailed           732
#define PublicPriveKeyMismatch                   733
#define CertVerifyFailed                         734
#define NoMirrorSSL                              735
#define NotMirrorMember                          736
#define MemberUnreachable                        737
#define CanNotDisableTerminalAuthe               738
#define MirrorSSLValidateFailed                  739
#define MissingSSLCertificate                    740
#define MissingSSLCA                             741
#define InvalidCert                              742
#define InvalidCAFile                            743
#define MissingX509Certificate                   744
#define ServiceNotLicensed                       787
#define InsufficientPrivilegeForOperationReq     788
#define EnteredUserDoesNotMatch                  789
#define OperationRequiresOneOfTwo                790
#define DocDBRestricted                          791
#define DocDBDisabled                            792
#define DocDBDoesNotExist                        793
#define DocDBAlreadyExists                       794
#define AttemptToAccessProtectedRoutine          795
#define AttemptToAccessProtectedMethod           796
#define UserAccountHasExpired                    797
#define AuthenticationFailed                     798
#define ApplicationInvalidName                   799
#define ServiceDisabled                          800
#define ServiceLoginsDisabled                    801
#define ServiceSystemStartupInProgress           802
#define ServiceSystemShutdown                    803
#define ServiceAutheKBNotAllowed                 804
#define ServiceAutheKBIntegrityNotAllowed        805
#define ServiceAutheKBEncryptionNotAllowed       806
#define ServiceAutheOSNotAllowed                 807
#define ServiceKBRequired                        808
#define ServiceDoesNotExist                      809
#define ServiceInvalidUsernameOrPassword         810
#define ServiceAutheK5CCacheNotAllowed           811
#define ServiceAutheK5PromptNotAllowed           812
#define ServiceAutheK5APINotAllowed              813
#define ServiceAutheK5KeyTabNotAllowed           814
#define ServiceNotAuthorized                     815
#define ServiceInvalidAutheAllowed               816
#define ServiceInvalidIPAddress                  817
#define ServiceCannotDelete                      818
#define ServiceAlreadyExists                     819
#define ServiceInvalidAuthe                      820
#define AccessToResourceDenied                   821
#define AccessDenied                             822
#define InvalidUsernameOrPassword                824
#define UserUnableToInitializeSQL                825
#define UserUnableToRunZSTART                    826
#define UserNotAuthorizedOnSystem                827
#define UserAccountIsDisabled                    828
#define UserUnableToAddRole                      829
#define UserUnableToUpdateLastLogin              830
#define UserInvalidUsernameOrPassword            831
#define UserErrorUpdatingPassword                832
#define UserLoginTimeout                         833
#define UserCTRLC                                834
#define UserBypassingSystemSecurity              835
#define UserInsufficentPrivForProgrammer         836
#define UserAlreadyExists                        837
#define UserDoesNotExist                         838
#define UserCannotDeleteSuperUser                839
#define UserCannotDeleteLastAll                  840
#define UserCannotDeleteDefaultUser              841
#define UserInvalid                              842
#define UserInUseByService                       843
#define UserInsufficentPrivForNameSpace          844
#define UserPasswordInvalidFormat                845
#define UserCannotContainDomain                  846
#define SystemAlreadyExists                      848
#define SystemDoesNotExist                       849
#define AuditDatabaseNotAvailable                850
#define EventInvalidName                         851
#define EventAlreadyExists                       852
#define EventDoesNotExist                        853
#define EventCannotDeleteSystem                  854
#define EventCannotModifySystem                  855
#define AuditNotStopped                          856
#define AuditUnableToStart                       857
#define AuditUnableToQuiesce                     858
#define AuditDoesNotExist                        859
#define SecurityInitFailure                      860
#define ApplicationDisabled                      861
#define ApplicationRestricted                    862
#define ApplicationLocked                        863
#define RequireAuthentication                    864
#define RoutineNotAuthorizedforProfile           865
#define ClientApplicationNotAuthorized           866
#define ApplicationAlreadyExists                 867
#define ApplicationNotFound                      868
#define ApplicationDoesNotExist                  869
#define CannotDeleteSystemApp                    870
#define MatchRoleDuplicate                       874
#define MatchRoleDoesNotExist                    875
#define TargetRoleDuplicate                      878
#define TargetRoleDoesNotExist                   879
#define RoleCannotDelete                         880
#define RoleCannotRemove                         881
#define RoleDoesNotExist                         883
#define RoleAlreadyExists                        884
#define RoleMaxReached                           885
#define RoleCannotModify                         886
#define RoleInvalidName                          887
#define ResourceCannotDelete                     890
#define ResourceAlreadyExists                    891
#define ResourceDoesNotExist                     892
#define ResourceCannotModify                     893
#define ResourceMaxReached                       894
#define ResourceDuplicate                        895
#define ResourceInvalidName                      896
#define ResourceInvalidPermission                897
#define SSLConfigAlreadyExists                   898
#define DomainCannotDelete                       900
#define DomainAlreadyExists                      901
#define DomainInvalidName                        902
#define DomainDoesNotExist                       903
#define DomainCannotChangeMultiple               904
#define LDAPConfigMustContainDot                 906
#define LDAPConfigAlreadyExists                  907
#define LDAPConfigInvalidName                    908
#define LDAPConfigDoesNotExist                   909
#define LDAPConfigNotEnabledForLDAP              910
#define UnableToDetermineLDAPConfig              911
#define LDAPISCLDAPConfigurationNotAllowed       912
#define PhoneProviderDoesNotExist                913
#define X509CredentialsDoesNotExist              914
#define OpenAMIdentityServicesDoesNotExist       915
#define CannotModifyResourceField                919
#define CannotModifyField                        920
#define OperationRequires                        921
#define OperationRequires1                       922
#define OperationRequires2                       923
#define OperationRequires3                       924
#define SystemCannotDelete                       930
#define PasswordChangeRequired                   935
#define InsufficientPrivilegeObjectAccess        939
#define InsufficientPrivilegeForOperation        940
#define AuditHeaderUnwritten                     941
#define UserAndRoleSameName                      942
#define UserHasNoRole                            943
#define UserInvalidExpirationDate                944
#define NoPctSysAuditImport                      945
#define UserHasNoNamespaces                      946
#define ServicePasswordNotAllowed                947
#define SSUnrecognizedType                       948
#define SSReadTimeout                            949
#define ServiceInvalidName                       950
#define ServiceAutheUnauthenticatedDisabled      951
#define UserInvalidPassword                      952
#define UserInvalidLegacyPassword                953
#define UserCannotConvertPassword                954
#define UserInvalidKerberosUsernameOrPassword    955
#define UserKerberosError                        956
#define ApplicationPasswordNotAllowed            957
#define InvalidPasswordPattern                   958
#define UserAccountIsExpired                     959
#define UserAccountIsInactive                    960
#define UserKerberosUnlicensed                   961
#define UpgradeCDClient                          962
#define NoAuthenticationEnabled                  963
#define LDAPServerUnavailable                    964
#define LDAPSearchBindFailed                     965
#define LDAPSearchFailed                         966
#define LDAPCountEntriesFailed                   967
#define LDAPUserDoesNotExist                     968
#define LDAPUserIsNotUnique                      969
#define LDAPFirstEntryFailed                     970
#define LDAPInvalidPassword                      971
#define NotALDAPUser                             972
#define NotADelegatedUser                        973
#define UserIsNotaIRISUser                       974
#define UserIsNotaCacheUser                      974
#define LDAPGetDNFailed                          975
#define LDAPGetValuesLenFailed                   976
#define AttributeValueMustBeList                 977
#define RequiresRoleForConnection                978
#define SSLConfigDoesNotExist                    979
#define UnableToActivateSSLConfig                980
#define SSLConfigInvalidName                     981
#define CipherRequireAuthe                       982
#define PrivateKeyReq                            983
#define CertificateKeyReq                        984
#define PrivateKeyReqPassword                    985
#define CAFileCAPathReq                          986
#define SSLConfigIsDisabled                      987
#define SSLHandShakeFailed                       988
#define SSLConnectionFailed                      989
#define SSLOnlyTestClient                        990
#define MustSpecifyHostAndPort                   991
#define PasswordHasExpired                       992
#define CannotModifyLDAPUser                     993
#define CannotModifyDelegatedUser                994
#define SSSSLRequired                            995
#define SSSSLNone                                996
#define OSDelegatedAuthenticationFailed          997
#define LoginTokenExpired                        998
#define UserLoginTokenExpired                    999
#define ShadowSourceNameUndefined                1000
#define ShadowSourcePortInvalid                  1001
#define ShadowJournalStoreUndefined              1002
#define ShadowStartPointUndefined                1003
#define ShadowDatabaseIsSys                      1004
#define ShadowDatabaseIsCachesys                 1004
#define ShadowDatabaseMappingUndefined           1005
#define ShadowIDInvalid                          1006
#define ShadowJournalStoreIsJournalDirectory     1007
#define ShadowMirrorAmbiguous                    1008
#define ShadowStoppedNotResumable                1010
#define ShadowLockFailed                         1012
#define ShadowIDRequired                         1013
#define ShadowIDNotExist                         1014
#define ShadowTestFailed                         1015
#define ShadowTestTimedOut                       1016
#define ShadowStopRequired                       1017
#define ShadowDatabaseSameAsSource               1018
#define ShadowVersionMismatch                    1020
#define ShadowJournalMismatch                    1021
#define ShadowConnectionDenied                   1022
#define ShadowVersionInvalid                     1023
#define ShadowGMHEAPAllocError                   1024
#define ShadowGMHEAPInsufficient                 1025
#define ShadowMessageInvalid                     1026
#define ShadowSourceNoCluster                    1027
#define ShadowSourceWrongCluster                 1028
#define ShadowAbort                              1029
#define ShadowJobFail                            1030
#define ShadowStopping                           1031
#define ShadowSuspendTimedOut                    1032
#define ShadowSourceJournalFileNotExist          1033
#define ShadowSourceJournalFileInvalid           1034
#define ShadowJournalFileCorrupt                 1035
#define ShadowFileOpenError                      1036
#define ShadowFileAheadOfSource                  1037
#define ShadowFileAddressInvalid                 1038
#define ShadowStartFileUndefined                 1039
#define ShadowSyncFailed                         1040
#define ShadowClusterStartPointUndefined         1041
#define ShadowClusterStartPointIncomplete        1042
#define ShadowLicenseInsufficient                1043
#define ShadowRunningNotResumable                1044
#define ShadowClusterCheckPointBad               1045
#define ShadowSourceJournalDisabled              1046
#define ShadowNotResumable                       1047
#define ShadowNotStartable                       1048
#define ShadowTCPOpenFailed                      1070
#define ShadowTCPReadTimedOut                    1071
#define ShadowSourceDisconnect                   1072
#define ShadowServerDisconnect                   1073
#define ShadowJobRoutineFail                     1074
#define ShadowPurgeInProgress                    1075
#define ShadowPurgeNotAvailable                  1076
#define ShadowAnswerError                        1077
#define ShadowKillJobError                       1078
#define ShadowPurgeNoSync                        1079
#define ShadowDatabaseMountError                 1080
#define ShadowSourceDatabaseNotExist             1090
#define ShadowSourceDatabaseNotMounted           1091
#define ShadowSourceDatabaseInvalid              1092
#define ShadowFileInvalidEOF                     1093
#define ShadowGotFewerData                       1094
#define JournalFileOpenForRecordFailed           1100
#define JournalFileNotExist                      1101
#define JournalFileInvalid                       1102
#define JournalFilePrevError                     1103
#define JournalFileOpenIdFailed                  1104
#define JournalFileFirstRecordInvalid            1105
#define JournalFileDeleteError                   1106
#define JournalFileSearchUndefined               1107
#define JournalFileUndefined                     1108
#define JournalFileNextNotExist                  1109
#define JournalFileNoValidRecord                 1110
#define JournalFileNextError                     1111
#define JournalFileCorruption                    1112
#define JournalFileNotInLog                      1113
#define JournalRecordFetchColumnUnknown          1120
#define JournalRecordBadDirectory                1121
#define JournalRecordBadGlobalNode               1122
#define JournalingStartError                     1140
#define JournalingStopError                      1141
#define JournalingSwitchError                    1142
#define JournalDirectoryNotExist                 1143
#define JournalDirectoryInvalid                  1144
#define JournalDirectoryCreateError              1145
#define JournalFilePrefixInvalid                 1146
#define JournalDirectoryTooLong                  1147
#define CommasInJournalPath                      1148
#define JournalUnableToGetAttributes             1149
#define JournalReadOnly                          1150
#define UserInsufficientPrivsDisableJournal      1151
#define JournalTransactionIDInvalid              1160
#define JournalTransactionStartInvalid           1161
#define ClusterJournalMarkerFileNotExist         1180
#define ClusterJournalMarkerFileNotOpen          1181
#define JrnEncRequiresStartupKey                 1197
#define JrnEncNotActivated                       1198
#define JrnEncNotDeactivated                     1199
#define DBEncKeyAlreadyActivated                 1200
#define DBEncKeyNotActivated                     1201
#define DBEncKeyFileBadFormat                    1202
#define DBEncKeyFileDoesNotMatch                 1203
#define DBEncKeyFileUserNotFound                 1204
#define DBEncKeyFileUserAlreadyExists            1205
#define DBEncKeyCreationFailed                   1206
#define DBEncKeyActivationFailed                 1207
#define DBEncDatabasesMounted                    1208
#define DBEncInvalidPassword                     1209
#define DBEncLastAdmin                           1210
#define DBEncWideUnicodeNotSupported             1211
#define DBEncKeyRequiredAtStartup                1212
#define DBEncKeyRequiredForRecovery              1213
#define DBEncKeyRequiredNow                      1214
#define DBEncKeyRequiredForRollback              1215
#define DBEncStartModeStillEnabled               1216
#define DBEncDatabasesRequired                   1217
#define AuditEncRequiresStartupKey               1218
#define DBEncKeyUnwrapFailed                     1219
#define DBEncKeyNoSpaceAvailable                 1220
#define DBEncKeyFileKeyNotFound                  1221
#define DBEncUnattendedAdmin                     1222
#define DBEncKMIPServerNotFound                  1223
#define DBEncKMIPServerConfigFailed              1224
#define DBEncKMIPCreateFailed                    1225
#define DBEncKMIPGetFailed                       1226
#define DBEncKMIPDestroyFailed                   1227
#define DBEncSysDB                               1228
#define DBEncMounted                             1229
#define DBEncLocked                              1230
#define DBEncKMIPNoStart                         1231
#define DCLockSystemFailed                       1300
#define DCDaemonNotAllowed                       1301
#define DCSystemAlreadyStarted                   1302
#define DCGlorefCollationOrder                   1303
#define DCProtocolError                          1304
#define DCInitQueueFailed                        1305
#define DCJobTimeout                             1306
#define DCJobFailure                             1307
#define DCAccessDenied                           1308
#define DCPeerTimeout                            1309
#define DCDuplicateDBMapping                     1310
#define DCConnectTimeout                         1311
#define DCFeatureNotSupportedByPeer              1312
#define DCMirrorConfig                           1313
#define DCSourceMismatch                         1314
#define DCObjectSystemName                       1315
#define DCInvalidDatabase                        1316
#define DCDuplicateGSMask                        1317
#define DCRangeListErrorStatus                   1360
#define DCRangeListCollationSet                  1361
#define DCRangeListModified                      1362
#define DCQueryInitialRefNull                    1370
#define DCQueryIdenticalRefs                     1371
#define DCQueryRefGlobalNames                    1372
#define DCWorkflowNull                           1380
#define DCWorkflowNextPhaseRange                 1381
#define DCGlobalReferenceInvalid                 1390
#define NotAKerberosUser                         1400
#define NoZauthorizeRoutine                      1401
#define NoZauthenticateRoutine                   1402
#define ZauthenticateParameter                   1403
#define CannotModifyKerberosUser                 1404
#define NotAOSUser                               1405
#define ZauthorizeParameter                      1406
#define CannotModifyOSUser                       1407
#define InvalidApplicationAuthe                  1408
#define TwoFactUserNotConfig                     1409
#define TwoFactWrongFunc                         1410
#define TwoFactTimeout                           1411
#define TwoFactBadToken                          1412
#define ProviderAlreadyExists                    1413
#define ProviderDoesNotExist                     1414
#define UserInvalidPhoneNumber                   1415
#define UserInvalidPhoneProvider                 1416
#define TwoFactInvalidConfig                     1417
#define UserAccountLoginLimit                    1418
#define GetCredentialsFailed                     1419
#define GetCredentialsNoUsername                 1420
#define UserNoPhoneProvider                      1421
#define ServiceNoMirrorAndShadow                 1422
#define AddRolesNoZINSERT                        1424
#define AppAutheUnauthenticatedDisabled          1426
#define UnableToAddOrSetAuditEvent               1427
#define StudioNoTwoFactor                        1428
#define UserInsufficentPrivForService            1429
#define NoImpliedNamespace                       1430
#define ManagerRoleRequires                      1431
#define DomainNameIsNull                         1432
#define TwoFactorPWBadToken                      1433
#define TwoFactorRequiresAuthentication          1434
#define TwoFactSMSTextNotConfig                  1435
#define TwoFactorOnlyOneEnabled                  1436
#define CannotDeleteDefaultDomain                1437
#define LDAPMustBeEnabled                        1438
#define UsernamesTooLong                         1439
#define LDAPNestedGroupsInvalidNoAD              1440
#define LDAPNestedGroupsInvalidNoGroups          1441
#define LDAPConfigIsKerberosOnly                 1442
#define LDAPGroupsNotConfigured                  1443
#define NoMultipleAndDomainChange                1444
#define PasswordChangeZAUTHFailed                1445
#define PasswordChangeFailed                     1446
#define PhoneProviderInUse                       1447
#define CannotVerifyPhoneProviderUnused          1448
#define CannotExportDatabaseRoles                1449
#define ServiceNotEnabled                        1450
#define SSLUsedByECPServer                       1451
#define SSLUsedByECPClient                       1452
#define SSLECPServerNotExist                     1453
#define SSLECPClientNotExist                     1454
#define EMSError                                 1500
#define EMSErrBadSSLCert                         1501
#define EMSErrAlreadyConfigured                  1502
#define EMSRestrictedOnClient                    1503
#define EMSNoSMP                                 1504
#define EMSAPIException                          1505
#define MGBLAlreadyExists                        1600
#define MGBLDoesNotExist                         1601
#define MGBLStillRunning                         1602
#define MGBLCannotModify                         1603
#define MGBLUserTerminated                       1604
#define MGBLCannotOpenJournal                    1605
#define MGBLUnableToFindJournal                  1606
#define MGBLSrcAndDstSame                        1607
#define MGBLCannotCopyECPDB                      1608
#define MGBLCannotUseSystemDB                    1609
#define MGBLJournalingDisabled                   1610
#define MGBLJournalingTroubled                   1611
#define MGBLDBNotMirrored                        1612
#define MGBLUnableToSetMirrorState               1613
#define MGBLGblAlreadyExists                     1614
#define MGBLGblDoesNotExist                      1615
#define MGBLAlreadyRun                           1616
#define MGBLCannotOperateNamespace               1617
#define MGBLRoutinesAlreadySplit                 1618
#define MGBLUnableToGetDirInfo                   1619
#define MGBLCollationsDontMatch                  1620
#define MGBLMoveGlobalsJobNotStarted             1621
#define MGBLMoveGlobalAlreadyRun                 1622
#define MGBLOperationTerminated                  1623
#define MGBLStartAndEndGlobalDiffer              1624
#define MGBLStateWrong                           1625
#define MGBLUnableToLock                         1626
#define MGBLUnableToFindSFN                      1627
#define MGBLCollationChanged                     1628
#define MGBLDidNotHandleKill                     1629
#define MGBLUnhandledJrnRecord                   1630
#define MGBLCantStartJournalMonitor              1631
#define MGBLCantCalcFreespaceDismounted          1632
#define MGBLIncreaseMaxSizeOfDB                  1633
#define MGBLMovesExceedsDiskSpace                1634
#define MGBLDstDBNotConfigured                   1635
#define MGBLNewDstDBAlreadyConfigured            1636
#define MGBLGblAlreadyExistInDstDB               1637
#define MGBLDataMoveIsRunning                    1638
#define MGBLCannotFindAndDeleteRange             1639
#define MGBLInvalidMethod                        1640
#define MGBLInvalidJobMethod                     1641
#define MGBLCannotJobMethod                      1642
#define MGBLAlreadyRunning                       1643
#define MGBLAlreadyCompleted                     1644
#define MGBLUnrecoverableRollBack                1645
#define MGBLCollationDifferent                   1646
#define MGBLUnableToQuiesce                      1647
#define MGBLUnableToSuspendCompleted             1648
#define MGBLUnableToSuspendNotStarted            1649
#define MGBLUnableToSuspendJournal               1650
#define MGBLUnableToSuspendStopped               1651
#define MGBLUnableToStopCompleted                1652
#define MGBLUnableToStopNotStarted               1653
#define MGBLUnableToStopJournal                  1654
#define MGBLInvalidName                          1655
#define JournalFileForDBMissingFromMirrorLog     2000
#define FailedToReadJournalHeader                2001
#define MirrorNameNotSpecified                   2002
#define MirrorJournalLogNotFound                 2003
#define MirrorJournalLogOpenError                2004
#define MirrorJournalLogReadError                2005
#define CantModifyMirrorSetName                  2006
#define CantModifyMirrorSetGUID                  2007
#define FailedToSendRecovParams                  2008
#define SectionNotLoadedMirrorSetGUIDNotDefined  2009
#define FailedToLoadMirrorConfiguration          2010
#define NoColonInMirrorName                      2011
#define MirrorNameTooLong                        2012
#define MirrorParametersAlreadyLoaded            2013
#define BothJoinMirrorAndAsyncMemberGUIDSetAbort 2014
#define BothJoinMirrorAndAsyncMemberGUIDSet      2015
#define MirrorMemberMissingSystemName            2016
#define MirrorMemberMissingMirrorName            2017
#define MirrorMemberMissingMirrorGUID            2018
#define MirrorMemberCheckSecurityMissingService  2019
#define MirrorNameNotDefined                     2020
#define BadMirrorName                            2021
#define CannotShutdownPrimary                    2022
#define NoColonInMirrorSystemName                2023
#define MirrorSystemNameTooLong                  2024
#define LoadAsyncMemberIDsMirrorNameNotConfig    2025
#define SSLCNAlreadyInUse                        2026
#define SSLCNCannotBeNull                        2027
#define MirrorConfigMissingRequiredParameter     2028
#define MirrorAsyncMemberNotConfigured           2029
#define MissingMirrorSetNameForUpdate            2030
#define QueryListMissingMirrorSetName            2031
#define MirrorSetNameNotFound                    2032
#define MirrorNameNotUnique                      2033
#define FailedToAllocateMirrorStructure          2034
#define DuplicateMirrorNameOrGUID                2035
#define FailedToLoadMirrorConfig                 2036
#define FailedToRetrieveMirrorConfig             2037
#define NoColonInMirrorMemberName                2038
#define MirrorMemberNameTooLong                  2039
#define MirrorSetNameNotDefined                  2040
#define LoadAllMirrorSetMembersAlreadyRun        2041
#define LocalSystemNotInMirrorConfig             2042
#define ConnectFailedToAddNewMirrorMember        2043
#define ArgumentIsNotAnObject                    2044
#define FailedToAddMirrorMember                  2045
#define MirrorMemberGUIDNotUnique                2046
#define BaseDirectoryMismatch                    2047
#define FailedToAddMirrorMemberIndex             2048
#define MirrorInsufficientPrivs                  2049
#define MirrorConfigNotLoaded                    2050
#define MirrorSetNameNotConfigured               2051
#define MirrorManagerDmnFailedToStart            2052
#define FailedToCreateMirrorJournalLog           2053
#define FailedToDeleteMirrorJournalLog           2054
#define MirrorPurgeStartFileNotFound             2055
#define MirrorVIPNotValid                        2056
#define MirrorVIPInterfaceNotExist               2057
#define MirrorDatabaseNameMissing                2058
#define MirrorDatabaseNameTooLong                2059
#define NoColonInMirrorDatabaseName              2060
#define MirrorDatabaseNameNotUnique              2061
#define FailedToCheckDupliateMirrorDatabaseName  2062
#define DatabaseAlreadyMirrored                  2063
#define RemoveDatabaseFailedDBNotMirrored        2064
#define CreateMirrorGenericError                 2065
#define MirrorServiceNotEnabled                  2066
#define SSLConfigRequiredButMissing              2067
#define SSLConfigExistsButNotEnabled             2068
#define SSLConfigurationServerClientNameMismatch 2069
#define MirrorVIPNotUnique                       2070
#define RetrieveMirrorConfigError                2071
#define CharacterSizeMismatch                    2072
#define MirroredDatabaseNotFoundOnSystem         2073
#define NotInMirror                              2074
#define OtherFailoverMemberNotDefinedOrFound     2075
#define RetrieveMirrorMemberError                2076
#define ForceBecomePrimaryFailed                 2077
#define MirroredDBAlreadyActivated               2078
#define ActivateMirroredDBFailed                 2079
#define RemoveMirroredDBFailed                   2080
#define NotFailoverMember                        2081
#define PrimaryNotConnected                      2082
#define InstanceLookupFail                       2083
#define JoinMirrorGenericError                   2084
#define VIPNoSubnetMask                          2085
#define AgentUnreachable                         2086
#define MirrorChannelUnreachable                 2087
#define ECPChannelUnreachable                    2088
#define BadVAI                                   2089
#define VirtualInterfaceIsNull                   2090
#define GetSSLDNFailed                           2091
#define EncrDBReqSSL                             2092
#define MirrorInsufficientShutdownPrivs          2093
#define MirrorConnDisconnectFailed               2094
#define MirrorSSLValidationTrouble               2095
#define MirrorVIPNotReachable                    2096
#define MirrorVIPSubnetMismatch                  2097
#define MirrorPurgeStartInvalid                  2098
#define MirrorLicenseInsufficient                2099
#define MirrorSetMemberOpenFailed                2100
#define MirrorSetNameNotUnique                   2101
#define NoMirrorDBInFailover                     2102
#define NoMirrorDBInPrimary                      2103
#define NewMirrorDBFailed                        2104
#define MirrorDBNotNew                           2105
#define MirrorAlreadyStarted                     2106
#define MirrorNotStarted                         2107
#define MirrorsOpenFailed                        2108
#define TooManyMirrorsOnFailoverMember           2109
#define AlphaNumericsOnlyInMirrorName            2110
#define FailedToReadMirrorMemberInfo             2111
#define DeleteOperationNotAllowed                2112
#define OperationOnPrimaryOnly                   2113
#define FailedToOpenMapMirrors                   2114
#define ClearFailoverDBFlagNotAllowed            2115
#define OperationNotAllowedInPrimary             2116
#define NotDRMember                              2117
#define LocalAgentNotUp                          2118
#define TooManyMirrorSet                         2119
#define RelayClientNotAllowed                    2120
#define FailoverNoAgent                          2121
#define FailToCreateMapMirrors                   2122
#define GUIDMismatch                             2123
#define SelectedNotFound                         2124
#define MismatchedPrimary                        2125
#define DefinedPrimaryFailed                     2126
#define TellPrimaryFailed                        2127
#define AgentUnreachableNoDetails                2128
#define JournalRequiredForMirroredDB             2129
#define RemoveDatabaseFailedDBNotMounted         2130
#define RelayServerNotAllowed                    2131
#define NeedVIPInterface                         2132
#define TooFewFailoverMember                     2133
#define OtherMirrorSetExisted                    2134
#define AgentGetVersionFailed                    2135
#define AgentVersionInvalid                      2136
#define TooManyFailoverMember                    2137
#define EMSManaged                               2138
#define RemoteEMSManaged                         2139
#define MismatchUNICODE                          2140
#define MismatchSystemName                       2141
#define BadAsyncMemberType                       2142
#define ClearFailoverDBFlagOnNonactvatedDB       2146
#define ClearFailoverDBFlagFailed                2147
#define DefaultMirrorSystemNameTooLong           2148
#define TooManyMirrorOnDR                        2149
#define RelayNotAllowedForDR                     2150
#define EncJrnNotAllowed                         2151
#define EncJrnNoUseSSL                           2152
#define NotAReportingMember                      2153
#define DejournalAlreadyRunning                  2154
#define DemoteNoPartnerWithPrimary               2155
#define DemoteFailedInPromote                    2156
#define PrimaryInTrouble                         2157
#define OnlyAllowedOnReportingMember             2158
#define NotTrackingAnyMirrors                    2159
#define NotTrackingMirror                        2160
#define MissingMirrorNameTrackingMultipleMirrors 2161
#define AgentPortUnavailable                     2162
#define AgentInterfaceUnavailable                2163
#define AgentStatusResponseInvalid               2164
#define NotAsyncMember                           2165
#define OnlyAllowedOnAsyncMember                 2166
#define MirrorDatabaseNameInvalid                2167
#define MirrorBackupNotExit                      2168
#define MirrorMasterNotExit                      2169
#define NoFilterCodes                            2170
#define MirrorNameContainsIllegalCharacter       2171
#define NonFailoverDBIsNotAllowed                2172
#define LocalValidationFailureBlocksMirrorEdit   2173
#define MirrorJoinFileExisted                    2174
#define DNIsTooLong                              2175
#define NoPromoteNoPartner                       2176
#define NoJoinNoPartner                          2177
#define BusyPromoteDemote                        2178
#define MirrorShutdownFailed                     2179
#define MissingPartner                           2180
#define InvalidIPAddress                         2181
#define InvalidHostName                          2182
#define InvalidArbiterAddr                       2183
#define ArbiterAddrTooLong                       2184
#define NoCAConfigured                           2200
#define CSRNotFound                              2201
#define CertificateNotFound                      2202
#define PrivateKeyFileNotFound                   2203
#define CSRCreationFailed                        2204
#define CertificateCreationFailed                2205
#define SubjectDNRequired                        2206
#define PrivateKeyPasswordRequired               2207
#define PasswordNoQuotationMarks                 2208
#define GeneralError                             5001
#define ObjectScriptError                        5002
#define CacheError                               5002
#define NotImplemented                           5003
#define CanNotGenerateUUID                       5004
#define FileCanNotOpen                           5005
#define FileNameInvalid                          5006
#define DirectoryNameInvalid                     5007
#define FileNameRequired                         5008
#define DirectoryNameRequired                    5009
#define FileAlreadyOpen                          5010
#define FileNotOpen                              5011
#define FileDoesNotExist                         5012
#define CannotGenerateTypeLibrary                5013
#define FeatureNotSupported                      5014
#define NamespaceDoesNotExist                    5015
#define TooManyErrors                            5017
#define RoutineDoesNotExist                      5018
#define FileCanNotDelete                         5019
#define FileCanNotRename                         5020
#define DirectoryNotExist                        5021
#define DataMissing                              5022
#define RemoteGatewayError                       5023
#define FileCanNotCopy                           5024
#define InvalidConnectionName                    5025
#define InvalidECPCliAction                      5026
#define FileAlreadyExists                        5027
#define InvalidRoutineName                       5028
#define UnableToKill                             5029
#define ErrorCompilingClass                      5030
#define CannotJobRoutine                         5031
#define DirectoryCannotCreate                    5032
#define Interrupt                                5033
#define InvalidStatusCodeStruct                  5034
#define GeneralException                         5035
#define SMPQueryHistoryLockFailed                5036
#define DirectoryPermission                      5037
#define ErrorCompilingGenerator                  5038
#define ErrorCallingFunction                     5039
#define CannotCopyFileFromTo                     5040
#define UnableToExecuteJava                      5041
#define UnableToExecuteZF                        5042
#define JarFileDoesNotExist                      5043
#define JavaException                            5044
#define JavaUnknownError                         5045
#define ErrorExecutingJavaCommand                5046
#define BadParameterEncode                       5047
#define BadJavaVersion                           5048
#define ConstraintNameInvalid                    5050
#define ClassAlreadyExist                        5051
#define DuplicatedName                           5052
#define ClassNameInvalid                         5053
#define MethodNameInvalid                        5054
#define ParameterNameInvalid                     5055
#define PropertyNameInvalid                      5056
#define StorageNameInvalid                       5057
#define TriggerNameInvalid                       5058
#define MethodNameConflict                       5059
#define ParameterNameConflict                    5060
#define PropertyNameConflict                     5061
#define StorageNameConflict                      5062
#define TriggerNameConflict                      5063
#define KeyNameInvalid                           5064
#define KeyNameConflict                          5065
#define IndexNameInvalid                         5066
#define IndexNameConflict                        5067
#define QueryNameInvalid                         5068
#define QueryNameConflict                        5069
#define ClassNameConflict                        5070
#define ConstraintNameConflict                   5071
#define ConstraintSQLNameConflict                5072
#define XMLNameConflict                          5073
#define XMLNameInvalid                           5074
#define ClassDictionaryVersionMismatch           5075
#define KeyNameTooLong                           5076
#define IndexNameTooLong                         5077
#define MethodNameTooLong                        5078
#define PropertyNameTooLong                      5079
#define ParameterNameTooLong                     5080
#define QueryNameTooLong                         5081
#define StorageNameTooLong                       5082
#define StoredProcedureNameConflict              5083
#define PackageNameInvalid                       5084
#define PackageNameTooLong                       5085
#define MethodTooLarge                           5086
#define ProjectionClassRequired                  5087
#define ProjectionClassDoesNotExist              5088
#define ProjectionClassNotSub                    5089
#define ProjectionCreateError                    5090
#define ProjectionRemoveError                    5091
#define ClassCaseConflict                        5092
#define PackageCaseConflict                      5093
#define MemberNameConflict                       5094
#define ClassDescriptorConflict                  5095
#define ClassNameToLong                          5096
#define PropertyCollationInvalid                 5097
#define ConstraintNameTooLong                    5098
#define ProjectCaseConflict                      5099
#define SQLNameConflict                          5100
#define ClassNameRequired                        5101
#define EnvironmentKeywordRequired               5102
#define MethodNameRequired                       5103
#define ParameterNameRequired                    5104
#define PropertyNameRequired                     5105
#define StorageKeywordRequired                   5106
#define StorageNameRequired                      5107
#define TriggerNameRequired                      5108
#define LibraryNameRequired                      5109
#define QueryNameRequired                        5110
#define KeyNameRequired                          5111
#define IndexNameRequired                        5112
#define XMLNameRequired                          5113
#define PackageNameRequired                      5114
#define ClassDictionaryVersionTooHigh            5115
#define OneClassDictionaryVersionMismatch        5116
#define ElementSameNameInCase                    5117
#define SchemaConflict                           5118
#define PackageConflictRS                        5119
#define ClassDescriptorBig                       5120
#define ParameterValueTooLong                    5121
#define IndexSqlNameNotUnique                    5122
#define MethodEntryNotFound                      5123
#define AliasPropertyConflict                    5124
#define InvalidExportVersion                     5125
#define ExportVersionNotSupported                5126
#define ExportKeywordNotPresent                  5127
#define ExportSqlInvalidCategory                 5128
#define ExportInvalidChar                        5129
#define InvalidCharInMember                      5130
#define QueryDependentChange                     5131
#define ParamNotConfig                           5132
#define ParamNotSetable                          5133
#define ExportIndexCollatedKey                   5134
#define MVPolymorphic                            5135
#define MVCollectionClassname                    5136
#define AliasAliasConflict                       5137
#define DictionaryKeywordTypeInvalid             5149
#define DictionaryKeywordValueInvalid            5150
#define ClassAttributeKeywordInvalid             5151
#define EnvironmentKeywordInvalid                5152
#define MethodAttributeKeywordInvalid            5153
#define ParameterAttributeKeywordInvalid         5154
#define PropertyAttributeKeywordInvalid          5155
#define TriggerAttributeKeywordInvalid           5156
#define ClassKeywordTypeInvalid                  5157
#define MethodKeywordTypeInvalid                 5158
#define ParameterKeywordTypeInvalid              5159
#define PropertyKeywordTypeInvalid               5160
#define TriggerKeywordTypeInvalid                5161
#define MethodKeywordValueInvalid                5162
#define PropertyKeywordValueInvalid              5163
#define KeyAttributeKeywordInvalid               5164
#define KeyKeywordTypeInvalid                    5165
#define KeyKeywordValueInvalid                   5166
#define IndexAttributeKeywordInvalid             5167
#define IndexKeywordTypeInvalid                  5168
#define IndexKeywordValueInvalid                 5169
#define QueryAttributeKeywordInvalid             5170
#define QueryKeywordTypeInvalid                  5171
#define QueryKeywordValueInvalid                 5172
#define PropertyColumnNbrInvalid                 5173
#define XMLAttributeKeywordInvalid               5174
#define XMLKeywordTypeInvalid                    5175
#define ClassKeywordValueInvalid                 5176
#define IndexPropertyCollationInvalid            5177
#define IndexDataPropertyInvalid                 5178
#define PropertyColumnNbrNotUnique               5179
#define PropertyStreamInitialInvalid             5190
#define ParseTreeInvalid                         5201
#define NothingToCompile                         5202
#define ParserError                              5203
#define IndexTypeClassInvalid                    5250
#define MethodCanNotChangeFinal                  5251
#define ParameterCanNotChangeFinal               5252
#define PropertyCanNotChangeFinal                5253
#define SuperClassIsFinal                        5254
#define PropertyMethodCanNotOverrideFinal        5255
#define BehaviorCanNotReplaceFinal               5256
#define KeyCanNotOverride                        5257
#define IndexCanNotOverride                      5258
#define QueryTypeCanNotBeChanged                 5259
#define QueryCanNotChangeFinal                   5260
#define QueryMethodCanNotOverrideFinal           5261
#define QuerySQLViewParameterInvalid             5262
#define QuerySQLViewNotSQL                       5263
#define PropertySQLComputeOnChangeInvalid        5264
#define CanNotChangeFinalKeyword                 5265
#define PropertyMultipleDependentRelationships   5266
#define XMLCanNotChangeFinal                     5267
#define XMLMethodCanNotOverrideFinal             5268
#define MemberMethodCanNotOverrideFinal          5269
#define CompositeMethodNameConflict              5270
#define MemberCannotOverride                     5271
#define MemberCannotChangeFinal                  5272
#define AliasLoopDetected                        5273
#define AliasMethodNotFound                      5274
#define AliasSignatureMismatch                   5275
#define AliasClassNotSuperclass                  5276
#define RelationshipDependentNotRoot             5277
#define VersionPropertyNotDefined                5278
#define VersionPropertyRedefined                 5279
#define NoCalculaltedCollection                  5280
#define ClassMultipleIdentities                  5281
#define PropertyIdentityIsCollection             5282
#define PropertyIdentityNotInteger               5283
#define IndexIdNotBasedOnIdentity                5284
#define PropertySQLComputeCodeMissing            5285
#define ClassTypeCannotOverride                  5286
#define TooManyInstanceVariables                 5287
#define SkipQueued                               5288
#define DependentNotCompiled                     5289
#define MaxClassElement                          5290
#define MaxClassDepth                            5291
#define ClsAlreadyCompiled                       5292
#define DependentDeployedNotCompiled             5293
#define NotCompiledDeploy                        5294
#define MethodMissingCallTag                     5301
#define MethodMissingCode                        5302
#define MethodMissingExpression                  5303
#define MethodMissingGenerator                   5304
#define MethodMissingName                        5305
#define ParameterMissingName                     5306
#define PropertyMissingName                      5307
#define QueryMissingName                         5308
#define QueryMissingType                         5309
#define MethodSQLProcClassMethod                 5310
#define MethodSQLProcContextParameterInvalid     5311
#define ConstraintMissingName                    5312
#define ProjectionMissingType                    5313
#define MethodCodeMissing                        5314
#define MemberMethodCodeMissing                  5315
#define ClassDependencyUsesLoop                  5316
#define ClassDependencyParentSystem              5317
#define ClassDependencyDependOnLoop              5318
#define PropertyTypeRecursion                    5319
#define MultipleRowVersion                       5320
#define RelationshipOnDeleteInvalid              5330
#define PropertyOnDeleteInvalid                  5331
#define IndexMultipleShardKey                    5332
#define IndexShardKeyConditional                 5333
#define IndexShardHasData                        5334
#define IndexShardNotRootExtent                  5335
#define PropertyCollectionCounterInvalid         5349
#define ClassLockEscalate                        5350
#define ClassDoesNotExist                        5351
#define ClassNotUpToDate                         5352
#define ClassDependencyUnresolved                5353
#define CircularInheritanceDetected              5354
#define MethodGeneratorDependencyUnresolved      5355
#define CompiledStorageClassDoesNotExist         5356
#define ClassDependencyParentChildUnresolved     5357
#define MethodLanguageInvalidSQLProc             5358
#define InvalidGeneratorLang                     5359
#define ClassIsStub                              5360
#define MemberMethodDefined                      5361
#define NoMemberMethodDefined                    5362
#define MemberMethodOverridden                   5363
#define PredecessorClassUndef                    5364
#define CollectionTableNameNotUnique             5365
#define RoutinePlacementDependencyUnresolved     5367
#define ClassShutdown                            5368
#define ClassInCompile                           5369
#define MethodGeneratorDoesNotExist              5370
#define ClassSharedLockFailed                    5371
#define ClassExclusiveLockFailed                 5372
#define PredecessorClassDoesNotExist             5373
#define InvalidClassDescriptor                   5374
#define InstanceUseInClassMethod                 5375
#define NoSuchMethodorProp                       5376
#define CallInstanceMethodFromClassMethod        5377
#define ClassDeployed                            5378
#define CanNotCompileDeployedClass               5379
#define PredecessorClassDeployed                 5380
#define CanNotExportDeployedClass                5381
#define CanNotEditDeployedClass                  5382
#define SQLMapFinal                              5383
#define SQLMapKeywordFinal                       5384
#define SQLMapDataNodePieceUsed                  5385
#define InvalidSuper                             5386
#define InvalidSuperAbstract                     5387
#define ClassProtectLock                         5388
#define SuperNotIsA                              5389
#define ClassDependencyPredecessorUnresolved     5390
#define ClassDependencyNestedError               5391
#define NoSuchMethod                             5392
#define NoPropInClassMethod                      5393
#define ClassDependencySysLevel                  5394
#define InvalidRtnMethodCall                     5395
#define ClassDescriptorTooBig                    5396
#define CompileProtect                           5397
#define ClassLockTableFull                       5398
#define ClassCanNotCompileForNotUpToDate         5399
#define PropertyStoredMultiple                   5400
#define ActionTypeInvalid                        5401
#define CacheDirectMapInvalid                    5402
#define ClientDataTypeInvalid                    5403
#define CodeModeReturnedByGeneratorInvalid       5404
#define CollectionTypeInvalid                    5405
#define StorageEnvironmentDefaultInvalid         5406
#define IDCardinalityInvalid                     5407
#define IDCounterInvalid                         5408
#define IDDependencyInvalid                      5409
#define IDKeyInvalid                             5410
#define IDKeyColumnInvalid                       5411
#define IDKeyPropertyInvalid                     5412
#define IdentityTypeInvalid                      5413
#define IndexAttributeInvalid                    5414
#define KeyInvalid                               5415
#define KeyPropertyInvalid                       5416
#define MethodCodeModeInvalid                    5417
#define PropertyTypeInvalid                      5418
#define ReferenceTypeInvalid                     5419
#define StorageAliasInvalid                      5420
#define StorageDefinitionInvalid                 5421
#define NoContextUsageInvalid                    5422
#define StorageNoDataMapsDefined                 5423
#define StorageNameNotSpecified                  5424
#define PropertyParameterNotDeclared             5425
#define PropertyTypeCanNotBeChanged              5426
#define RoutineCompilationError                  5427
#define StorageClassNotSpecified                 5428
#define StorageNotDefined                        5429
#define TriggerNotDefined                        5430
#define QueryParameterNotDeclared                5431
#define QueryRowSpecTypeInvalid                  5432
#define ODBCTypeInvalid                          5433
#define SQLCategoryInvalid                       5434
#define StorageInvalidStructure                  5435
#define StorageInvalidDependency                 5436
#define StorageInvalidLiteral                    5437
#define StorageInvalidSymbol                     5438
#define StorageUndefinedSymbol                   5439
#define SerialInvalidDependency                  5440
#define StorageSymbolUndefined                   5441
#define StorageDataSubscriptConflict             5442
#define IndexMultipleIdKey                       5443
#define IndexMultiplePrimaryKey                  5444
#define IndexMultipleExtent                      5445
#define IndexIdKeyConditional                    5446
#define IndexPrimaryKeyConditional               5447
#define IndexExtentConditional                   5448
#define IndexIdKeyHasData                        5449
#define IndexExtentHasData                       5450
#define IndexExtentHasProperties                 5451
#define IndexExtentIsKey                         5452
#define DatatypeCanNotHaveProperties             5453
#define ExtentSpecAttributeInvalid               5454
#define TriggerEventInvalid                      5455
#define TriggerEventRequired                     5456
#define TriggerTimeInvalid                       5457
#define TriggerTimeRequired                      5458
#define TriggerOrderRequired                     5459
#define TriggerCodeRequired                      5460
#define InvalidStreamType                        5461
#define InvalidStreamStorageValue                5462
#define ForeignKeyAttributeInvalid               5463
#define ForeignKeyTargetClassInvalid             5464
#define ForeignKeyTargetKeyInvalid               5465
#define InvalidErrorCode                         5466
#define InvalidErrorName                         5467
#define IndexTypeInvalid                         5468
#define ViewCanNotHaveProperties                 5469
#define IndexUniqueCollationOverridden           5470
#define IndexBitMapUnique                        5471
#define IndexBitMapHasData                       5472
#define ConstraintParameterNotDeclared           5473
#define IDExternalCounterInvalid                 5474
#define RoutineCompilationErrorWithInfo          5475
#define CompilationSignatureMismatch             5476
#define KeywordSignatureError                    5477
#define KeywordTypeSignatureError                5478
#define IndexIdKeyRequired                       5479
#define MemberParameterNotDeclared               5480
#define InvalidClassStorageDefn                  5481
#define InvalidClassStorage                      5482
#define InvalidSubnodeCollection                 5483
#define NoBitmapForDependent                     5484
#define NoBitmapForIDAttribute                   5485
#define MethodLanguageInvalid                    5486
#define QueryRowspecFormatInvalid                5487
#define FormalSpecFormatInvalid                  5488
#define IndexIdkeyAbstract                       5489
#define ErrorRunningGenerator                    5490
#define RelationshipInvalidTypeCategory          5491
#define RelationshipCardinalityInvalid           5492
#define RelationshipCardinalityRequired          5493
#define RelationshipCardinalityMismatch          5494
#define RelationshipInverseRequired              5495
#define RelationshipInverseNotDefined            5496
#define RelationshipInverseMismatch              5497
#define RelationshipRelatedClassNotCompiled      5498
#define RelationshipError                        5499
#define FormalArgTypeInvalid                     5500
#define InvalidPropertySlot                      5501
#define SQLTableCompileError                     5502
#define FieldNameInvalid                         5503
#define ParentColumnInvalid                      5504
#define SQLTableParentInvalid                    5505
#define SQLCounterInvalid                        5506
#define SQLIdentityTableInvalid                  5507
#define SQLMapDataFieldInvalid                   5508
#define SQLMapRowIDFieldInvalid                  5509
#define SQLMapSubscriptInvalid                   5510
#define SQLMapTypeInvalid                        5511
#define SQLReferenceTargetInvalid                5512
#define MapExpressionMustBeField                 5513
#define MapExpressionUnknownField                5514
#define TableAlreadyExists                       5515
#define TableDoesNotExist                        5516
#define TableNotFound                            5517
#define TableIDDoesNotExist                      5518
#define SQLParentTableInvalid                    5519
#define TableReferenceInvalid                    5520
#define SQLError                                 5521
#define SQLParentTableNotExported                5522
#define TableNameInvalid                         5523
#define InvalidCurlyBraceField                   5524
#define ViewNotFound                             5525
#define BadReference                             5526
#define SQLPrivilege                             5527
#define SQLDelimitedIDOff                        5528
#define SQLIdentifierReserved                    5529
#define SQLBadLogin                              5530
#define SQLMGRMissingClass                       5531
#define GTWCConnectionError                      5532
#define GTWCAllocationError                      5533
#define GTWCColumnsError                         5534
#define GTWCTablesError                          5535
#define GTWCPrimaryKeysError                     5536
#define StreamMoveToError                        5537
#define SQLMapVarsMissingDataExpression          5538
#define SQLMapVarsMissingName                    5539
#define SQLCode                                  5540
#define MapExpressionUnknownFieldLoc0            5541
#define MapExpressionUnknownFieldLoc1            5542
#define MapExpressionUnknownFieldLoc2            5543
#define MapExpressionUnknownFieldLoc25           5544
#define MapExpressionUnknownFieldLoc3            5545
#define MapExpressionUnknownFieldLoc4            5546
#define MapExpressionUnknownFieldLoc5            5547
#define MapExpressionUnknownFieldLoc6            5548
#define MapExpressionUnknownFieldLoc7            5549
#define SQLInvalidLanguageDT                     5550
#define StorageDefaultDataNotList                5551
#define StorageInvalidParent                     5552
#define IDPropertyCollationInvalid               5553
#define DatatypeParameterIntegerNotPositive      5554
#define InorrectIntegerFormat                    5555
#define ForeignKeyCardinalityInvalid             5556
#define IndexBitSliceMultiple                    5557
#define IndexSubValueNoMethod                    5558
#define ClassDefinitionError                     5559
#define NoSaveReadOnlyMethod                     5560
#define IndexNoProperty                          5561
#define IndexSubValueUnique                      5562
#define DatatypeParameterScaleIncorrect          5563
#define StorageReferenceInUse                    5564
#define StorageReferenceRegistrationError        5565
#define LibReadOnly                              5566
#define ClassDatabaseReadOnly                    5567
#define DatatypeParameterCurrencyScale           5568
#define DatatypeParameterScaleNegative           5569
#define ExtentDatabaseReadOnly                   5570
#define NotInheritableProperty                   5571
#define SecondaryRelationship                    5572
#define RelationshipNCardinalityReq              5573
#define ErrorRunningParamGenerator               5574
#define IndexSerialPropertyPrivate               5575
#define MetaDataNotCreated                       5576
#define MetaDataCall                             5577
#define MetaDataNoMethod                         5578
#define MetaDataBadCodeMode                      5579
#define SQLPrivilege2                            5580
#define SQLBuildPurgeIndex                       5581
#define SQLGrantSamples                          5582
#define SQLMapDataNodeInvalid                    5583
#define SQLGrantDocbook                          5584
#define SQLRowIDSpecsNoCreate                    5585
#define SystemSQLInvalidArgumentValue            5586
#define SystemSQLInvalidArgumentValue2           5587
#define SystemSQLInvalidArgumentValue3           5588
#define SystemSQLInvalidArgumentValue4           5589
#define NumberOfTuplesLockFailed                 5590
#define SystemSQLInvalidArgumentValue5           5591
#define ParallelSplitError                       5592
#define ParallelSplitUnknownError                5593
#define SQLBuildPurgeIndexForRow                 5594
#define ShardTableFeatureNotSupported            5595
#define MapMissingGlobalName                     5596
#define ShardKeyIdKeyMismatch                    5597
#define StorageNotSupportedForSharding           5598
#define ShardClassMustBePersistent               5599
#define ShardClassUnsupportedFeature             5600
#define NoClassContext                           5601
#define SuperClassNotResolved                    5602
#define InstanceVariableDoesNotExist             5603
#define InstanceVariableDoesNotSupportArray      5604
#define ClassContextForInstanceVariableInvalid   5605
#define SuperUsageInvalid                        5606
#define ReferenceVariableDoesNotExist            5607
#define ReferenceVariableDoesNotSupportArray     5608
#define PrivateClassMethod                       5609
#define ReferenceMacroNotDefine                  5610
#define FunctionMacroMissingArg                  5611
#define MacroMissingRightParen                   5612
#define TooManyMacroArguments                    5613
#define NotEnoughMacroArguments                  5614
#define NoClosingParen                           5615
#define NoKeywordOpenParen                       5616
#define InvalidKeyword                           5617
#define NoKeywordCloseParen                      5618
#define InvalidKeywordArgument                   5619
#define KeywordFieldNameMissing                  5620
#define KeywordNoSuchTable                       5621
#define KeywordNoSuchField                       5622
#define KeywordUniqueInvalidArg                  5623
#define KeywordUniqueNoPrevious                  5624
#define DefineMissingMacroName                   5625
#define DefineNoClosingParen                     5626
#define DefineOneArgMultipleArg                  5627
#define DefineMacroArgNoPercent                  5628
#define DefineArgHasBadCharacter                 5629
#define ContinueWithNoMoreLines                  5630
#define NoPreceedingIf                           5631
#define IfOrElseIfMissingArg                     5632
#define IfInvalidArg                             5633
#define IfdefMissingMacroName                    5634
#define NoSuchIncludeFile                        5635
#define NoSuchLibraryFile                        5636
#define NoSuchLibraryVersion                     5637
#define SqlCompileBadMode                        5638
#define FunctionError                            5639
#define DuplicateRoutineSpec                     5640
#define RoutineSpecAfterSQL                      5641
#define RoutineSpecInvalid                       5642
#define RoutineRefNested                         5643
#define RoutineRefInvalid                        5644
#define NameConflict                             5645
#define ExpressionError                          5646
#define InvalidMacroName                         5647
#define InvalidUseOfFunction                     5648
#define TooManyMacroReferences                   5649
#define BadSQLSyntax                             5650
#define PropertyNotExecutable                    5651
#define MethodCannotSet                          5652
#define CompiledClassDoesNotExist                5653
#define MethodDoesNotExist                       5654
#define ParameterDoesNotExist                    5655
#define PropertyDoesNotExist                     5656
#define MethodHasNoReturnValue                   5657
#define ObjectInstanceRequired                   5658
#define PropertyRequired                         5659
#define QueryDoesNotExist                        5660
#define CollectionPropertyRequired               5661
#define RelationshipChildRequired                5662
#define NotSupportedInDeferredMode               5663
#define IvarInClassMethod                        5664
#define MPPFunctionError                         5665
#define MissingRequiredName                      5701
#define MissingLeftParen                         5702
#define MissingRightParen                        5703
#define NoEqualSignAfterSetLeft                  5704
#define UnbalancedQuotes                         5705
#define UnbalancedParentheses                    5706
#define UnbalancedBeginlitEndlit                 5707
#define UnexpectedElse                           5710
#define UnexpectedElseif                         5711
#define UnexpectedEndif                          5712
#define UnexpectedEndOfLine                      5720
#define UnexpectedEndOfFile                      5721
#define IncorrectDelimiter                       5730
#define InvalidExternalPackage                   5731
#define MacroNestingLimitExceeded                5732
#define NoPreviousNew                            5733
#define NoEmbeddedFile                           5734
#define Compiling                                5740
#define CompileComplete                          5741
#define IntFileFail                              5742
#define MacFileFail                              5743
#define ModuleSizeExceeded                       5744
#define CompileFailed                            5745
#define NoSplitCodeBlock                         5746
#define NoSplitLanguage                          5747
#define NoCurrentClassContext                    5748
#define PersistentProtect                        5750
#define MethodNotAccessible                      5751
#define ClassIsAbstract                          5752
#define AbstractClassNotInstantiable             5753
#define DatatypeClassNotInstantiable             5754
#define ObjectNotRegistered                      5755
#define ProcedureNameInvalid                     5756
#define ProcedureNotFound                        5757
#define MethodNotImplemented                     5758
#define PropertyReadOnly                         5759
#define FailedToOpenClass                        5760
#define FailedToNewClass                         5761
#define ClassIsReadOnly                          5762
#define FailedToCreateEmbeddedObject             5763
#define DeleteExtentObjectsRemain                5764
#define SyncDiffLocales                          5765
#define InvalidTableName                         5766
#define TableNameExists                          5767
#define ClassNameExists                          5768
#define LinkingError                             5769
#define KeyValueNotFoundOpen                     5770
#define KeyValueNotFoundDelete                   5771
#define ReadOnlyCollection                       5772
#define IdentityInsertOff                        5773
#define CounterPropertyReset                     5774
#define InheritLock                              5775
#define ConstructIndicesBAT                      5776
#define ClassIsSharded2                          5777
#define DatatypeValidationError                  5794
#define LockFailedForeignKey                     5795
#define LockFailedKey                            5796
#define KeyNotFound                              5797
#define LockFailedExtent                         5798
#define LockFailedExtentShared                   5799
#define ConcurrencyVersionMismatch               5800
#define CanNotSetSerial                          5801
#define DatatypeValidationFailed                 5802
#define LockFailedToAcquireExclusive             5803
#define LockFailedToAcquireRead                  5804
#define IDKeyNotUnique                           5805
#define LockTypeInvalid                          5806
#define OrefInvalid                              5807
#define KeyNotUnique                             5808
#define LoadObjectNotFound                       5809
#define DeleteObjectNotFound                     5810
#define LoadNoStateData                          5811
#define NullId                                   5812
#define NullOid                                  5813
#define OidPreviouslyAssigned                    5814
#define TooManyCallsToClose                      5815
#define TransactionRollBackFailed                5816
#define QueryNothingSelected                     5817
#define QueryNotClosed                           5818
#define TooManyArguments                         5819
#define CollectionKeyInvalid                     5820
#define QueryCannotInstantiate                   5821
#define QueryDynamicParameterInvalid             5822
#define RelationshipRestrictDelete               5823
#define ReferencedObjectDoesNotExist             5824
#define NotAnInstanceError                       5825
#define InterfaceNotSupported                    5826
#define SaveCyclicDependancy                     5827
#define ConcurrencyValueInvalid                  5828
#define FKEYConstraintFailed                     5829
#define FKEYReferentialActionFailed              5830
#define FKEYReferentialActionFailedNoAction      5831
#define NullIdComponent                          5832
#define PropertyValueInvalidType                 5833
#define IDKeyCounterNotValid                     5834
#define CollDisconnected                         5835
#define PropertyTypeClassIsAbstract              5836
#define NullGUID                                 5837
#define NoDevloperPriv                           5838
#define ProjectIncludesCSP                       5839
#define ImportUnknownType                        5840
#define ImportLineTooShort                       5841
#define ImportTooFewLines                        5842
#define ImportCanNotCreateDoc                    5843
#define ImportUserItemNotPresent                 5844
#define ItemNotEditable                          5845
#define SecurityNotDeveloper                     5846
#define CanNotImportDefaultProject               5847
#define CanNotExportDefaultProject               5848
#define RoutineLangInvalid                       5849
#define ProjectIncludesPackage                   5850
#define LibraryClassCanNotModify                 5851
#define LibraryClassCanNotSave                   5852
#define ElementTypeInvalid                       5853
#define GlobalReferenceInvalid                   5854
#define OidPrefixInvalid                         5855
#define SQLBindingDoesNotExist                   5856
#define StorageSQLMapDataNameRequired            5857
#define StorageSQLMapNameRequired                5858
#define StorageSQLMapRowIdSpecNameRequired       5859
#define StorageSQLMapSubscriptNameRequired       5860
#define PackageRoutinePrefixTooLong              5861
#define PackageGlobalPrefixTooLong               5862
#define CanNotLockRoutine                        5863
#define CanNotLockRoutineInfo                    5864
#define ItemNotCheckedOut                        5865
#define ProjectNoName                            5876
#define ProjectInvalidType                       5877
#define ProjectBlankName                         5878
#define ProjectNoStream                          5879
#define SourceControlClass                       5880
#define ProjectExist                             5881
#define UnableToCreateRoutine                    5882
#define RoutineProtect                           5883
#define CanNotLockCSP                            5885
#define CanNotSaveCompiledDictionaryClasses      5886
#define CanNotDeleteCompiledDictionaryClasses    5887
#define CanNotNewCompiledDictionaryClasses       5888
#define SourceControlNotLoggedIn                 5889
#define RoutineNameTooLong                       5890
#define UnableToCopyProject                      5891
#define RoutineAlreadyExists                     5892
#define InvalidRtnFile                           5893
#define TooManyItemsInImport                     5894
#define ItemProtect                              5895
#define BadTemplateMode                          5896
#define SourceControlLock                        5897
#define BadGlobalFormat                          5898
#define BadGlobalDecode                          5899
#define IncorrectPackageName                     5900
#define RuleFamilyDoesNotExist                   5901
#define RuleDoesNotExist                         5902
#define RuleNameRequired                         5903
#define AttributeRequired                        5904
#define AttributeValueInvalid                    5905
#define SessionIdMissing                         5906
#define SessionIdDoesNotExist                    5907
#define FailedToCreateClass                      5908
#define TagNotClosed                             5909
#define CSPReloginWith2Factor                    5910
#define CSPInvalidCharacterSet                   5911
#define CSPPageDoesNotExist                      5912
#define CSPInvalidContentType                    5913
#define CSPApplicationDoesNotExist               5914
#define CannotGrantLicense                       5915
#define CSPIllegalRequest                        5916
#define CSPMethodNotSupported                    5917
#define CSPSessionTimeout                        5918
#define InvalidDecrypt                           5919
#define CSPIncorrectNamespace                    5920
#define CSPAppNamespaceRequired                  5921
#define CSPTimeout                               5922
#define CSPRedirectLoop                          5923
#define CSPErrorWithErrorPage                    5924
#define ScriptCacheMissingAttribute              5925
#define CSPUnableToRedirect                      5926
#define CSPClassNameClash                        5927
#define CSPTagParsingError                       5928
#define CSPDirectiveParsingError                 5929
#define CSPIncludeFileError                      5930
#define CSPPageInProgress                        5931
#define CSPNotSupported                          5932
#define CSPServerError                           5933
#define CSPInvalidObjectClass                    5934
#define CSPFormNameLength                        5935
#define CSPFormObjectClass                       5936
#define CSPFormObject                            5937
#define CSPTagName                               5938
#define CSPSelectOref                            5939
#define CSPInvalidObjectName                     5940
#define CSPCheckboxNotList                       5941
#define CSPNoForm                                5942
#define CSPBadSQLTag                             5943
#define CSPSQLInvalidName                        5944
#define CSPSQLInvalidMode                        5945
#define CSPSQLDuplicate                          5946
#define CSPSQLNoCursor                           5947
#define CSPOBJECTDuplicate                       5948
#define CSPRuleDuplicate                         5949
#define CSPRuleClassDoesNotExist                 5950
#define CSPOnSelectError                         5951
#define CSPRuleVersion                           5952
#define CSPBrokerQuery                           5953
#define CSPPageLock                              5954
#define CSPAppFetch                              5955
#define CSPAppDirDoesNotExist                    5956
#define CSPLookupSearch                          5957
#define CSPLookupClassName                       5958
#define CSPLookupWhere                           5959
#define CSPLookupResultSet                       5960
#define CSPConvertCharacterSet                   5961
#define CSPSessionAllocate                       5962
#define CSPSysLogLevel                           5963
#define CSPLanguageChange                        5964
#define CSPInvalidLanguage                       5965
#define CSPInputCharset                          5966
#define CSPBadBrokerRequest                      5967
#define CSPBadRuleLanguage                       5968
#define CSPScriptLanguage                        5969
#define CSPBasicNoStaticSQL                      5970
#define CSPErrorTradeLicense                     5971
#define CSPSaveCallback                          5972
#define CSPPageTooBig                            5973
#define CSPPersistentEnd                         5974
#define CSPUnableToLock                          5975
#define CSPInvalidDirection                      5976
#define CSPInvalidSortDirection                  5977
#define CSPInvalidSaveEscape                     5978
#define CSPInvalidId                             5979
#define CSPPreserveInvalid                       5980
#define CSPIncludeNoArg                          5981
#define CSPSQLOnlySelect                         5982
#define CSPPageNotFound                          5983
#define CSPNeedAuthenticatedId                   5984
#define CSPInvalidSessionReuse                   5985
#define CSPUserCannotRunService                  5986
#define CSPMustBeClassmethod                     5987
#define CSPNoCookie                              5988
#define CSPRuleMixed                             5989
#define CSPSessionNotFound                       5990
#define CSPNoSoapService                         5991
#define CSPSecContextCaller                      5992
#define CSPUnknownError                          5993
#define CSPNamespaceDoesNotExist                 5994
#define CSPUnexpectedAttribute                   5995
#define CSPNoINI                                 5996
#define CSPNoUser                                5997
#define CSPNoUpdate                              5998
#define CSPPendingTwoFactorAuthentication        5999
#define CSPSecurityTokenMismatch                 6000
#define CanNotRestoreOBJ                         6001
#define NotROFile                                6002
#define CannotConvertClass                       6003
#define CannotExportClass                        6004
#define CannotImportClass                        6005
#define XMLFileFormatInvalid                     6006
#define HttpRequestContentLength                 6007
#define HttpRequestConnection                    6008
#define UnsupportedError                         6009
#define ConnectedError                           6010
#define NotConnectedError                        6011
#define POP3NoResponse                           6012
#define ConnectionFailed                         6013
#define ConnectionTerminated                     6014
#define POP3Error                                6015
#define POP3CommandError                         6016
#define POP3BlankLine                            6017
#define POP3TCPError                             6018
#define SAXLocation                              6019
#define SAXPop                                   6020
#define SAXPush                                  6021
#define GatewayFailed                            6022
#define QueryNotPrepared                         6023
#define Queryqacn                                6024
#define GatewayConnection                        6025
#define GatewayAllocate                          6026
#define NamespaceQueryError                      6027
#define PreprocessorError                        6028
#define SMTPTimeout                              6029
#define SMTPProperty                             6030
#define SMTPOpen                                 6031
#define SMTPFirst                                6032
#define SMTPResponse                             6033
#define SMTPConnectionFailed                     6034
#define SMTPUnicodeCharset                       6035
#define SMTPQuotedPrintable                      6036
#define XMLNothing                               6037
#define ActivateInit                             6038
#define ActivateNotHRESULT                       6039
#define ActivateNotNULL                          6040
#define RoutineNoClass                           6041
#define RoutineNoCode                            6042
#define DatabaseClassDefnError                   6043
#define MountDatabaseError                       6044
#define IllegalExportDir                         6045
#define DatabaseDoesNotExist                     6046
#define InvalidIdentifierFormat                  6047
#define InvalidStatementType                     6048
#define InvalidDynamicQueryParm                  6049
#define InvalidNumberParmValues                  6050
#define INTOClauseError                          6051
#define InvalidConversionDir                     6052
#define MalformedSerializedData                  6053
#define InvalidMsgDictSpec                       6054
#define LanguageNotSpecified                     6055
#define SMTPCharset                              6056
#define POP3UnexpectedError                      6057
#define POP3MessageNumber                        6058
#define HttpRequestConnect                       6059
#define MonitorInUse                             6060
#define MonitorNotRunning                        6061
#define MonitorAlreadyRunning                    6062
#define MonitorMemoryAlloc                       6063
#define MonitorStatsColl                         6064
#define MonitorNoCollection                      6065
#define InvalidCompileExtention                  6066
#define RebuildClsIdxErr                         6067
#define XMLNoCatalogFile                         6068
#define LoadGblError                             6069
#define SMTPNoSend                               6070
#define RequiredArgumentMissing                  6071
#define LicenseDataInvalid                       6072
#define LicenseFileOpenWrite                     6073
#define MimeContentTransferEncoding              6074
#define NotALegalBlockNumber                     6075
#define NotABitMapBlock                          6076
#define InvalidRtnCompare                        6077
#define StudioSourceActionInvalid                6078
#define InvalidStudioClass                       6079
#define InvalidROFormat                          6080
#define StudioAbstractDocXMLErr                  6081
#define LicenseUpgradeError                      6082
#define OperationNotLicensed                     6083
#define ErrorDetected                            6084
#define HttpRequestSSLError                      6085
#define SMTPRFC822                               6086
#define SMTPRFC822Encoding                       6087
#define HttpInvalidProxy                         6088
#define HttpConnectFail                          6089
#define MIMENoBoundary                           6090
#define MIMEBadBoundary                          6091
#define MIMEBadHeader                            6092
#define MIMEUnexpectedEnd                        6093
#define MIMENoSource                             6094
#define HTTPHeaderLong                           6095
#define InvalidGbl                               6096
#define TCPIPError                               6097
#define HTTPTempFile                             6098
#define STARTTLSConfigRequired                   6099
#define STARTTLSNotSupported                     6100
#define ComException                             6101
#define ComNoDefaultIntf                         6102
#define ComNoDispatch                            6103
#define SourceProtect                            6150
#define RoutineSourceRO                          6151
#define ProjectItemNotPresent                    6152
#define POP3NoFetch                              6153
#define HttpSocketClosed                         6154
#define HttpSSLNoCert                            6155
#define HttpSSLNoMatch                           6156
#define CSPNoSave                                6157
#define NoFullDeploy                             6158
#define HttpSSLNoConfig                          6159
#define HttpSSLRedirectNoConfig                  6160
#define HttpRedirectError                        6161
#define HttpAuthHeader                           6162
#define HttpAuthScheme                           6163
#define CannotCreateObject                       6201
#define NoMsgHandler                             6202
#define ElementMismatch                          6203
#define ProcessingInstruction                    6204
#define UnqualifiedElement                       6205
#define VersionError                             6206
#define SoapActionError                          6207
#define AttributeMismatch                        6208
#define AttributeCount                           6209
#define AttributeValue                           6210
#define AttributeMissing                         6211
#define AttributeNameSpace                       6212
#define AttributeNotInScope                      6213
#define AttributeNotQualified                    6214
#define AttributeValueNotQualified               6215
#define UnsupportedTransport                     6216
#define AddOperationFailed                       6217
#define DuplicateElement                         6218
#define UnknownError                             6219
#define InternalError                            6220
#define HeaderNotSupported                       6221
#define SoapBindingStyleError                    6222
#define SoapBodyUseError                         6223
#define XMLNoImport                              6224
#define XMLNoDTD                                 6225
#define SoapWebMethodArg                         6226
#define SOAPServerError                          6227
#define SOAPClientError                          6228
#define XMLInconsistentProjection                6229
#define XMLInvalidProjection                     6230
#define XMLInvalidFormat                         6231
#define XMLValidationFailed                      6232
#define XMLImportMalformed                       6233
#define XMLImportRequired                        6234
#define XMLImportNSErr                           6235
#define XMLImportId                              6236
#define XMLImportBadTag                          6237
#define XMLImportNoKey                           6238
#define XMLInvalidContentProjection              6239
#define SOAPNoServiceName                        6240
#define SOAPHttpOnly                             6241
#define SOAPUnexpectedStatus                     6242
#define SOAPUnexpectedType                       6243
#define SOAPNoLocation                           6244
#define SOAPClientNoPercent                      6245
#define SOAPNoResponseBody                       6246
#define SOAPNoEncodingMatch                      6247
#define SOAPFaultReceived                        6248
#define XMLReferenceNotEnabled                   6249
#define XMLNeedElementType                       6250
#define SOAPTSchemaCorrelationError              6251
#define XMLValidationNoValue                     6252
#define XMLValidationTagFound                    6253
#define XMLImportMalformedNoTag                  6254
#define XMLDataSetBadRecord                      6255
#define XMLInvalidSubstitutionGroup              6256
#define XMLInvalidChoiceType                     6257
#define XMLInvalidEncoding                       6258
#define XMLInvalidIDPROJECTION                   6259
#define XMLAttrValidationFailed                  6260
#define XMLInvalidIgnoreNULL                     6261
#define XMLInvalidXMLIO                          6262
#define XMLInvalidReference                      6263
#define XMLInvalidTypeConstraint                 6264
#define XMLInconsistentReference                 6265
#define XMLInconsistentIDReference               6266
#define XMLInvalidSummaryList                    6267
#define XMLInvalidDefaultReference               6268
#define XMLTypedDSIncomplete                     6269
#define SOAPDuplicateMethod                      6270
#define XMLTypedDSQueryClass                     6272
#define XMLDSQueryClass                          6273
#define XMLInDocument                            6275
#define XMLNotInRootElement                      6276
#define XMLImportBadType                         6277
#define XMLNoString                              6278
#define XMLMaxString                             6279
#define XMLDSNoExecute                           6280
#define XMLDerivedInconsistent                   6281
#define SOAPMalformed                            6282
#define SOAPBadSessionHeader                     6283
#define SOAPBadLogin                             6284
#define XMLNotInDocument                         6285
#define XMLOutsideRoot                           6286
#define XMLNotInTag                              6287
#define XMLDatasetSchema                         6288
#define XMLDSNoMatch                             6289
#define XMLDSNoSchema                            6290
#define XMLDSNoDataMatch                         6291
#define XMLDSColDuplicate                        6292
#define XMLTranslateTable                        6293
#define SOAPMessagePartError                     6294
#define XMLSchemaWizardError                     6295
#define XMLCycleCheck                            6296
#define XMLInvalidStreamMode                     6297
#define XMLNotAllowedStreamMode                  6298
#define XMLInvalidXMLNAME                        6299
#define XMLInvalidFormatParameter                6300
#define SAXError                                 6301
#define MsgFileFormatInvalid                     6302
#define InvalidContentHandler                    6303
#define ExportUnknownType                        6304
#define ExportUserType                           6305
#define ExportCSPNoApp                           6306
#define ExportCSPNoFile                          6307
#define ExportNoDef                              6308
#define ExportDeployed                           6309
#define MalformedURL                             6310
#define SchemaDefinitionDoesNotExist             6311
#define NoDefaultNamespaceForClass               6312
#define SchemaMonikerTypeInvalid                 6313
#define SAXWarning                               6314
#define ImportSubDoc                             6315
#define ImportNoDoc                              6316
#define XMLInvalidInheritance                    6317
#define XMLPropertyRequired                      6318
#define XMLfixedAttrError                        6320
#define RMCreateSequenceResponseRequired         6321
#define RMCreateSequenceResponseBehavior         6322
#define RMUnexpectedHeader                       6323
#define RMExpectedHeader                         6324
#define RMUnexpectedMessageNumber                6325
#define RMCloseSequenceResponseRequired          6326
#define RMTerminateSequenceResponseRequired      6327
#define RMCreateSequenceReuse                    6328
#define ServiceMessageName                       6350
#define ServiceAction                            6351
#define SOAPInvalidRequester                     6352
#define XMLUnexpectedAttribute                   6353
#define XMLInvalidNotStringContent               6354
#define SOAPNoBody                               6355
#define XMLInvalidNodeType                       6356
#define XMLParentSet                             6357
#define XMLWriteNoElement                        6358
#define SOAPNoBinary                             6359
#define SOAPBinaryMismatch                       6360
#define XMLNotEnabled                            6361
#define XMLSchemaDuplicate                       6362
#define XMLSchemaBadEncoded                      6363
#define XMLSchemaBadQualified                    6364
#define SOAPBinaryBadFormat                      6365
#define SOAPBinaryBadTopLevel                    6366
#define SOAPBinaryBadVersion                     6367
#define SOAPBinaryDupClass                       6368
#define SOAPBinaryUnknownClass                   6369
#define SOAPDupRemoteClass                       6370
#define SOAPBadRemoteClass                       6371
#define SOAPBadMultipart                         6372
#define SOAPUnsupportedVersion                   6373
#define SOAPBadVersion                           6374
#define SOAPBadEncodingStyle                     6375
#define SOAPMustUnderstandError                  6376
#define SOAPInvalidSECURITYIN                    6378
#define SOAPWSSECURITYRequired                   6379
#define WSSECURITYBadCertificate                 6380
#define WSSECURITYInvalidEncAlgo                 6381
#define WSSECURITYKeyEncFailed                   6382
#define WSSECURITYEncFailed                      6383
#define XMLInvalidMappingParameter               6384
#define XMLInconsistentMappingParameter          6385
#define XMLInconsistentGroup                     6386
#define SOAPUnsupportedArgumentStyle             6387
#define SOAPUnexpectedElement                    6388
#define SOAPBadSecurityElement                   6389
#define SOAPBadSignature                         6390
#define WSSCInvalidDerivedKey                    6391
#define WSTCollectionResponseRequired            6392
#define WSTCollectionEmptyResponse               6393
#define WSTUnexpectedResponse                    6394
#define WSTNotSupportedResponse                  6395
#define WSTNoToken                               6396
#define WSTInvalidResponseToken                  6397
#define WSSCNoKey                                6398
#define WSTCancelResponse                        6399
#define SOAPUnsupportedRequest                   6400
#define WSDLBadAttributeName                     6401
#define WSDLBadAttributeValue                    6402
#define WSDLBadAttributes                        6403
#define WSDLBadElementName                       6404
#define WSDLBadElementValue                      6405
#define WSDLBadNamespace                         6406
#define WSDLBadSchemaType                        6407
#define WSDLBadMessageType                       6408
#define WSDLBadEncoding                          6409
#define WSDLMissingAttribute                     6410
#define WSDLMissingElement                       6411
#define WSDLNoValue                              6412
#define WSDLNoCorrespondence                     6413
#define WSDLDuplicate                            6414
#define WSDLUnsupportedTransport                 6415
#define WSDLUnrecognizedElement                  6416
#define WSDLPartElement                          6417
#define WSDLLiteralEncodingParams                6418
#define WSDLInconsistentForOperation             6419
#define WSDLBindingNotSupported                  6420
#define WSDLParmCountMismatch                    6421
#define NoWSDLNamespace                          6422
#define NoSOAPNamespace                          6423
#define WSDLPartAttribute                        6424
#define WSDLMessageStyleNeeded                   6425
#define WSDLPackageNeeded                        6426
#define WSDLPolicyNoClient                       6427
#define WSDLPolicyMultiConfig                    6428
#define WSDLPolicyService                        6429
#define SOAPConfigBadRoot                        6440
#define SOAPConfigUnexpected                     6441
#define SOAPConfigDuplicate                      6442
#define SOAPConfigDuplicateClass                 6443
#define SOAPConfigNoClass                        6444
#define SOAPConfigNoMethodName                   6445
#define SOAPConfigDuplicateMethod                6446
#define SOAPPolicyUnexpected                     6447
#define SOAPConfigNameNoMatch                    6448
#define SOAPConfigInvalidName                    6449
#define SOAPConfigNotFound                       6450
#define SOAPConfigAssertionText                  6451
#define SOAPPolicyInternalError                  6452
#define SOAPPolicyUnsupportedNamespace           6453
#define SOAPPolicyNone                           6454
#define SOAPPolicyUnsupported                    6455
#define SOAPPolicyUnknown                        6456
#define SOAPPolicyNoPolicyAllowed                6457
#define SOAPPolicyUnsupportedParameter           6458
#define SOAPPolicyHeaderNamespace                6459
#define SOAPPolicyHeaderName                     6460
#define SOAPPolicyUnsupportedNested              6461
#define SOAPPolicyNestedRequired                 6462
#define SOAPPolicyNamespaceUnexpected            6463
#define SOAPPolicyOnlyOne                        6464
#define SOAPPolicyNoTokenParm                    6465
#define SOAPPolicyBadToken                       6466
#define SOAPPolicyAlgoSuite                      6467
#define SOAPPolicyTokenFormat                    6468
#define SOAPPolicyUnexpectedInclude              6469
#define SOAPPolicyTokenRequired                  6470
#define SOAPPolicySupportingTokenRequired        6471
#define SOAPConfigUnexpectedNamespace            6472
#define SOAPPolicyUnexpectedAttr                 6473
#define SOAPPolicyX509Find                       6474
#define SOAPPolicyX509FindField                  6475
#define SOAPPolicyRefNoId                        6476
#define SOAPPolicyRefNotFound                    6477
#define SOAPPolicySigningUsername                6478
#define SOAPPolicyWSDLElement                    6479
#define SOAPParamNoMethodName                    6480
#define SOAPParamNoMethod                        6481
#define SOAPParamHeaderAttrReq                   6482
#define SOAPDerivedKeyPolicy                     6483
#define SOAPParamNoActionText                    6484
#define SOAPPolicySCTToken                       6485
#define SOAPPolicySCTLifetime                    6486
#define SOAPPolicyAttrType                       6487
#define XSDXSDType                               6501
#define XSDCacheType                             6502
#define XMLProjectionLock                        6503
#define XMLNoStreamArray                         6504
#define SOAPBadNewSession                        6505
#define XSDNoSchema                              6506
#define XMLInvalidDefaultSkipNil                 6507
#define XMLNoDescendant                          6508
#define XMLTargetElement                         6509
#define QRCodeFileCanNotOpen                     6550
#define QRCodeExceptionFileCanNotOpen            6551
#define QRCodeFileNotCreated                     6552
#define QRCodeCorrectionLevel                    6553
#define QRCodeNotSupportedOnPlatform             6554
#define QRCodeInvalidDimension                   6555
#define QRCodeCorrectionLevelMaxLen              6556
#define QRCodeNotEscaped                         6557
#define LGBeanNameIsRequired                     6601
#define LGRootDirReq                             6602
#define LGClassPathReq                           6603
#define LGAppServerHomeReq                       6604
#define LGJavaHomeReq                            6605
#define LGPathReq                                6606
#define LGServerTypeReq                          6607
#define LGOnlyQuick                              6608
#define LGOnlyPersistent                         6609
#define LGOnlyClassListNotEmpty                  6610
#define LGUnsupportedServer                      6611
#define LGCMPRequiresPrimaryKey                  6612
#define LGCMPCommonCPPOutputNotSet               6613
#define LGgetClassMethodsError                   6614
#define LGgetClassPropertiesError                6615
#define LGgetClassQueriesError                   6616
#define LGgetEJBCLassNameError                   6617
#define LGgetJobNumberError                      6618
#define LGCommonOutputNotSet                     6619
#define LGCommonLanguageGeneratorNotSet          6620
#define LGEJBEasyWindowsOnly                     6621
#define LGPersistenceTypeIsBMPorCMP              6622
#define LGCMPBadRequired                         6623
#define LGMustBeAtLeastOnePersistent             6624
#define LGWebLogicRequiresTestTable              6625
#define LGNotProjectible                         6626
#define LGTransactionionIsolation                6627
#define LGConflictingInheritance                 6628
#define LGConflictingPropertyDeclaration         6629
#define LGSuperMustBeRegistered                  6630
#define LGSuperMustBePersistent                  6631
#define LGClassMustBeUpToDate                    6632
#define LGInvalidChildTable                      6633
#define LGgetClientClassDefError                 6634
#define LGQueryGetInfo                           6635
#define LGDataType                               6636
#define LGBadFormatFlags                         6637
#define LGListTooBig                             6638
#define LGgetCountMethodsError                   6639
#define LGgetCountPropertiesError                6640
#define LGgetCountQueriesError                   6641
#define LGRequiredNoProject                      6642
#define ClassNotExportable                       6643
#define LGRoutineError                           6645
#define LGPackageNameConflict                    6646
#define LGNoCppServerSideUseClient               6647
#define LGDependsOnBad                           6648
#define LGDependsOnInvalid                       6649
#define LGDependsOnServerOnly                    6650
#define LGFailedDependency                       6651
#define LGEmptyJavaBlock                         6653
#define LGManyJavaBlocks                         6654
#define LGCannotExtendCollection                 6655
#define LGPOJODoesNotAllowByRef                  6656
#define LGNoAbstractStreams                      6657
#define LGStreamCannotBeLeftmostSuper            6658
#define LGCacheLockTimeOut                       6659
#define LGQueryGetParamInfo                      6660
#define DebugAttached                            6701
#define DebugMissingPID                          6702
#define DebugInvalidPID                          6703
#define DebugTargetExited                        6704
#define DebugBreakFailed                         6705
#define DebugNoCSPAttach                         6706
#define DebugNotAttached                         6707
#define DebugUnattach                            6708
#define DebugNotStopped                          6709
#define DebugAttachFailed                        6710
#define DebugInvalidTarget                       6711
#define DebugNoMapBreakpoint                     6712
#define DebugStartFailed                         6713
#define DebugError                               6714
#define DebugBadPID                              6715
#define DebugInDebugMode                         6716
#define DebugInSignonMode                        6717
#define DebugSourceNotCompiled                   6718
#define XSLTError                                6901
#define InvalidErrorHandler                      6902
#define InvalidOutputStream                      6903
#define InvalidResultHandler                     6904
#define InvalidInputStream                       6905
#define UseFactoryMethods                        6906
#define TSQLHardError                            7001
#define TSQLCompilationError                     7002
#define ISQLHardError                            7003
#define ISQLCompilationError                     7004
#define TSQLQueryBuilderExpected                 7005
#define TSQLCompileAssignQueryToVar              7006
#define TSQLCompileRequiresProcedureBlock        7011
#define XSQLCantOpenClassDefinition              7050
#define XSQLReadUnrecognizedInput                7051
#define XSQLReadMissingRightBracket              7052
#define XSQLReadMissingStringEndQuote            7053
#define XSQLReadSyntaxError                      7054
#define XSQLProcNotQuery                         7055
#define TSQLArgumentAlreadySet                   7056
#define ErrIOSeekPastEnd                         7101
#define ErrIOFileNoReadMode                      7102
#define ErrIOFileNoWriteMode                     7103
#define ErrIONoDelegatedStream                   7104
#define ErrIONoCharTable                         7105
#define ErrIOStreamNotCloseable                  7106
#define ErrIODelegatedNotSeekable                7107
#define ErrIONotStream                           7108
#define ErrIOOpenTimeout                         7109
#define ErrIOListenTimeout                       7110
#define ErrTelnetOptionNotSet                    7150
#define ErrTelnetBadState                        7151
#define ErrTelnetInitTimeout                     7152
#define DTFailure                                7200
#define DTMaxLen                                 7201
#define DTMinLen                                 7202
#define DTMaxVal                                 7203
#define DTMinVal                                 7204
#define DTValueList                              7205
#define DTNotBoolean                             7206
#define DTNotNum                                 7207
#define DTTimeStamp                              7208
#define DTPattern                                7209
#define DTInvalidChar                            7210
#define DTNotDuration                            7211
#define DTNotGUID                                7212
#define DTNotPosix                               7213
#define DTDateTime                               7214
#define BkpOpenLogFileOutErr                     7300
#define BkpExtFreezeCantRun                      7301
#define BkpClusterMemberTCPInfo                  7302
#define BkpClusterMemberJrnSwitch                7303
#define BkpCluJrnSwitchFail                      7304
#define BkpLocJrnSwitchFail                      7305
#define BkpFailedToQuiesce                       7306
#define BkpPlaceJrnMarker                        7307
#define BkpTaskNotExist                          7308
#define BkpIsRunning                             7309
#define BkpOpenTaskErr                           7310
#define BkpNotRecorded                           7311
#define BkpUnknownPlatform                       7312
#define BkpLogFileListErr                        7313
#define BkpTaskListErr                           7314
#define BkpLogDirErr                             7315
#define BkpCreateLogFileErr                      7316
#define BkpOutDirErr                             7317
#define BkpCreateOutFileErr                      7318
#define BkpDBListFail                            7319
#define BkpUnknownType                           7320
#define BkpDBNotExist                            7321
#define BkpNotTEMP                               7322
#define BkpDBListErr                             7323
#define BkpNotInList                             7324
#define BkpJobFailed                             7325
#define BkpIJCFailed                             7326
#define BkpErrDBACK                              7327
#define BkpNoModBuiltin                          7328
#define BkpInvalidType                           7329
#define BkpNoTaskName                            7330
#define BkpInvalidTaskName                       7331
#define BkpTaskExists                            7332
#define BkNoDevice                               7333
#define BkNoRead                                 7334
#define BkVolumeCanNotOpen                       7335
#define BkNotaVolume                             7336
#define BkpSuspendRequestCleared                 7337
#define TASKMGRRunning                           7400
#define TASKNotOpen                              7401
#define TASKUserNotEnabled                       7402
#define TASKNotScheduled                         7403
#define TASKInvalidIncrement                     7404
#define TASKUserNotAuthorized                    7405
#define TASKUserDoesNotExist                     7406
#define TASKDailyEndTimeInvalid                  7408
#define TASKEndDateInvalid                       7409
#define TASKTimePeriodDay                        7410
#define TASKOutputDirectoryError                 7411
#define TASKFilenameError                        7412
#define TASKClassIsRequired                      7413
#define TASKClassNotExist                        7414
#define TASKNoneToDelete                         7415
#define TASKSchedulingProblem                    7416
#define TASKFailToSuspend                        7418
#define TASKFailToResume                         7419
#define TASKInvalidSuspendFlag                   7420
#define TASKInvalidMailServer                    7421
#define TASKNoEmailAddresses                     7422
#define TASKFailedConfigUpdate                   7423
#define TASKUnableToSendMail                     7424
#define TASKClearRunAfter                        7425
#define TASKTimePeriodWeekly                     7426
#define TASKPositiveRepeatingOffset              7427
#define TASKInvalidDayMonth                      7428
#define TASKWeeklyOffset                         7429
#define TASKInvalidDailyFrequencyTime            7430
#define TASKInvalidRunAfterTask                  7431
#define TASKStartDateInvalid                     7432
#define TASKJobRunning                           7450
#define TASKJobUntrappedError                    7451
#define TASKJobSetupError                        7452
#define TASKJobTimeout                           7453
#define TASKJobPostProcessError                  7454
#define MustEnterTapeDevice                      7460
#define TASKAuditKeepDaysInvalid                 7461
#define SSHGeneralError                          7500
#define SSHNotConnected                          7501
#define SSHHostKeyMismatch                       7502
#define SSHInvalidHostname                       7503
#define SSHTimeout                               7504
#define SSHConnected                             7505
#define SSHNoSession                             7506
#define SSHNoChannel                             7507
#define SSHNoSFTP                                7508
#define SSHSSHError                              7510
#define SSHSFTPError                             7511
#define DplyFormat                               7600
#define DplyFormatType                           7601
#define DplyVersion                              7602
#define DplyDelimId                              7603
#define DplyGblNode                              7604
#define DplyNoOBJ                                7605
#define DplyGblInUse                             7606
#define DplyGblData                              7607
#define DplyGblNodeDif                           7608
#define DplyBadFile                              7609
#define DplySigMismatch                          7610
#define InstallerInvalidManifestSpecification    7700
#define InstallerInvalidExpression               7701
#define InstallerInvalidSpecialVariable          7702
#define InstallerParserError                     7703
#define MultiNoJobs                              7800
#define MultiNoMod                               7801
#define MultiShutdown                            7802
#define MultiQueueClosed                         7803
#define MultiLockFull                            7804
#define MultiWorkRecurse                         7805
#define MultiSignalWorkers                       7806
#define MultiJobsNotStarted                      7807
#define MultiNoModLock                           7808
#define MultiWorkWorker                          7809
#define MultiInvalidQueue                        7810
#define MultiNoContext                           7811
#define MultiQueueDead                           7812
#define MultiInvalidMsg                          7813
#define MultiWorkStalled                         7814
#define MultiPreviousStop                        7815
#define MultiIPQWorker                           7816
#define MultiSemOpen                             7817
#define MultiNoZero                              7818
#define MultiQueueDeleted                        7819
#define MultiUserLogicErr                        7820
#define MultiIPQDied                             7821
#define MultiIPQNoEvent                          7822
#define MultiBadCategory                         7823
#define MultiResumeAfterFree                     7824
#define MultiStopping                            7825
#define MultiNewGroupFail                        7826
#define MultiGroupNotRead                        7827
#define ClassTypeSysNoMember                     7850
#define ClassTypeSysSuper                        7851
#define ClassTypeInvalid                         7852
#define ClassTypeSysGen                          7853
#define CPPMethodAlias                           7854
#define CPPMethodReturn                          7855
#define CPPMethodArg                             7856
#define ServiceNotEnabledForApplication          7900
#define CSPSecondFactorLoginFailed               7901
#define CSPOnApplicationAbortedLogin             7902
#define CSPSecondFactorCancelled                 7903
#define CSPMobileCall                            7904
#define CSPMobileMethod                          7905
#define CSPSessionEventClose                     7906
#define CSPWebSocketTimeout                      7950
#define CSPWebSocketClosed                       7951
#define IKDomainExists                           8000
#define IKInvalidSortField                       8001
#define IKReservedGlobalName                     8002
#define IKFailedProcessSource                    8003
#define IKFailedLockDomain                       8004
#define IKExtIdNotFound                          8005
#define IKConfigurationNotFound                  8006
#define IKFailedInitDirectInput                  8007
#define IKFailedInitIndexer                      8008
#define IKFailedLoadKB                           8009
#define IKFailedLoadLB                           8010
#define IKKBNotFound                             8011
#define IKCaughtError                            8012
#define IKListerAliasInUse                       8013
#define IKFailedResetLocation                    8014
#define IKNothingToProcess                       8015
#define IKNoConfigWithId                         8016
#define IKDomainMismatch                         8017
#define IKDomainNotExists                        8018
#define IKDomainCorrupt                          8019
#define IKDomainNamespaceError                   8020
#define IKNoDomainWithId                         8021
#define IKInternalDatasourceError                8022
#define IKFailedDeleteSource                     8023
#define IKInvalidTypeKey                         8024
#define IKMissingSourceId                        8025
#define IKMissingSrcField                        8026
#define IKMissingContinuationKey                 8027
#define IKMissingCrcField                        8028
#define IKMissingSentField                       8029
#define IKMissingRelFreq                         8030
#define IKMissingAttribute                       8031
#define IKMinimumPartLength                      8032
#define IKNoSourceSpecified                      8033
#define IKSourceDoesNotExist                     8034
#define IKSourceDoesNotExistE                    8035
#define IKNoMDFieldSpecified                     8036
#define IKMDFieldDoesNotExist                    8037
#define IKMDFieldDoesNotExistE                   8038
#define IKMDValueNotInLOV                        8039
#define IKMDFieldExists                          8040
#define IKDictionaryDoesNotExist                 8041
#define IKDictItemDoesNotExist                   8042
#define IKDictTermDoesNotExist                   8043
#define IKDictElemDoesNotExist                   8044
#define IKDictItemURIExists                      8045
#define IKDFClassDoesNotExist                    8046
#define IKDictTermIndexError                     8047
#define IKMDOperatorNotSupported                 8048
#define IKMDLovDoesNotExist                      8049
#define IKFailedLowercase                        8050
#define IKNoSuchEncoding                         8051
#define IKFailedTranscode                        8052
#define IKInvalidIndexerId                       8053
#define IKUnknownLanguageId                      8054
#define IKInvalidObjectId                        8055
#define IKFileOpenFailed                         8056
#define IKNoKBLoaded                             8057
#define IKDataItemTooLarge                       8058
#define IKAddDataFailed                          8059
#define IKInvalidObject                          8060
#define IKConfigurationExists                    8061
#define IKLanguagesMustBeList                    8062
#define IKLanguageDoesNotExist                   8063
#define IKFailedLoadLibrary                      8064
#define IKUnableCreateEngine                     8065
#define IKFailedLockIndexer                      8066
#define IKUnableOpenListerId                     8067
#define IKNgramNotEnabled                        8068
#define IKMDCannotReplaceInBatch                 8069
#define IKMDValueCountMismatch                   8070
#define IKUnableOpenConverterId                  8071
#define IKUnableOpenProcessorId                  8072
#define IKLoaderIsNotClean                       8073
#define IKIndexerProcFailed                      8074
#define IKCannotCreateLoader                     8075
#define IKFailedSplitExtId                       8076
#define IKUnknownLister                          8077
#define IKBuildExtIdFromNameRoot                 8078
#define IKMatchIdDoesNotEXist                    8079
#define IKConfigMismatch                         8080
#define IKMissingBitString                       8081
#define IKBadListForBuildGlobals                 8082
#define IKFailedToBuildGlobals                   8083
#define IKFailedJobStart                         8084
#define IKOnlyOneVSrcSupported                   8085
#define IKVirtualSourceNotFound                  8086
#define IKDictElementTooLong                     8087
#define IKGroupDoesNotExist                      8088
#define IKDuplicateExternalId                    8089
#define IKStringTooLong                          8090
#define IKBlackListExists                        8091
#define IKDictExists                             8092
#define IKBlackListDoesNotExist                  8093
#define IKInsufficientGMHeap                     8094
#define IKIllegalDomainParameter                 8095
#define IKDomainNonEmptyForParam                 8096
#define IKLicenseError                           8097
#define IKIllegalResultParam                     8098
#define IKStoreErrorInResult                     8099
#define GatewayRequestFailed                     8100
#define GatewayRequestException                  8101
#define GatewayRequestNoData                     8102
#define GatewayRequestTimeout                    8103
#define GatewayException                         8104
#define IKIllegalMaxConLength                    8200
#define IKSecurityError                          8201
#define IKMissingListerParam                     8202
#define IKListerParamError                       8203
#define IKNoListerRegistered                     8204
#define IKNoUserDictWithName                     8205
#define IKNoUserDictWithId                       8206
#define IKUserDictWithNameExists                 8207
#define IKInvalidFilter                          8208
#define IKMissingRelDom                          8209
#define IKMissingProxField                       8210
#define IKInvalidConverter                       8211
#define IKInvalidProcessor                       8212
#define IKMissingConDom                          8213
#define IKMissingField                           8214
#define IKMatProfileModified                     8215
#define IKMatProfileDoesNotExist                 8216
#define IKCannotLoadInDSDomain                   8217
#define IKMatProfileExists                       8218
#define IKIllegalMatProfileName                  8219
#define IKFeatureRequiresVersion                 8220
#define IKSysParameterSet                        8221
#define IKFailedToAcquireLock                    8222
#define IKObjectModified                         8223
#define IKEmptyDomainParamForSys                 8224
#define IKIllegalDomainParamVal                  8225
#define IKMetricIDDoesNotExist                   8226
#define IKMetricDoesNotExist                     8227
#define IKMetricTargetDoesNotExist               8228
#define IKMetricTargetNotSupported               8229
#define IKDomainIsManaged                        8230
#define IKObjectIsManaged                        8231
#define IKInternalEngineFault                    8232
#define IKGlobalsNotBuilt                        8233
#define IKModelError                             8234
#define IKSysDomVirtualOnly                      8235
#define IKSysDomNotSupported                     8236
#define IKEngineOutOfMemory                      8237
#define IKStemmingNotEnabled                     8238
#define IFSyntaxBrackets                         8239
#define RegexNoPattern                           8300
#define RegexICU                                 8301
#define URegexInternalError                      8310
#define URegexRuleSyntax                         8311
#define URegexInvalidState                       8312
#define URegexBadEscapeSequence                  8313
#define URegexPropertySyntax                     8314
#define URegexUnimplemented                      8315
#define URegexMismatchedParen                    8316
#define URegexNumberTooBig                       8317
#define URegexBadInterval                        8318
#define URegexMaxLtMin                           8319
#define URegexInvalidBackRef                     8320
#define URegexInvalidFlag                        8321
#define URegexLookBehindLimit                    8322
#define URegexSetContainsString                  8323
#define URegexOctalTooBig                        8324
#define URegexMissingCloseBracket                8325
#define URegexInvalidRange                       8326
#define URegexStackOverflow                      8327
#define URegexTimeOut                            8328
#define URegexStoppedByCaller                    8329
#define URegexIndexOutOfBounds                   8351
#define UregexIllegalArgument                    8352
#define JrnRestGUIDNotFound                      8400
#define JrnRestNameNotFound                      8401
#define JrnRestBareNotFound                      8402
#define JrnRestNameAmbiguous                     8403
#define JrnRestBareAmbiguous                     8404
#define JrnRestPriorNotFound                     8405
#define JrnRestPrefixNotFound                    8406
#define JrnRestSharedTarget                      8407
#define ClassSaveError                           8500
#define ClassLoadError                           8501
#define LicAppRetSessionOutOfScope               8600
#define LicInvalidAppname                        8601
#define LicCannotOpenLicenseFile                 8602
#define LicNotValidLicenseFile                   8603
#define LicKeyHasExpired                         8604
#define LicKeyIsInvalid                          8605
#define LicKeyInvalidForVersion                  8606
#define LicEnsembleCores                         8607
#define LicIRISCores                             8608
#define LicKeyInvalidPlatform                    8609
#define LicKeyInvalidSU                          8610
#define LicKeyAppKWNotNumeric                    8611
#define LicKeyAppKWInvalid                       8612
#define AppLicenseUserCountOverflow              8613
#define XDataBlockMissing                        8700
#define InvalidDispatchMap                       8701
#define RESTSpecMissing                          8710
#define RESTSpecNoParameter                      8711
#define RESTNoParameter                          8712
#define RESTBadType                              8713
#define RESTBadIn                                8714
#define RESTInvalidProperty                      8715
#define RESTBodyAndForm                          8716
#define RESTBody2                                8717
#define RESTDuplicateParam                       8718
#define RESTBadReference                         8719
#define RESTNoReferenceFound                     8720
#define RESTParameterDefsRef                     8721
#define RESTSpecExtraParameter                   8722
#define RESTUrlSlash                             8723
#define RESTDuplicateClass                       8724
#define RESTFileContentType                      8725
#define RESTContentType                          8726
#define RESTRequired                             8727
#define RESTInvalid                              8728
#define RESTDuplicate                            8729
#define RESTResource                             8730
#define RESTBadItemsType                         8731
#define RESTInvalidRef                           8732
#define RESTBadMethodName                        8733
#define RESTNoOverwrite                          8734
#define RESTClassExists                          8735
#define RESTOpenAPINotJSON                       8736
#define RESTOpenAPIRequired                      8737
#define RESTOpenAPIVersion                       8738
#define RESTOpenAPITypeMismatch                  8739
#define RESTOpenAPIExtraField                    8740
#define RESTOpenAPILocalRef                      8741
#define RESTOpenAPIBadRef                        8742
#define RESTOpenAPINoRef                         8744
#define RESTOpenAPIMultiRef                      8745
#define RESTOpenAPIBadType                       8746
#define RESTOpenAPIPathTemplating                8748
#define RESTNoRESTSpec                           8749
#define RESTNoWebApp                             8750
#define RESTNoRef                                8751
#define RESTBadParameterName                     8752
#define RESTNoApplication                        8753
#define RESTBadNamespace                         8754
#define RESTDevResource                          8755
#define RESTNotDynObj                            8756
#define RESTBadAccepts                           8757
#define RESTBadName                              8758
#define RESTNoWebClass                           8759
#define RESTErrorProcessingXData                 8760
#define InvalidNotification                      8800
#define NotificationProtocolNotSupported         8801
#define InvalidDeviceToken                       8802
#define APNSConnectionTimedOut                   8803
#define APNSPushNotificationFailed               8804
#define APNSPushNotificationFailedWithReason     8805
#define APNSInvalidResponse                      8806
#define APNSConnectionFailed                     8807
#define APNSConnectionTerminated                 8808
#define GCMConnectionFailed                      8809
#define GCMHTTPStatus                            8810
#define GCMPushNotificationFailed                8812
#define GCMPushNotificationFailedWithReason      8813
#define RequiredClientProperties                 8850
#define OAuth2InvalidTokenType                   8851
#define OAuth2InvalidBearerHeader                8852
#define OAuth2DuplicateToken                     8853
#define OAuth2NotSSL                             8854
#define OAuth2NoSSLConfig                        8855
#define OAuth2ResponseContentType                8856
#define OAuth2ResponseBody                       8857
#define OAuth2ResponseError                      8858
#define OAuth2ResponseUnsupported                8859
#define OAuth2ResponseInvalidExpires             8860
#define OAuth2RedirectInvalid                    8861
#define OAuth2RedirectURI                        8862
#define OAuth2GrantTypes                         8863
#define OAuth2NoConfiguration                    8864
#define OAuth2GenerateError                      8865
#define OAuth2RedirectURINeeded                  8866
#define OAuth2Multiple                           8867
#define OAuth2RequestArgument                    8868
#define OAuth2IDTokenNotValid                    8869
#define OAuth2NoAccessToken                      8871
#define OAuth2ISCOnly                            8872
#define OAuth2JWTNotValid                        8873
#define OAuth2UserinfoNotValid                   8874
#define RequiredServerDefinitionProperties       8875
#define OAuth2NoEndpoint                         8876
#define OAuth2AuthURI                            8877
#define OAuth2AuthClientSecret                   8878
#define OAuth2AuthPrivateKey                     8879
#define OAuth2DiscoveryNotValid                  8880
#define OAuth2NoRegistrationEndpoint             8881
#define OAuth2RegistrationNotValid               8882
#define OAuth2NoAuthSigning                      8883
#define OAuth2InvalidGrantType                   8884
#define OAuth2NoPrivateKey                       8885
#define OAuth2NoCredentials                      8886
#define OAuth2RSAParsingError                    8887
#define OAuth2InvalidRSAType                     8888
#define OAuth2InvalidRSAParameters               8889
#define OAuth2RSAConstructionError               8890
#define OAuth2InvalidAlg                         8891
#define OAuth2RSAKeyGenError                     8892
#define OAuth2ClientSecretTooShort               8893
#define OAuth2InvalidAlgCombination              8894
#define OAuth2InvalidSigalg                      8895
#define OAuth2NoPrivateKey1                      8896
#define OAuth2NoPublicKey                        8897
#define OAuth2NoSharedKey                        8898
#define OAuth2RSASignatureError                  8899
#define OAuth2RSAVerificationError               8900
#define OAuth2RSAEncryptionError                 8901
#define OAuth2RSADecryptionError                 8902
#define OAuth2InvalidJOSE                        8903
#define OAuth2InvalidJWT                         8904
#define OAuth2HMACVerificationError              8905
#define OAuth2AESKWError                         8906
#define OAuth2BadAuthMethods                     8907
#define OAuth2NoLocalJWKS                        8908
#define OAuth2NoRemoteJWKS                       8909
#define OAuth2ClientSecretInvalidLength          8910
#define MFTErrorResponse                         8921
#define MFTUnexpectedResponse                    8922
#define MFTRootDelete                            8923
#define MFTNoFolder                              8924
#define MFTNotSharedFolder                       8925
#define MFTFolderExpected                        8926
#define MFTFileExists                            8927
#define MFTNoURL                                 8928
#define MFTNoFile                                8929
#define MFTBadAccessLevel                        8930
#define MFTNoUser                                8931
#define MFTUnshareOwner                          8932
#define MFTNotShared                             8933
#define MFTFileNeeded                            8934
#define MFTBadConnection                         8935
#define MFTNotAuthorized                         8936
#define MFTAddUserError                          8937
#define StudioRefNotUpToDate                     9000
#define StudioRefNameExists                      9001
#define StudioRefGenerated                       9002
#define StudioRefNotOpen                         9003
#define StudioRefParse                           9004
#define StudioRefDeployed                        9005
#define InvalidExtentSize                        9100
#define ClassGlobalNameTooLong                   9101
#define HGRemoteError                            9200
#define HGInvalidOption                          9201
#define HGInvalidImportTableExistsOptionValue    9202
#define HGUnsupportedImportDatatype              9203
#define HGImportTableExists                      9204
#define HGCannotAcquireImportTableLock           9205
#define HGImportSyntaxError                      9206
#define HGSyntaxErrorAsSQLType                   9207
#define HGUnsupportedDatatypeParameter           9208
#define HGParameterUnsupportedForDatatype        9209
#define HGCardinalityNotSupported                9210
#define HGUnsupportedTimeFormat                  9211
#define HGInverseConflicts                       9212
#define HGMustSpecifyInverse                     9213
#define HGInvalidConnectionOption                9214
#define HGMustConnectToCreateMapReduceResult     9215
#define HGMustConnectToExecuteCommand            9216
#define HGMustConnectToSynchronize               9217
#define HGCannotAcquireLockToSync                9218
#define HGCannotAcquireLockToRollback            9219
#define HGNoSuchSyncJob                          9220
#define SHMShardError                            9300
#define SHMShardErrors                           9301
#define SHMTxExists                              9302
#define SHMTxInvalidStateTransition              9303
#define SHMTxAlreadyInTransaction                9304
#define SHMCannotConnectECP                      9305
#define SHMCannotDisconnectECP                   9306
#define SHMCannotCreateSemaphore                 9307
#define SHMCannotConnectTCP                      9308
#define SHMCannotDeleteSemaphore                 9309
#define SHMStorageModelNotSupported              9310
#define SHMLoadAlreadyInProgress                 9311
#define SHMNotShardedTable                       9312
#define SHMNoCompiledClass                       9313
#define SHMMultipleStorageDefs                   9314
#define SHMRemoteShardDirectory                  9315
#define SHMCannotLogin                           9316
#define SHMMapLockTimeout                        9317
#define SHMConnReset                             9318
#define SHMNotShardedNamespace                   9319
#define SHMNamespaceNotAShard                    9320
#define SHMNotPrimary                            9321
#define SHMNoSuchShard                           9322
#define SHMNotAShardAppServer                    9323
#define SHMInvalidSQLStatement                   9324
#define SHMIdRangeAlloc                          9325
#define SHMTablesWithShardKeyExist               9326
#define SHMShardActivateError                    9327
#define SHMMasterNotLocal                        9328
#define SHMCannotCreateDatabase                  9329
#define SHMDatabaseFileExists                    9330
#define SHMShardRtnNsExists                      9331
#define SHMShardRtnDbExists                      9332
#define SHMNoShardRtnDbPath                      9333
#define SHMNoShardRtnNs                          9334
#define SHMNoShardRtnDb                          9335
#define SHMSomeRowsNotDeleted                    9336
#define SHMAuthenticationError                   9337
#define SHMServiceNotEnabledOnShard              9338
#define SHMIncomingIPNotAllowed                  9339
#define SHMNoIPForHostname                       9340
#define SHMMessageSequenceError                  9341
#define SHMIPMismatch                            9342
#define SHMNoIPAvailable                         9343
#define SHMMasterNsNotMirrored                   9344
#define SHMQueryShardCannotBeMirrored            9345
#define SHMCannotDeassignShardTablesExist        9346
#define SHMNoSuchShardAddress                    9347
#define SHMEntityShardCountTooHigh               9348
#define SHMShardCleanupFailed                    9349
#define SHMShardAlreadyAssigned                  9350
#define SHMShardAssignedToAnotherMaster          9351
#define SHMNoSuchQueryShard                      9352
#define SHMNoShards                              9353
#define SHMShardVerificationError                9354
#define SHMShardVerificationErrors               9355
#define SHMQueryShardVerificationError           9356
#define SHMQueryShardVerificationErrors          9357
#define SHMUnrecognizedMsgCode                   9358
#define SHMInsufficientMaxServers                9359
#define SHMInsufficientMaxServerConn             9360
#define SHMInsufficientMaxServersMaxServerConn   9361
#define SHMQueryShardWrongDirectory              9362
#define SHMQueryShardWrongInstance               9363
#define SHMShardNotMirrored                      9364
#define SHMWrongBackupAddress                    9365
#define SHMInvalidOptionName                     9366
#define SHMInvalidOptionValue                    9367
#define SHMMasterCannotBeShard                   9368
#define SHMMirroredShardDatabaseNotMirrored      9369
#define SHMShardDbNotDismounted                  9370
#define SHMShardingNotEnabled                    9371
#define SHMQuiesceTimeout                        9372
#define SHMNotQuiesced                           9373
#define SHMReplyTimeout                          9374
#define SHMConnectBadPort                        9375
#define SHMShardingServiceNotEnabledOnShard      9376
#define SHMECPServiceNotEnabled                  9377
#define SHMRestartRequired                       9378
#define SHMClusterVersionMismatch                9379
#define SHMShardVersionMismatch                  9380
#define SHMUpgradeNeeded                         9381
#define SHMLicenseInsufficient                   9382
#define SHMShardOnMirrorDatabaseNotMirrored      9383
#define SHMShardNotPrimary                       9384
#define SHMCantConnectToEitherFailover           9385
#define SHMFailoverMemberError                   9386
#define SHMIdNotMappedToShard                    9387
#define SHMNoShardMapRanges                      9388
#define SHMUnrecognizedShardKeyType              9389
#define SHMCannotRebalanceNoShardKey             9390
#define SHMInvalidShardMap                       9391
#define SHMRebalancingNotSetupForExtent          9392
#define SHMNoShardedTables                       9393
#define SHMCannotAcquireRebalancingLock          9394
#define SHMRebalancingInProgress                 9395
#define SHMInconsistentTempDatabase              9396
#define SHMJobNotResponding                      9397
#define SHMNodeAlreadyInitialized                9398
#define SHMNodeAlreadyAttached                   9399
#define JSONInvalidDefaultParameter              9400
#define JSONInvalidPropertyParameter             9401
#define JSONNoStreamArray                        9402
#define JSONMaxString                            9403
#define JSONImportBadField                       9404
#define JSONImportRequired                       9405
#define JSONImportError                          9406
#define JSONUnexpectedNamespace                  9407
#define JSONExtraMapping                         9408
#define JSONNoPropertyName                       9409
#define JSONUnexpectedPropertyName               9410
#define JSONRefNotEnabled                        9411
#define BGTaskNoMem                              9500
#define BGTaskMemoryInUse                        9501
#define BGTaskRequestNotAllowed                  9502
#define BGTaskRequestNotAllowedState             9503
#define BGTaskNotRunning                         9505
#define BGTaskNotRunnable                        9506
#define BGTaskNotRunningInJob                    9507
#define BGTaskStartTimeout                       9508
#define BGTaskJobSignalFailed                    9509
#define BGTaskJobStartFailed                     9510
#define SHMNotSimpleCluster                      9600
#define SHMInvalidClusterURL                     9601
#define SHMNoClusterNamespace                    9602
#define SHMNotClusterNode                        9603
#define SHMConnectReadError                      9604
#define SHMNamespaceNotMirrored                  9605
#define SHMDatabaseNotMirrored                   9606
#define SHMInstanceCannotBeMirrored              9607
#define SHMInstanceNotMirrored                   9608
#define SHMClusterIsMirrored                     9609
#define SHMClusterIsNotMirrored                  9610
#define SHMMirrorHasTwoFailoverMembers           9611
#define SHMNoDirectory                           9612
#define SHMCannotAttachToSelf                    9613
#define SHMNotBackup                             9614
#define SHMCannotDeassignSelf                    9615
#define SHMDatabaseNotMirrorMatched              9616
#define SHMSameMasterAndClusterNamespace         9617
#define SHMSameMasterAndClusterDatabase          9618
#define SHMWrongMirror                           9619
#define SHMMissingParameter                      9620
#define SHMDuplicateMirrorName                   9621
#define SHMIncompleteArbiterAddress              9622
#define SHMAttemptedShardedIUDInTransaction      9623
#define SHMUpgradeNeededForSQM                   9624
#define SHMECPConnectionLockTimeout              9625
#define SHMNodeNotInitialized                    9626
#define SHMCantCatchupDb                         9627
#define IndexKeyPropertyInvalid                  15414
#define RequiresNeedObjectScript                 15415
#define RequiresNotSystemMethod                  15416
#define RequiresInvalidType                      15417
#define RequiresSigInvalid                       15418
#define RequiresNeedProcBlock                    15419
#define SQLMapConditionNull                      15511
#define IncorrectStringFormat                    15555
#define ExtentIndexReadOnly                      15570
#define ExtentIndexLockFailed                    15798
#define ExtentIndexClassLockFailed               15803
#define SourceErrorLocation                      16000
#define UnableToOpenDocument                     16001
#define InvalidJSONContent                       16002
#define PostedDataNoContent                      16003
#define UnknownRequestType                       16004
#define DocumentDoesNotExist                     16005
#define DocumentNameInvalid                      16006
#define XDebugCmdInvalid                         16007
#define DocumentDatabaseAlreadyExists            25051
#define DocumentDatabaseNameInvalid              25053
#define DocumentDatabaseNameConflict             25070
#define DocumentDatabaseDoesNotExist             25351
#define DocumentDatabaseKeyNotExist              25465
#define DocumentDatabaseFindOperatorNotValid     25540
#define DocumentDatabasePropertyNotValid         25541
#define DocumentKeyNotFound                      25797
#define DocDBInvalidContentType                  25913
#define IAMKeyDoesNotExist                       26000
#define MQTTCLIENT                               27000
#define MQTTParameterMustBe                      27001
#define MQTTParameterMaxLength                   27002
#define MQTTParameterIllegalValue                27003
#define MQTTNoCAConfigured                       27004
#define MQTTIllegalQOS                           27005
#define MQTTSendTimedOut                         27006
#define NetWebSocketErrConnectionClosed          28000
#define NetWebSocketErrPingTimeout               28001
#define NetWebSocketErrPongInvalid               28002
#define NetWebSocketErrUpgradeFailed             28003
#define NetWebSocketErrURLRequired               28004
]]></Routine>


<Class name="%ZPM.cache.Mapping">
<Super>%RegisteredObject,%XML.Adaptor</Super>
<System>2</System>
<TimeCreated>65797,80046.726092</TimeCreated>

<Parameter name="NAMESPACE">
<Default>http://www.intersystems.com/jsonmapping</Default>
</Parameter>

<Parameter name="XMLFORMAT">
<Default>literal</Default>
</Parameter>

<Parameter name="XMLIGNOREINVALIDATTRIBUTE">
<Default>0</Default>
</Parameter>

<Property name="IgnoreInvalidField">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="Null">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="IgnoreNull">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="Mapping">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="Reference">
<Type>%String</Type>
<InitialExpression>"OBJECT"</InitialExpression>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="propertyList">
<Type>%ZPM.cache.MappingProperty</Type>
<Collection>list</Collection>
<Parameter name="XMLNAME" value="Property"/>
<Parameter name="XMLPROJECTION" value="element"/>
</Property>
</Class>


<Class name="%ZPM.cache.MappingProperty">
<Super>%RegisteredObject,%XML.Adaptor</Super>
<System>2</System>
<TimeCreated>65797,80046.795163</TimeCreated>

<Parameter name="NAMESPACE">
<Default>http://www.intersystems.com/jsonmapping</Default>
</Parameter>

<Parameter name="XMLFORMAT">
<Default>literal</Default>
</Parameter>

<Parameter name="XMLIGNOREINVALIDATTRIBUTE">
<Default>0</Default>
</Parameter>

<Property name="Name">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="FieldName">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="Include">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="Null">
<Type>%Boolean</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="IgnoreNull">
<Type>%Boolean</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="Mapping">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>

<Property name="Reference">
<Type>%String</Type>
<Parameter name="XMLPROJECTION" value="attribute"/>
</Property>
</Class>


<Class name="%ZPM.cache.PropertyParameters">
<System>2</System>
<TimeCreated>65797,80046.859913</TimeCreated>

<Parameter name="%JSONFIELDNAME">
<Type>STRING</Type>
</Parameter>

<Parameter name="%JSONINCLUDE">
<Type>STRING</Type>
<Constraint>INOUT,INPUTONLY,OUTPUTONLY,NONE</Constraint>
<Flags>ENUM</Flags>
</Parameter>

<Parameter name="%JSONNULL">
<Type>BOOLEAN</Type>
</Parameter>

<Parameter name="%JSONIGNORENULL">
<Type>BOOLEAN</Type>
</Parameter>

<Parameter name="%JSONREFERENCE">
<Type>STRING</Type>
<Constraint>OBJECT,ID,OID,GUID</Constraint>
<Flags>ENUM</Flags>
</Parameter>
</Class>


<Class name="%ZPM.cache.RawString">
<Description>
This is an internal datatype used to represent string values.</Description>
<ClassType>datatype</ClassType>
<System>1</System>
<TimeCreated>65797,80046.923227</TimeCreated>
</Class>


<Routine name="%ZPM.filetempdir" type="INC"><![CDATA[
#;  %ZPM.filetempdir.inc   ; by rcc for Cach
#define FileTempDir ##class(%SYS.System).TempDirectory()_"/"_##class(%PopulateUtils).StringMin(8,8)
]]></Routine>


<Project name="zpm" LastModified="2021-02-23 10:56:13.559392">
  <Items>
    <ProjectItem name="%ZPM" type="PKG"></ProjectItem>
    <ProjectItem name="%ZPM.PackageManager.Common.INC" type="MAC"></ProjectItem>
    <ProjectItem name="%ZPM.cache.INC" type="MAC"></ProjectItem>
    <ProjectItem name="%ZPM.filetempdir.INC" type="MAC"></ProjectItem>
  </Items>
</Project>
</Export>
